<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Diagrams.Util</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Diagrams-Util.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Diagrams-Util.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">diagrams-lib-1.4: Embedded domain-specific language for declarative graphics</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) 2011-2015 diagrams-lib team (see LICENSE)</td></tr><tr><th>License</th><td>BSD-style (see LICENSE)</td></tr><tr><th>Maintainer</th><td>diagrams-discuss@googlegroups.com</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Diagrams.Util</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Utilities for users</a></li><li><a href="#g:2">Finding files</a></li><li><a href="#g:3">Finding sandboxes</a></li><li><a href="#g:4">Internal utilities</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Some miscellaneous utilities provided by the diagrams-lib package.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:with">with</a> :: <a href="http://hackage.haskell.org/packages/archive/data-default-class/0.1.2.0/doc/html/Data-Default-Class.html#t:Default">Default</a> d =&gt; d</li><li class="src short"><a href="#v:applyAll">applyAll</a> :: [a -&gt; a] -&gt; a -&gt; a</li><li class="src short"><a href="#v:-35-">(#)</a> :: a -&gt; (a -&gt; b) -&gt; b</li><li class="src short"><a href="#v:-35--35-">(##)</a> :: <a href="http://hackage.haskell.org/packages/archive/lens/4.15.1/doc/html/Control-Lens-Type.html#t:AReview">AReview</a> t b -&gt; b -&gt; t</li><li class="src short"><a href="#v:iterateN">iterateN</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (a -&gt; a) -&gt; a -&gt; [a]</li><li class="src short"><a href="#v:tau">tau</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Numeric.html#t:Floating">Floating</a> a =&gt; a</li><li class="src short"><a href="#v:findHsFile">findHsFile</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:IO">IO</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:FilePath">FilePath</a>)</li><li class="src short"><a href="#v:findSandbox">findSandbox</a> :: [<a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:FilePath">FilePath</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:IO">IO</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:FilePath">FilePath</a>)</li><li class="src short"><a href="#v:globalPackage">globalPackage</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:FilePath">FilePath</a></li><li class="src short"><a href="#v:foldB">foldB</a> :: (a -&gt; a -&gt; a) -&gt; a -&gt; [a] -&gt; a</li></ul></div><div id="interface"><h1 id="g:1">Utilities for users</h1><div class="top"><p class="src"><a id="v:with" class="def">with</a> :: <a href="http://hackage.haskell.org/packages/archive/data-default-class/0.1.2.0/doc/html/Data-Default-Class.html#t:Default">Default</a> d =&gt; d <a href="src/Diagrams-Util.html#with" class="link">Source</a> <a href="#v:with" class="selflink">#</a></p><div class="doc"><p>Several functions exported by the diagrams library take a number
   of arguments giving the user control to &quot;tweak&quot; various aspects
   of their behavior.  Rather than give such functions a long list
   of arguments, and to make it possible for the user to selectively
   override only certain arguments and use default values for
   others, such sets of arguments are collected into a record with
   named fields (see <code>PolygonOpts</code> in <a href="Diagrams-TwoD-Shapes.html">Diagrams.TwoD.Shapes</a> for an
   example).  Such record types are made instances of the <code><a href="http://hackage.haskell.org/packages/archive/data-default-class/0.1.2.0/doc/html/Data-Default-Class.html#t:Default">Default</a></code>
   class, which provides a single record structure (<code><a href="http://hackage.haskell.org/packages/archive/data-default-class/0.1.2.0/doc/html/Data-Default-Class.html#v:def">def</a></code>)
   collecting the &quot;default&quot; arguments to the function.  <code>with</code> is
   a synonym for <code><a href="http://hackage.haskell.org/packages/archive/data-default-class/0.1.2.0/doc/html/Data-Default-Class.html#v:def">def</a></code>, which provides nice-looking syntax for
   simulating optional, named arguments in Haskell.  For example,</p><pre>  polygon with {sides = 7, edgeSkip = 2}
  </pre><p>calls the <code>polygon</code> function with a single argument (note that
   record update binds more tightly than function application!),
   namely, <code><a href="Diagrams-Util.html#v:with">with</a></code> (the record of default arguments) where the
   <code>sides</code> and <code>edgeSkip</code> fields have been updated.</p></div></div><div class="top"><p class="src"><a id="v:applyAll" class="def">applyAll</a> :: [a -&gt; a] -&gt; a -&gt; a <a href="src/Diagrams-Util.html#applyAll" class="link">Source</a> <a href="#v:applyAll" class="selflink">#</a></p><div class="doc"><p><code>applyAll</code> takes a list of functions and applies them all to a
   value, in sequence from the last function in the list to the first.
   For example, <code>applyAll [f1, f2, f3] a == f1 . f2 . f3 $ a</code>.</p></div></div><div class="top"><p class="src"><a id="v:-35-" class="def">(#)</a> :: a -&gt; (a -&gt; b) -&gt; b <span class="fixity">infixl 8</span><span class="rightedge"></span> <a href="src/Diagrams-Util.html#%23" class="link">Source</a> <a href="#v:-35-" class="selflink">#</a></p><div class="doc"><p>Postfix function application, for conveniently applying
   attributes.  Unlike <code>($)</code>, <code>(#)</code> has a high precedence (8), so <code>d
   # foo # bar</code> can be combined with other things using operators
   like <code>(|||)</code> or <code>(&lt;&gt;)</code> without needing parentheses.</p></div></div><div class="top"><p class="src"><a id="v:-35--35-" class="def">(##)</a> :: <a href="http://hackage.haskell.org/packages/archive/lens/4.15.1/doc/html/Control-Lens-Type.html#t:AReview">AReview</a> t b -&gt; b -&gt; t <span class="fixity">infixr 8</span><span class="rightedge"></span> <a href="src/Diagrams-Util.html#%23%23" class="link">Source</a> <a href="#v:-35--35-" class="selflink">#</a></p><div class="doc"><p>A replacement for lenses' <code><a href="http://hackage.haskell.org/packages/archive/lens/4.15.1/doc/html/Control-Lens-Review.html#v:-35-">#</a></code> operator.</p></div></div><div class="top"><p class="src"><a id="v:iterateN" class="def">iterateN</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (a -&gt; a) -&gt; a -&gt; [a] <a href="src/Diagrams-Util.html#iterateN" class="link">Source</a> <a href="#v:iterateN" class="selflink">#</a></p><div class="doc"><p><code>iterateN n f x</code> returns the list of the first <code>n</code> iterates of
   <code>f</code> starting at <code>x</code>, that is, the list <code>[x, f x, f (f x), ...]</code>
   of length <code>n</code>. (Note that the last element of the list will be
   <code>f</code> applied to <code>x</code> <code>(n-1)</code> times.)</p></div></div><div class="top"><p class="src"><a id="v:tau" class="def">tau</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Numeric.html#t:Floating">Floating</a> a =&gt; a <a href="src/Diagrams-Util.html#tau" class="link">Source</a> <a href="#v:tau" class="selflink">#</a></p><div class="doc"><p>The circle constant, the ratio of a circle's circumference to its
   <em>radius</em>.  Note that <code>pi = tau/2</code>.</p><p>For more information and a well-reasoned argument why we should
   all be using tau instead of pi, see <em>The Tau Manifesto</em>,
   <a href="http://tauday.com/">http://tauday.com/</a>.</p><p>To hear what it sounds like (and to easily memorize the first 30
   digits or so), try <a href="http://youtu.be/3174T-3-59Q">http://youtu.be/3174T-3-59Q</a>.</p></div></div><h1 id="g:2">Finding files</h1><div class="top"><p class="src"><a id="v:findHsFile" class="def">findHsFile</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:IO">IO</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:FilePath">FilePath</a>) <a href="src/Diagrams-Util.html#findHsFile" class="link">Source</a> <a href="#v:findHsFile" class="selflink">#</a></p><div class="doc"><p>Given some file (no extension or otherwise) try to find a haskell
   source file.</p></div></div><h1 id="g:3">Finding sandboxes</h1><div class="top"><p class="src"><a id="v:findSandbox" class="def">findSandbox</a> :: [<a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:FilePath">FilePath</a>] -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:IO">IO</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:FilePath">FilePath</a>) <a href="src/Diagrams-Util.html#findSandbox" class="link">Source</a> <a href="#v:findSandbox" class="selflink">#</a></p><div class="doc"><p>Search for a sandbox in the following order:</p><ul><li>Test given FilePaths if they point directly to a database or
     contain a cabal config file (or any parent directory containing a
     config file).</li><li>Same test for <code>DIAGRAMS_SANDBOX</code> environment value</li><li>Environment values of <code>GHC_PACKAGE_PATH</code>, <code>HSENV</code> and
     <code>PACKAGE_DB_FOR_GHC</code> that point to a database.</li><li>Test for config file (cabal.sandbox.config) in the current
     directory and its parents.</li></ul></div></div><div class="top"><p class="src"><a id="v:globalPackage" class="def">globalPackage</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/System-IO.html#t:FilePath">FilePath</a> <a href="src/Diagrams-Util.html#globalPackage" class="link">Source</a> <a href="#v:globalPackage" class="selflink">#</a></p><div class="doc"><p>Find ghc's global package database. Throws an error if it isn't
   found.</p></div></div><h1 id="g:4">Internal utilities</h1><div class="top"><p class="src"><a id="v:foldB" class="def">foldB</a> :: (a -&gt; a -&gt; a) -&gt; a -&gt; [a] -&gt; a <a href="src/Diagrams-Util.html#foldB" class="link">Source</a> <a href="#v:foldB" class="selflink">#</a></p><div class="doc"><p>Given an associative binary operation and a default value to use
   in the case of an empty list, perform a <em>balanced</em> fold over a
   list.  For example,</p><pre>  foldB (+) z [a,b,c,d,e,f] == ((a+b) + (c+d)) + (e+f)
  </pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.2</p></div></body></html>