<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Diagrams.Layout.Wrap</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Diagrams-Layout-Wrap.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Diagrams-Layout-Wrap.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">diagrams-contrib-1.4.0.1: Collection of user contributions to diagrams EDSL</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) 2012 Michael Sloan</td></tr><tr><th>License</th><td>BSD-style (see the LICENSE file)</td></tr><tr><th>Maintainer</th><td>Michael Sloan &lt;mgsloan at gmail&gt;</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Diagrams.Layout.Wrap</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>An algorithm for filling space in a fashion akin to word-wrapping.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:wrapDiagram">wrapDiagram</a> :: (<a href="http://hackage.haskell.org/packages/archive/linear/1.20.5/doc/html/Linear-Metric.html#t:Metric">Metric</a> v, <a href="../diagrams-core/Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> n) =&gt; ([(v n, <a href="../diagrams-core/Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v n <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Monoid.html#t:Any">Any</a>)], [<a href="../diagrams-core/Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v n <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Monoid.html#t:Any">Any</a>]) -&gt; <a href="../diagrams-core/Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v n <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Monoid.html#t:Any">Any</a></li><li class="src short"><a href="#v:wrapOutside">wrapOutside</a> :: (<a href="../diagrams-core/Diagrams-Core-Envelope.html#t:Enveloped">Enveloped</a> a, <a href="../diagrams-core/Diagrams-Core-V.html#t:V">V</a> a ~ v, <a href="../diagrams-core/Diagrams-Core-V.html#t:N">N</a> a ~ n, <a href="http://hackage.haskell.org/packages/archive/linear/1.20.5/doc/html/Linear-Epsilon.html#t:Epsilon">Epsilon</a> n) =&gt; (<a href="../diagrams-core/Diagrams-Core-Points.html#t:Point">Point</a> v n -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a>) -&gt; [v n] -&gt; <a href="../diagrams-core/Diagrams-Core-Points.html#t:Point">Point</a> v n -&gt; [a] -&gt; ([(v n, a)], [a])</li><li class="src short"><a href="#v:wrapInside">wrapInside</a> :: <span class="keyword">forall</span> a v n. (<a href="../diagrams-core/Diagrams-Core-Envelope.html#t:Enveloped">Enveloped</a> a, <a href="../diagrams-core/Diagrams-Core-V.html#t:V">V</a> a ~ v, <a href="../diagrams-core/Diagrams-Core-V.html#t:N">N</a> a ~ n, <a href="http://hackage.haskell.org/packages/archive/linear/1.20.5/doc/html/Linear-Metric.html#t:Metric">Metric</a> v, <a href="../diagrams-core/Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> n, <a href="http://hackage.haskell.org/packages/archive/linear/1.20.5/doc/html/Linear-Epsilon.html#t:Epsilon">Epsilon</a> n) =&gt; (<a href="../diagrams-core/Diagrams-Core-Points.html#t:Point">Point</a> v n -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a>) -&gt; [v n] -&gt; <a href="../diagrams-core/Diagrams-Core-Points.html#t:Point">Point</a> v n -&gt; [a] -&gt; ([(v n, a)], [a])</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:wrapDiagram" class="def">wrapDiagram</a> :: (<a href="http://hackage.haskell.org/packages/archive/linear/1.20.5/doc/html/Linear-Metric.html#t:Metric">Metric</a> v, <a href="../diagrams-core/Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> n) =&gt; ([(v n, <a href="../diagrams-core/Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v n <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Monoid.html#t:Any">Any</a>)], [<a href="../diagrams-core/Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v n <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Monoid.html#t:Any">Any</a>]) -&gt; <a href="../diagrams-core/Diagrams-Core-Types.html#t:QDiagram">QDiagram</a> b v n <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Monoid.html#t:Any">Any</a> <a href="src/Diagrams-Layout-Wrap.html#wrapDiagram" class="link">Source</a> <a href="#v:wrapDiagram" class="selflink">#</a></p><div class="doc"><p><code>wrapDiagram</code> post-processes the results of <code>wrapOutside</code> /
   <code>wrapInside</code> into a Diagram of the result.  This only works when
   applying them to a list of diagrams.</p></div></div><div class="top"><p class="src"><a id="v:wrapOutside" class="def">wrapOutside</a> :: (<a href="../diagrams-core/Diagrams-Core-Envelope.html#t:Enveloped">Enveloped</a> a, <a href="../diagrams-core/Diagrams-Core-V.html#t:V">V</a> a ~ v, <a href="../diagrams-core/Diagrams-Core-V.html#t:N">N</a> a ~ n, <a href="http://hackage.haskell.org/packages/archive/linear/1.20.5/doc/html/Linear-Epsilon.html#t:Epsilon">Epsilon</a> n) =&gt; (<a href="../diagrams-core/Diagrams-Core-Points.html#t:Point">Point</a> v n -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a>) -&gt; [v n] -&gt; <a href="../diagrams-core/Diagrams-Core-Points.html#t:Point">Point</a> v n -&gt; [a] -&gt; ([(v n, a)], [a]) <a href="src/Diagrams-Layout-Wrap.html#wrapOutside" class="link">Source</a> <a href="#v:wrapOutside" class="selflink">#</a></p><div class="doc"><p><code>wrapOutside</code> is the same as <code>wrapInside</code>, but with an inverted
   predicate.</p></div></div><div class="top"><p class="src"><a id="v:wrapInside" class="def">wrapInside</a> :: <span class="keyword">forall</span> a v n. (<a href="../diagrams-core/Diagrams-Core-Envelope.html#t:Enveloped">Enveloped</a> a, <a href="../diagrams-core/Diagrams-Core-V.html#t:V">V</a> a ~ v, <a href="../diagrams-core/Diagrams-Core-V.html#t:N">N</a> a ~ n, <a href="http://hackage.haskell.org/packages/archive/linear/1.20.5/doc/html/Linear-Metric.html#t:Metric">Metric</a> v, <a href="../diagrams-core/Diagrams-Core-Envelope.html#t:OrderedField">OrderedField</a> n, <a href="http://hackage.haskell.org/packages/archive/linear/1.20.5/doc/html/Linear-Epsilon.html#t:Epsilon">Epsilon</a> n) =&gt; (<a href="../diagrams-core/Diagrams-Core-Points.html#t:Point">Point</a> v n -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.9.0.0/doc/html/Data-Bool.html#t:Bool">Bool</a>) -&gt; [v n] -&gt; <a href="../diagrams-core/Diagrams-Core-Points.html#t:Point">Point</a> v n -&gt; [a] -&gt; ([(v n, a)], [a]) <a href="src/Diagrams-Layout-Wrap.html#wrapInside" class="link">Source</a> <a href="#v:wrapInside" class="selflink">#</a></p><div class="doc"><p><code>wrapInside</code> greedily wraps content to fill a space defined by a
   predicate.  It is passed a list of vectors which express the
   order of dimensions to be filled.  In other words, wrapping RTL
   text is done by passing in [unitX, unitY], to first exhaust
   space horizontally, and then vertically.</p><p>Note that this function does not guarantee that there are not
   points inside each positioned item for which the predicate is
   False.  Instead, only the corners of the bounds, along each axii,
   are used.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.2</p></div></body></html>