<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Diagrams - Diagrams User Manual</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <!-- Bootstrap -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="../css/bootstrap.min.css" rel="stylesheet" />
    <link href="../css/sticky-footer-navbar.css" rel="stylesheet" />
    <link href="../css/callout.css" rel="stylesheet" />
    <link href="../css/doc.css" rel="stylesheet" />
    <link href="../css/bootstrap-docs.css" rel="stylesheet" />
    <link href="../css/home.css" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <link rel="shortcut icon" href="../diagrams.ico" />

    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>

    <div id="wrap">

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">diagrams</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav pull-right">
            <li><a href="../">Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
              <ul class="dropdown-menu">
		<li><a href="../download.html">Installation</a></li>
		<li class="divider"></li>
 		<li><a href="../tutorials.html">Tutorials</a></li>
		<li><a href="../doc/manual.html">User manual</a></li>
                <li><a href="../haddock/index.html">API reference (Haddocks)</a></li>
                <li><a href="../doc/core.html">Core library reference</a></li>
		<li class="divider"></li>
		<li><a href="http://haskell.org/haskellwiki/Diagrams">Wiki</a></li>
		<li><a href="../releases.html">Releases / changelogs</a></li>
              </ul>
            </li>
	    <li><a href="../gallery.html">Gallery</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <b class="caret"></b></a>
	      <ul class="dropdown-menu">
		<li><a href="http://webchat.freenode.net?channels=diagrams">IRC channel</a></li>
		<li><a href="http://groups.google.com/group/diagrams-discuss">Mailing
		    list</a></li>
                <li><a href="https://github.com/diagrams">Github</a></li>
		<li><a href="../sightings.html">Sightings</a></li>
		<li><a href="../community.html">Get involved</a></li>
              </ul>
	    </li>
            <li><a href="../blog/index.html">Blog</a></li>
	    <li>
	        <form id="search" class="navbar-form navbar-left" role="search" method="get" action="http://haskell.org/hoogle">
	            <div class="form-group">
	                <input id="hoogle" name="hoogle" type="text" class="form-control" placeholder="API Search">
	            </div>
	        </form>
	    </li>
	   </ul>
        </div>
      </div>
    </div>
    
    <div class="container" style="padding-top: 60px;">
      <?xml version="1.0" encoding="UTF-8" ?>
<div class="container bs-docs-container"><div class="row"><div class="col-md-3"><div class="bs-sidebar hidden-print" role="complementary" data-spy="affix"><ul class="nav"><li><a class="reference internal" href="#preliminaries"><generated classes="sectnum">1   </generated>Preliminaries</a><ul class="nav"><li><a class="reference internal" href="#introduction"><generated classes="sectnum">1.1   </generated>Introduction</a></li><li><a class="reference internal" href="#about-this-document"><generated classes="sectnum">1.2   </generated>About this document</a></li><li><a class="reference internal" href="#other-resources"><generated classes="sectnum">1.3   </generated>Other resources</a></li><li><a class="reference internal" href="#installation"><generated classes="sectnum">1.4   </generated>Installation</a></li><li><a class="reference internal" href="#getting-started"><generated classes="sectnum">1.5   </generated>Getting started</a></li><li><a class="reference internal" href="#contributing"><generated classes="sectnum">1.6   </generated>Contributing</a></li></ul></li><li><a class="reference internal" href="#essential-concepts"><generated classes="sectnum">2   </generated>Essential concepts</a><ul class="nav"><li><a class="reference internal" href="#semigroups-and-monoids"><generated classes="sectnum">2.1   </generated>Semigroups and monoids</a></li><li><a class="reference internal" href="#faking-optional-named-arguments"><generated classes="sectnum">2.2   </generated>Faking optional named arguments</a></li><li><a class="reference internal" href="#postfix-transformation"><generated classes="sectnum">2.3   </generated>Postfix transformation</a></li><li><a class="reference internal" href="#vectors-and-points"><generated classes="sectnum">2.4   </generated>Vectors and points</a></li><li><a class="reference internal" href="#envelopes-and-local-vector-spaces"><generated classes="sectnum">2.5   </generated>Envelopes and local vector spaces</a></li><li><a class="reference internal" href="#measurement-units"><generated classes="sectnum">2.6   </generated>Measurement units</a><ul class="nav"><li><a class="reference internal" href="#local-units">Local units</a></li><li><a class="reference internal" href="#global-units">Global units</a></li><li><a class="reference internal" href="#normalized-units">Normalized units</a></li><li><a class="reference internal" href="#output-units">Output units</a></li></ul></li><li><a class="reference internal" href="#types-and-type-classes"><generated classes="sectnum">2.7   </generated>Types and type classes</a></li></ul></li><li><a class="reference internal" href="#creating-2d-diagrams"><generated classes="sectnum">3   </generated>Creating 2D diagrams</a><ul class="nav"><li><a class="reference internal" href="#basic-2d-types"><generated classes="sectnum">3.1   </generated>Basic 2D types</a><ul class="nav"><li><a class="reference internal" href="#euclidean-2-space">Euclidean 2-space</a></li><li><a class="reference internal" href="#angles">Angles</a></li><li><a class="reference internal" href="#directions">Directions</a></li></ul></li><li><a class="reference internal" href="#primitive-shapes"><generated classes="sectnum">3.2   </generated>Primitive shapes</a><ul class="nav"><li><a class="reference internal" href="#circles-and-ellipses">Circles and ellipses</a></li><li><a class="reference internal" href="#arcs">Arcs</a></li><li><a class="reference internal" href="#pre-defined-shapes">Pre-defined shapes</a></li><li><a class="reference internal" href="#general-polygons">General polygons</a></li><li><a class="reference internal" href="#star-polygons">Star polygons</a></li></ul></li><li><a class="reference internal" href="#composing-diagrams"><generated classes="sectnum">3.3   </generated>Composing diagrams</a><ul class="nav"><li><a class="reference internal" href="#superimposing-diagrams-with-atop">Superimposing diagrams with <code>atop</code></a></li><li><a class="reference internal" href="#juxtaposing-diagrams">Juxtaposing diagrams</a></li><li><a class="reference internal" href="#juxtaposing-without-composing">Juxtaposing without composing</a></li><li><a class="reference internal" href="#concatenating-diagrams">Concatenating diagrams</a></li></ul></li><li><a class="reference internal" href="#modifying-diagrams"><generated classes="sectnum">3.4   </generated>Modifying diagrams</a><ul class="nav"><li><a class="reference internal" href="#attributes-and-styles">Attributes and styles</a></li><li><a class="reference internal" href="#texture">Texture</a></li><li><a class="reference internal" href="#static-attributes">Static attributes</a></li><li><a class="reference internal" href="#d-transformations">2D Transformations</a></li><li><a class="reference internal" href="#deformations">Deformations</a></li><li><a class="reference internal" href="#alignment">Alignment</a></li><li><a class="reference internal" href="#aligned-composition">Aligned composition</a></li></ul></li><li><a class="reference internal" href="#trails-and-paths"><generated classes="sectnum">3.5   </generated>Trails and paths</a><ul class="nav"><li><a class="reference internal" href="#segments">Segments</a></li><li><a class="reference internal" href="#trails">Trails</a></li><li><a class="reference internal" href="#located">Located</a></li><li><a class="reference internal" href="#paths">Paths</a></li><li><a class="reference internal" href="#vertices-vs-points">Vertices vs points</a></li><li><a class="reference internal" href="#stroking-trails-and-paths">Stroking trails and paths</a></li><li><a class="reference internal" href="#offsets-of-segments-trails-and-paths">Offsets of segments, trails, and paths</a></li><li><a class="reference internal" href="#expand-segments-trails-and-paths">Expand segments, trails, and paths</a></li><li><a class="reference internal" href="#the-traillike-class">The <code>TrailLike</code> class</a></li><li><a class="reference internal" href="#segments-and-trails-as-parametric-objects">Segments and trails as parametric objects</a></li><li><a class="reference internal" href="#splines">Splines</a></li><li><a class="reference internal" href="#fill-rules">Fill rules</a></li><li><a class="reference internal" href="#clipping">Clipping</a></li><li><a class="reference internal" href="#boolean-operations-on-paths">Boolean operations on paths</a></li><li><a class="reference internal" href="#trail-and-path-implementation-details">Trail and path implementation details</a></li></ul></li><li><a class="reference internal" href="#arrows"><generated classes="sectnum">3.6   </generated>Arrows</a></li><li><a class="reference internal" href="#text"><generated classes="sectnum">3.7   </generated>Text</a><ul class="nav"><li><a class="reference internal" href="#font-size">Font size</a></li><li><a class="reference internal" href="#native-font-support">Native font support</a></li></ul></li><li><a class="reference internal" href="#images"><generated classes="sectnum">3.8   </generated>Images</a></li></ul></li><li><a class="reference internal" href="#advanced-tools-for-diagram-creation"><generated classes="sectnum">4   </generated>Advanced tools for diagram creation</a><ul class="nav"><li><a class="reference internal" href="#envelopes"><generated classes="sectnum">4.1   </generated>Envelopes</a><ul class="nav"><li><a class="reference internal" href="#envelope-related-functions">Envelope-related functions</a></li><li><a class="reference internal" href="#the-enveloped-class">The <code>Enveloped</code> class</a></li></ul></li><li><a class="reference internal" href="#traces"><generated classes="sectnum">4.2   </generated>Traces</a></li><li><a class="reference internal" href="#path-and-trail-intersections"><generated classes="sectnum">4.3   </generated>Path and trail intersections</a></li><li><a class="reference internal" href="#named-subdiagrams"><generated classes="sectnum">4.4   </generated>Named subdiagrams</a><ul class="nav"><li><a class="reference internal" href="#giving-names">Giving names</a></li><li><a class="reference internal" href="#user-defined-names">User-defined names</a></li><li><a class="reference internal" href="#listing-names">Listing names</a></li><li><a class="reference internal" href="#accessing-names">Accessing names</a></li><li><a class="reference internal" href="#subdiagrams">Subdiagrams</a></li><li><a class="reference internal" href="#qualifying-names">Qualifying names</a></li><li><a class="reference internal" href="#localizing-names">Localizing names</a></li></ul></li><li><a class="reference internal" href="#using-queries"><generated classes="sectnum">4.5   </generated>Using queries</a><ul class="nav"><li><a class="reference internal" href="#the-default-query">The default query</a></li><li><a class="reference internal" href="#using-other-monoids">Using other monoids</a></li><li><a class="reference internal" href="#queries-and-fill-rules">Queries and fill rules</a></li><li><a class="reference internal" href="#generalized-queries">Generalized queries</a></li></ul></li><li><a class="reference internal" href="#bounding-boxes"><generated classes="sectnum">4.6   </generated>Bounding boxes</a></li><li><a class="reference internal" href="#scale-invariance"><generated classes="sectnum">4.7   </generated>Scale-invariance</a></li><li><a class="reference internal" href="#measurement-expressions"><generated classes="sectnum">4.8   </generated>Measurement expressions</a></li></ul></li><li><a class="reference internal" href="#tips-and-tricks"><generated classes="sectnum">5   </generated>Tips and tricks</a><ul class="nav"><li><a class="reference internal" href="#polymorphic-diagrams-and-partialtypesignatures"><generated classes="sectnum">5.1   </generated>Polymorphic diagrams and <code>PartialTypeSignatures</code></a></li><li><a class="reference internal" href="#using-absolute-coordinates"><generated classes="sectnum">5.2   </generated>Using absolute coordinates</a></li><li><a class="reference internal" href="#delayed-composition"><generated classes="sectnum">5.3   </generated>Delayed composition</a></li><li><a class="reference internal" href="#naming-vertices"><generated classes="sectnum">5.4   </generated>Naming vertices</a></li><li><a class="reference internal" href="#deciphering-error-messages"><generated classes="sectnum">5.5   </generated>Deciphering error messages</a><ul class="nav"><li><a class="reference internal" href="#couldn-t-match-type-v-p2-double-with-v2-double">Couldn't match type <code class="sourceCode"><span class="dt">V</span> (<span class="dt">P2</span> <span class="dt">Double</span>)</code> with <code class="sourceCode"><span class="dt">V2</span> <span class="dt">Double</span></code></a></li><li><a class="reference internal" href="#could-not-deduce-n-a0-n-a">Could not deduce N a0 ~ N a ...</a></li><li><a class="reference internal" href="#could-not-deduce-isname-a0">Could not deduce (IsName a0)</a></li></ul></li></ul></li><li><a class="reference internal" href="#creating-3d-diagrams"><generated classes="sectnum">6   </generated>Creating 3D diagrams</a></li><li><a class="reference internal" href="#animation"><generated classes="sectnum">7   </generated>Animation</a><ul class="nav"><li><a class="reference internal" href="#active"><generated classes="sectnum">7.1   </generated>Active</a></li><li><a class="reference internal" href="#using-active-with-diagrams"><generated classes="sectnum">7.2   </generated>Using Active with diagrams</a></li><li><a class="reference internal" href="#animated-gifs"><generated classes="sectnum">7.3   </generated>Animated GIFs</a></li></ul></li><li><a class="reference internal" href="#rendering-backends"><generated classes="sectnum">8   </generated>Rendering backends</a><ul class="nav"><li><a class="reference internal" href="#calling-backends"><generated classes="sectnum">8.1   </generated>Calling backends</a></li><li><a class="reference internal" href="#the-svg-backend"><generated classes="sectnum">8.2   </generated>The SVG backend</a></li><li><a class="reference internal" href="#the-rasterific-backend"><generated classes="sectnum">8.3   </generated>The Rasterific backend</a></li><li><a class="reference internal" href="#the-cairo-backend"><generated classes="sectnum">8.4   </generated>The cairo backend</a></li><li><a class="reference internal" href="#the-postscript-backend"><generated classes="sectnum">8.5   </generated>The postscript backend</a></li><li><a class="reference internal" href="#the-canvas-backend"><generated classes="sectnum">8.6   </generated>The Canvas backend</a></li><li><a class="reference internal" href="#the-html5-backend"><generated classes="sectnum">8.7   </generated>The HTML5 backend</a></li><li><a class="reference internal" href="#the-pgf-backend"><generated classes="sectnum">8.8   </generated>The PGF backend</a></li><li><a class="reference internal" href="#the-gtk-backend"><generated classes="sectnum">8.9   </generated>The GTK backend</a></li><li><a class="reference internal" href="#other-backends"><generated classes="sectnum">8.10   </generated>Other backends</a></li><li><a class="reference internal" href="#tools-for-backends"><generated classes="sectnum">8.11   </generated>Tools for backends</a></li></ul></li><li><a class="reference internal" href="#other-tools"><generated classes="sectnum">9   </generated>Other tools</a><ul class="nav"><li><a class="reference internal" href="#diagrams-builder"><generated classes="sectnum">9.1   </generated>diagrams-builder</a></li><li><a class="reference internal" href="#diagrams-haddock"><generated classes="sectnum">9.2   </generated>diagrams-haddock</a></li><li><a class="reference internal" href="#svgfonts"><generated classes="sectnum">9.3   </generated>SVGFonts</a></li></ul></li><li><a class="reference internal" href="#type-reference"><generated classes="sectnum">10   </generated>Type reference</a><ul class="nav"><li><a class="reference internal" href="#understanding-diagrams-types"><generated classes="sectnum">10.1   </generated>Understanding diagrams types</a></li><li><a class="reference internal" href="#type-class-reference"><generated classes="sectnum">10.2   </generated>Type class reference</a><ul class="nav"><li><a class="reference internal" href="#classes-for-transforming-and-combining">Classes for transforming and combining</a></li><li><a class="reference internal" href="#classes-for-attributes-and-styles">Classes for attributes and styles</a></li><li><a class="reference internal" href="#classes-for-names">Classes for names</a></li><li><a class="reference internal" href="#classes-for-trails-and-paths">Classes for trails and paths</a></li><li><a class="reference internal" href="#classes-for-parametric-objects">Classes for parametric objects</a></li><li><a class="reference internal" href="#classes-for-backends">Classes for backends</a></li><li><a class="reference internal" href="#poor-man-s-type-synonyms">Poor man's type synonyms</a></li></ul></li><li><a class="reference internal" href="#type-family-reference"><generated classes="sectnum">10.3   </generated>Type family reference</a><ul class="nav"><li><a class="reference internal" href="#v">V</a></li><li><a class="reference internal" href="#n">N</a></li><li><a class="reference internal" href="#vn">Vn</a></li><li><a class="reference internal" href="#render">Render</a></li><li><a class="reference internal" href="#result">Result</a></li><li><a class="reference internal" href="#options">Options</a></li><li><a class="reference internal" href="#codomain">Codomain</a></li></ul></li></ul></li></ul></div></div><div class="col-md-9"><div class="section" id="preliminaries"><h1><generated classes="sectnum">1   </generated>Preliminaries</h1><div class="section" id="introduction"><h2><generated classes="sectnum">1.1   </generated>Introduction</h2><p><code>diagrams</code> is a flexible, powerful embedded domain-specific language
(EDSL) for creating vector graphics and animations.  The <code>diagrams</code>
framework is:</p><ul><li><p><strong>Declarative</strong>: you specify <em>what</em> a diagram is, not <em>how</em> to
draw it.  <code>diagrams</code> takes care of the how.</p></li><li><p><strong>Compositional</strong>: diagrams can be easily <em>combined</em> in many ways to
produce more complex diagrams.</p></li><li><p><strong>Embedded</strong>: the full power of <a class="reference external" href="http://haskell.org/">Haskell</a>, including every library
on <a class="reference external" href="http://hackage.haskell.org/">Hackage</a>, is available to help construct and manipulate
graphics.</p></li></ul><ul><li><p><strong>Extensible</strong>: extending diagrams with additional or higher-level
functionality is as simple as writing a Haskell module.</p></li><li><p><strong>Flexible</strong>: diagrams is designed from the ground up to be as
generic and flexible as possible, with support for pluggable
rendering backends, arbitrary graphics primitives, multiple numeric
types, and multiple vector spaces (2D, 3D, ...).</p></li></ul></div><div class="section" id="about-this-document"><h2><generated classes="sectnum">1.2   </generated>About this document</h2><p>This document attempts to explain all major aspects of using the
<code>diagrams</code> core and standard libraries, organized by topic to make
it easy to find what you are looking for.  It is not, however, a
complete reference of every single function in the standard library:
for that, see the API documentation listed under <a class="reference internal" href="#other-resources">Other resources</a>.
Most sections contain links to relevant modules you can follow to
read about other functions not covered in the text.</p><p>Module names in the text are typeset like this:
<code>Diagrams.Prelude</code>.  Mathematical equations are typeset using
<a class="reference external" href="http://www.mathjax.org/">MathJax</a>:</p>\[\sum_{k=1}^\infty \frac{1}{k^2} = \frac{\pi^2}{6}\]<p>Right-click on any equation to access MathJax options, like displaying
the LaTeX source, switching between MathML and HTML/CSS for display,
zoom settings, and so on.</p><p>Occasionally content may be missing or incomplete; this is noted by a
light blue box with a "document" icon on the right hand side, like
this:</p><div class="todo bs-callout bs-callout-info"><ul><li><p>Explain zygohistomorphic prepromorphisms</p></li><li><p>Essay on postmodernist critiques of <code>diagrams</code> vis-a-vis Kant</p></li></ul></div><p>If you see a box like this in the place of something you would really
like to know about, please bug the developers (using the <code>#diagrams</code> IRC
channel on Libera.Chat, or the <a class="reference external" href="http://groups.google.com/group/diagrams-discuss?pli=1">diagrams mailing list</a>) so they can
prioritize it!</p><p>Warnings, "gotchas", and other important asides are in a yellow box with
a "warning" icon, like this:</p><div class="warning bs-callout bs-callout-warning"><p>Diagrams is extremely addictive and may be hazardous to your
health!</p></div><p>You would do well to pay special attention to the contents of such boxes.</p></div><div class="section" id="other-resources"><h2><generated classes="sectnum">1.3   </generated>Other resources</h2><p>Here are some other resources that may be helpful to you as you learn
about <code>diagrams</code>:</p><ul><li><p>The API reference documentation for all the <code>diagrams</code> packages
is intended to be high-quality and up-to-date, and is available
<a class="reference external" href="http://projects.haskell.org/diagrams/reference.html">from the diagrams website</a>.  If you find an omission, error, or
something confusing, please <a class="reference external" href="https://github.com/diagrams/diagrams-doc/issues">report it as a bug</a>!</p></li><li><p>The <code>diagrams</code> <a class="reference external" href="http://projects.haskell.org/diagrams">website</a> has a <a class="reference external" href="http://projects.haskell.org/diagrams/gallery.html">gallery of examples</a> and a
<a class="reference external" href="http://projects.haskell.org/diagrams/documentation.html">list of tutorials</a>, as well as links to blog posts and
other documentation.</p></li><li><p>The <a class="reference external" href="https://wiki.haskell.org/Diagrams">diagrams wiki</a> is a good place to find tips and tricks,
examples, answers to frequently asked questions, and more.</p></li><li><p>The <code>#diagrams</code> <a class="reference external" href="https://web.libera.chat">IRC channel on Libera.Chat</a> is a friendly place
where you can get help from other <code>diagrams</code> users and developers.</p></li><li><p>Consider joining the <a class="reference external" href="http://groups.google.com/group/diagrams-discuss?pli=1">diagrams mailing list</a> for discussions
and announcements about <code>diagrams</code>.</p></li><li><p>See the issue trackers in the <a class="reference external" href="https://github.com/diagrams/">diagrams organization on github</a>
for a list of open tickets.  If you find a bug or would like to
request a feature, please file a ticket!</p></li></ul></div><div class="section" id="installation"><h2><generated classes="sectnum">1.4   </generated>Installation</h2><p>Before installing <code>diagrams</code>, you will need the following:</p><ul><li><p>The <a class="reference external" href="http://www.haskell.org/ghc/">Glasgow Haskell Compiler</a> (GHC), version 7.10.x or later.</p></li><li><p>The <a class="reference external" href="http://hackage.haskell.org/trac/hackage/wiki/CabalInstall">cabal-install</a> tool.</p></li></ul><p>If you do not already have these, we recommend following the <a class="reference external" href="https://www.haskell.org/downloads#minimal">minimal
installer instructions</a>.</p><p>Once you have the prerequisites, we recommend installing diagrams in a
sandbox, like so:</p><pre><code>cabal sandbox init
cabal install diagrams</code></pre><p>To make use of the diagrams libraries in the sandbox, you can use
commands such as</p><pre><code>cabal exec -- ghc --make MyDiagram.hs</code></pre><p>which will run <code>ghc --make MyDiagram.hs</code> in the sandbox environment.
Alternatively, on any Unix-ish system you should be able to do
something like</p><pre><code>cabal exec bash</code></pre><p>(feel free to substitute your favorite shell in place of <code>bash</code>).
This will start a new shell in an environment with all the diagrams
packages available to GHC; you can now run <code>ghc</code> normally, without
the need for <code>cabal exec</code>.  To exit the sandbox, just exit the shell.</p><p>The <span class="package"><a href="http://hackage.haskell.org/package/diagrams"><code>diagrams</code></a></span> package is a convenience wrapper that simply pulls
in (by default) four other packages:</p><ul><li><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams-core"><code>diagrams-core</code></a></span> (core data type definitions and utilities),</p></li><li><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams-lib"><code>diagrams-lib</code></a></span> (standard primitives and combinators),</p></li><li><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams-contrib"><code>diagrams-contrib</code></a></span> (user-contributed extensions), and</p></li><li><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams-svg"><code>diagrams-svg</code></a></span> (Haskell-native backend generating SVG files).</p></li></ul><p>There are several other Haskell-native backends including a
<a class="reference external" href="http://hackage.haskell.org/package/diagrams-postscript/">postscript backend</a>, which supports all features except
transparency, and a <a class="reference external" href="http://hackage.haskell.org/package/diagrams-rasterific/">raster backend</a> (based on the excellent
<a class="reference external" href="http://hackage.haskell.org/package/Rasterific/">Rasterific</a> package).  To get them, add the <code>-fps</code> or
<code>-frasterific</code> flags, respectively:</p><pre><code>cabal install -fps diagrams
  OR
cabal install -frasterific diagrams</code></pre><p>There is also a backend based on the <a class="reference external" href="http://www.cairographics.org/">cairo graphics
library</a>; it has support for more
features than the SVG backend and additional output formats (PNG, PS,
PDF), but can be much more difficult to install on some platforms
(notably OS X).  If you want the cairo backend, you can issue the
command</p><pre><code>cabal install gtk2hs-buildtools
cabal install -fcairo diagrams</code></pre><p>Add <code>-fgtk</code> to also get a GTK backend (based on the cairo backend)
which can render diagrams directly to GTK windows.</p><p>You can also mix and match all the above flags to get multiple
backends.  Note, if you don't want the SVG backend at all, you must
add the <code>-f-svg</code> flag to disable it.</p><p>There are other backends as well; see <a class="reference internal" href="#rendering-backends">Rendering backends</a>.</p><p><a class="reference external" href="http://wiki.haskell.org/Diagrams/Install">See the wiki for the most up-to-date information</a> regarding
installation.  If you have trouble installing diagrams, feel free to
send email to the <a class="reference external" href="http://groups.google.com/group/diagrams-discuss?pli=1">diagrams mailing list</a>; we would like to collect
reports of problems and solutions on various platforms.</p></div><div class="section" id="getting-started"><h2><generated classes="sectnum">1.5   </generated>Getting started</h2><p>Create a file called <code>TestDiagram.hs</code> (or whatever you like) with
the following contents:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span>
<span class="ot">></span> <span class="ot">{-# LANGUAGE FlexibleContexts          #-}</span>
<span class="ot">></span> <span class="ot">{-# LANGUAGE TypeFamilies              #-}</span>
<span class="ot">></span> 
<span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.Prelude</span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.Backend.SVG.CmdLine</span>
<span class="ot">></span> <span class="co">-- or:</span>
<span class="ot">></span> <span class="co">-- import Diagrams.Backend.xxx.CmdLine</span>
<span class="ot">></span> <span class="co">-- where xxx is the backend you would like to use.</span>
<span class="ot">></span> 
<span class="ot">> myCircle ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> myCircle <span class="fu">=</span> circle <span class="dv">1</span>
<span class="ot">></span> 
<span class="ot">></span> main <span class="fu">=</span> mainWith myCircle</code></pre></div></div><p>The first line turns off the <a class="reference external" href="http://www.haskell.org/haskellwiki/Monomorphism_restriction">dreaded monomorphism restriction</a>, which is
quite important when using <code>diagrams</code>: otherwise you will probably
run into lots of crazy error messages.</p><p>The other two extensions are not needed for this simple example in
particular, but are often required by diagrams in general, so it
doesn't hurt to include them as a matter of course.</p><p><code>Diagrams.Prelude</code> re-exports almost everything from the
<code>diagrams</code> standard library, along with things from other packages
which are often used in conjunction with <code>diagrams</code>.
<code>Diagrams.Backend.SVG.CmdLine</code> provides a command-line interface
to the SVG rendering backend.  We then declare <code class="sourceCode">myCircle</code> to have the
type <code class="sourceCode"><span class="dt">Diagram</span> <span class="dt">B</span></code>.  The <code class="sourceCode"><span class="dt">B</span></code> is an alias representing the particular
backend. All backends export <code class="sourceCode"><span class="dt">B</span></code> as an alias for themselves, so
you can switch backends just by changing an import, without having to
change type annotations on your diagrams; <code class="sourceCode"><span class="dt">B</span></code> simply refers to
whichever backend is in scope.  Finally, <code class="sourceCode">mainWith</code> takes a diagram
and creates a command-line-driven executable for rendering it. GHC needs some
help to determine the type of the arugment of <code class="sourceCode">mainWith</code> so it is important to
annotate the type of <code class="sourceCode">myCircle</code> (or whatever argument you pass to <code class="sourceCode">mainWith</code>)
as <code class="sourceCode"><span class="dt">Diagram</span> <span class="dt">B</span></code>.</p><p>To compile your program, type</p><pre><code>$ ghc TestDiagram</code></pre><p>(Note that the <code>$</code> indicates a command prompt and should not
actually be typed.)  Then execute <code>TestDiagram</code> with some
appropriate options:</p><pre><code>$ ./TestDiagram -w 100 -h 100 -o TestDiagram.svg</code></pre><p>The above will generate a 100x100 SVG that should look like this:</p><div class="exampleimg"><div style="text-align: center"><img src="images/1d707ce3132f040f.png" width="500" height="200" /></div></div><p>If you are using the rasterific backend you can also request a
<code>.png</code>, <code>.jpg</code>, <code>.tif</code>, or <code>.bmp</code> file (the format is
automatically determined by the extension), or an <code>.eps</code> file if
using the postscript backend.  The cairo backend allows <code>.svg</code>,
<code>.png</code>, <code>.ps</code>, and <code>.pdf</code>.</p><p>Try typing</p><pre><code>$ ./TestDiagram --help</code></pre><p>to see the other options that are supported.</p><p>To get started quickly, you may wish to continue by reading the <a class="reference external" href="../doc/quickstart.html">quick
start tutorial</a>; or you can continue reading the rest of this user
manual.</p><p>Note that <code class="sourceCode"><span class="dt">Diagrams.Backend.SVG.CmdLine</span></code> is provided for convenience,
but it is not the only interface to the backend. For more control over
when and how diagrams are rendered, <em>e.g.</em> as one component of a
larger program, use the <code class="sourceCode">renderDia</code> function, or see the related
section under <a class="reference internal" href="#rendering-backends">Rendering backends</a> for additional backend specific
entry points.</p></div><div class="section" id="contributing"><h2><generated classes="sectnum">1.6   </generated>Contributing</h2><p><code>diagrams</code> is an open-source project, and contributions are
encouraged!  All diagrams-related repositories are in the <a class="reference external" href="http://github.com/diagrams">diagrams
organization</a> on github.  The <a class="reference external" href="http://www.haskell.org/haskellwiki/Diagrams/Contributing">Contributing page</a> on the
diagrams wiki explains how to get the repositories and make
contributions.  To find out about the latest developments, join the
<code>#diagrams</code> IRC channel on Libera.Chat, and check out the <a class="reference external" href="https://trello.com/b/pL6YdKgz/diagrams">diagrams
Trello board</a>.</p></div></div><div class="section" id="essential-concepts"><h1><generated classes="sectnum">2   </generated>Essential concepts</h1><p>Before we jump into the main content of the manual, this chapter
explains a number of general ideas and central concepts that will
recur throughought.  If you're eager to skip right to the good stuff,
feel free to skip this section at first, and come back to it when
necessary; there are many links to this chapter from elsewhere in the
manual.</p><div class="section" id="semigroups-and-monoids"><h2><generated classes="sectnum">2.1   </generated>Semigroups and monoids</h2><p>A <em>semigroup</em> consists of</p><ul><li><p>A set of elements \(S\)</p></li><li><p>An <em>associative binary operation</em> on the set, that is, some
operation</p>\[\diamond \colon S \to S \to S\]<p>for which</p>\[(x \diamond y) \diamond z = x \diamond (y \diamond z).\]</li></ul><p>A <em>monoid</em> is a semigroup with the addition of</p><ul><li><p>An <em>identity element</em> \(i \in S\) which is the identity for
\(\diamond\), that is,</p>\[x \diamond i = i \diamond x = x.\]</li></ul><p>In Haskell, semigroups are expressed using the <code class="sourceCode"><span class="dt">Semigroup</span></code> type class
from the <span class="package"><a href="http://hackage.haskell.org/package/semigroups"><code>semigroups</code></a></span> package:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">Semigroup</span> s <span class="kw">where</span>
<span class="ot">>   (<>) ::</span> s <span class="ot">-></span> s <span class="ot">-></span> s</code></pre></div></div><p>and monoids are expressed using the <code class="sourceCode"><span class="dt">Monoid</span></code> type class, defined in
<code>Data.Monoid</code>:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span>
<span class="ot">>   mempty  ::</span> m
<span class="ot">>   mappend ::</span> m <span class="ot">-></span> m <span class="ot">-></span> m</code></pre></div></div><p>The <code class="sourceCode">mappend</code> function represents the associative binary operation,
and <code class="sourceCode">mempty</code> is the identity element.  (<code class="sourceCode">mappend</code> and <code class="sourceCode">(<span class="fu"><></span>)</code> should
always be the same; there are two different functions for historical
reasons.) A function</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> mconcat ::</span> <span class="dt">Monoid</span> m <span class="ot">=></span> [m] <span class="ot">-></span> m</code></pre></div></div><p>is also provided as a shorthand for the common operation of combining
a whole list of elements with <code class="sourceCode">(<span class="fu"><></span>)</code>/<code class="sourceCode">mappend</code>.</p><p>Semigroups and monoids are used extensively in <code>diagrams</code>: diagrams,
transformations, envelopes, traces, trails, paths, styles, colors, and
queries are all instances of both <code class="sourceCode"><span class="dt">Semigroup</span></code> and <code class="sourceCode"><span class="dt">Monoid</span></code>.</p></div><div class="section" id="faking-optional-named-arguments"><h2><generated classes="sectnum">2.2   </generated>Faking optional named arguments</h2><p>Many diagram-related operations can be customized in a wide variety of
ways.  For example, when creating a regular polygon, one can customize
the number of sides, the radius, the orientation, and so on. However,
to have a single function that takes all of these options as separate
arguments would be a real pain: it's hard to remember what the arguments are
and what order they should go in, and often one wants to use default
values for many of the options and only override a few.  Some
languages (such as Python) support <em>optional, named</em> function
arguments, which are ideal for this sort of situation.  Sadly, Haskell
does not.  However, we can fake it!</p><p>Any function which should take some optional, named arguments instead
takes a single argument which is a record of options.  The record type
is declared to be an instance of the <code class="sourceCode"><span class="dt">Default</span></code> type class:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">Default</span> d <span class="kw">where</span>
<span class="ot">>   def ::</span> d</code></pre></div></div><p>That is, types which have a <code class="sourceCode"><span class="dt">Default</span></code> instance have some default value
called <code class="sourceCode">def</code>.  For option records, <code class="sourceCode">def</code> is declared to be the record
containing all the default arguments.  The idea is that you can pass
<code class="sourceCode">def</code> as an argument to a function which takes a record of options,
and override only the fields you want, like this:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> foo (def <span class="fu">&</span> arg1 <span class="fu">.~</span> someValue <span class="fu">&</span> arg6 <span class="fu">.~</span> blah)</code></pre></div></div><p>This is using machinery from the <span class="package"><a href="http://hackage.haskell.org/package/lens"><code>lens</code></a></span> package; but you don't have to
understand <span class="package"><a href="http://hackage.haskell.org/package/lens"><code>lens</code></a></span>, or know anything beyond the above syntax in
order to use diagrams (for convenience, diagrams re-exports the <code class="sourceCode">(<span class="fu">&</span>)</code>
and <code class="sourceCode">(<span class="fu">.~</span>)</code> operators from <span class="package"><a href="http://hackage.haskell.org/package/lens"><code>lens</code></a></span>).  In fact, in most cases, you
can also use record update syntax instead (note the underscores):</p><pre><code>foo (def { _arg1 = someValue, _arg6 = blah })</code></pre><p>In some cases, however, the lens library is used to provide convenient
"virtual" fields which do not correspond to real record fields; for
example, <code class="sourceCode">headColor</code> can be used to set the color of an arrowhead,
even though the arrow options record actually contains a general style
instead of just a color.</p><p>Finally, note that <code>diagrams</code> also defines <code class="sourceCode">with</code> as a synonym for
<code class="sourceCode">def</code>, which can read a bit more nicely.  So, instead of the above, you
could write</p><pre><code>foo (with &amp; arg1 .~ someValue &amp; arg6 .~ blah)</code></pre><p>Most functions which take an optional arguments record have two
variants: one named <code class="sourceCode">foo</code> which uses all default arguments, and one
named <code class="sourceCode">foo'</code> (with a trailing prime) which takes an options record.</p></div><div class="section" id="postfix-transformation"><h2><generated classes="sectnum">2.3   </generated>Postfix transformation</h2><p>You will often see idiomatic <code>diagrams</code> code that looks like this:</p><pre><code>foobar # attr1
       # attr2
       # attr3
       # transform1</code></pre><p>There is nothing magical about <code class="sourceCode">(<span class="fu">#</span>)</code>, and it is not required in order
to apply attributes or transformations. In fact, it is nothing more
than reverse function application with a high precedence (namely, 8):</p><pre><code>infixl 8 #
x # f = f x</code></pre><p><code class="sourceCode">(<span class="fu">#</span>)</code> is provided simply because it often reads better to first write
down what a diagram <em>is</em>, and then afterwards write down attributes
and modifications.  Additionally, <code class="sourceCode">(<span class="fu">#</span>)</code> has a high precedence so it
can be used to make "local" modifications without requiring lots of
parentheses:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span>     square <span class="dv">2</span> <span class="fu">#</span> fc red <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">3</span>)
<span class="ot">></span>           <span class="fu">|||</span> circle <span class="dv">1</span> <span class="fu">#</span> lc blue <span class="fu">#</span> fc green</code></pre></div></div><p>Note how the modifiers <code class="sourceCode">fc red</code> and <code class="sourceCode">rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">3</span>)</code> apply only to the
square, and <code class="sourceCode">lc blue</code> and <code class="sourceCode">fc green</code> only to the circle. The
horizontal composition operator <code class="sourceCode">(<span class="fu">|||</span>)</code> has a precedence of 6, lower
than that of <code class="sourceCode">(<span class="fu">#</span>)</code>.</p></div><div class="section" id="vectors-and-points"><h2><generated classes="sectnum">2.4   </generated>Vectors and points</h2><p>Although much of this user manual focuses on constructing
two-dimensional diagrams, the definitions in the core library in fact
work for <em>any</em> vector space.  Vector spaces are defined in the
<code>Linear.Vector</code> module from Edward Kmett's <span class="package"><a href="http://hackage.haskell.org/package/linear"><code>linear</code></a></span> package.</p><p>Many objects (diagrams, paths, backends...) inherently live in some
particular vector space.  The vector space in which a given type
"lives" can be computed by the type function <code class="sourceCode"><span class="dt">Vn</span></code>.  So, for example,
the type</p><pre><code>Foo d => Vn d -> d -> d</code></pre><p>is the type of a two-argument function whose first argument is a
vector in whatever vector space corresponds to the type <code class="sourceCode">d</code> (which
must be an instance of <code class="sourceCode"><span class="dt">Foo</span></code>).</p><p>Each vector space has a <em>dimension</em> and a type of <em>scalars</em>.  The type
<code class="sourceCode"><span class="dt">V2</span> <span class="dt">Double</span></code> specifies that the dimension is 2 and the scalar type is
<code class="sourceCode"><span class="dt">Double</span></code> (64-bit floating point values).  A vector represents a
direction and magnitude, whereas a scalar represents only a magnitude.
Useful operations on vectors and scalars include:</p><ul><li><p>Adding and subtracting vectors with <code class="sourceCode">(<span class="fu">^+^</span>)</code> and <code class="sourceCode">(<span class="fu">^-^</span>)</code></p></li><li><p>Multiplying a vector by a scalar with <code class="sourceCode">(<span class="fu">*^</span>)</code></p></li><li><p>Linearly interpolating between two vectors with <code class="sourceCode">lerp</code></p></li><li><p>Finding the <code class="sourceCode">norm</code> (length) of a vector</p></li><li><p>Projecting one vector onto another with <code class="sourceCode">project</code>.</p></li></ul><p>Functions and types which are parametric in the vector space have two
type parameters, <code class="sourceCode">v</code> representing the dimension and <code class="sourceCode">n</code> the scalar
type.  Occasionally <code class="sourceCode">v</code> or <code class="sourceCode">n</code> appears alone in a type signature, with
the same meaning.  <code class="sourceCode">n</code> is most commonly <code class="sourceCode"><span class="dt">Double</span></code>, or some other type
approximating the real numbers, but this is not required. Many
functions require that <code class="sourceCode">n</code> be an instance of <code class="sourceCode"><span class="dt">Num</span></code>, or one of the
narrower classes <code class="sourceCode"><span class="dt">Fractional</span></code>, <code class="sourceCode"><span class="dt">Floating</span></code>, or <code class="sourceCode"><span class="dt">Real</span></code>.</p><p>See <a class="reference external" href="vector.html">this tutorial for a more in-depth introduction to working with vectors
and points</a>.</p><p>One might think we could also identify <em>points</em> in a space with
vectors having one end at the origin.  However, this turns out to be a
poor idea. There is a very important difference between vectors and
points: namely, vectors are translationally invariant whereas points
are not.  A vector represents a direction and magnitude, not a
location. Translating a vector has no effect. Points, on the other
hand, represent a specific location. Translating a point results in a
different point.</p><p>Although it is a bad idea to <em>conflate</em> vectors and points, we can
certainly <em>represent</em> points using vectors. The
<span class="package"><a href="http://hackage.haskell.org/package/linear"><code>linear</code></a></span> package defines a newtype wrapper around
vectors called <code class="sourceCode"><span class="dt">Point</span></code>.  The most important connection between points
and vectors is given by <code class="sourceCode">(<span class="fu">.-.</span>)</code>, defined in
<code>Linear.Affine</code>. If <code class="sourceCode">p</code> and <code class="sourceCode">q</code> are points, <code class="sourceCode">q <span class="fu">.-.</span> p</code> is
the vector giving the direction and distance from <code class="sourceCode">p</code> to <code class="sourceCode">q</code>.
Offsetting a point by a vector (resulting in a new point) is
accomplished with <code class="sourceCode">(<span class="fu">.+^</span>)</code>.</p></div><div class="section" id="envelopes-and-local-vector-spaces"><h2><generated classes="sectnum">2.5   </generated>Envelopes and local vector spaces</h2><p>In order to be able to position diagrams relative to one another, each
diagram must keep track of some bounds information.  Rather than use a
bounding box (which is neither general nor compositional) or even a
more general bounding <em>path</em> (which is rather complicated to deal
with), each diagram has an associated bounding <em>function</em>, called the
<em>envelope</em>.  Given some direction (represented by a vector) as input,
the envelope answers the question: "how far in this direction must one
go before reaching a perpendicular (hyper)plane that completely
encloses the diagram on one side of it?"</p><p>That's a bit of a mouthful, so hopefully the below illustration will
help clarify things if you found the above description confusing.
(For completeness, the code used to generate the illustration is
included, although you certainly aren't expected to understand it yet
if you are just reading this manual for the first time!)</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/087918490ed26c13.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> illustrateEnvelope v d
<span class="ot">></span>   <span class="fu">=</span> mconcat
<span class="ot">></span>     [arrowAt' (with <span class="fu">&</span> arrowHead <span class="fu">.~</span> tri) origin v
<span class="ot">></span>     , origin <span class="fu">~~</span> b
<span class="ot">></span>       <span class="fu">#</span> lc green <span class="fu">#</span> lw veryThick
<span class="ot">></span>     , p1 <span class="fu">~~</span> p2
<span class="ot">></span>       <span class="fu">#</span> lc red
<span class="ot">></span>     ]
<span class="ot">></span>     <span class="kw">where</span>
<span class="ot">></span>       b  <span class="fu">=</span> envelopeP v d
<span class="ot">></span>       v' <span class="fu">=</span> <span class="fl">1.5</span> <span class="fu">*^</span> signorm v
<span class="ot">></span>       p1 <span class="fu">=</span> b <span class="fu">.+^</span> (rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">4</span>) v')
<span class="ot">></span>       p2 <span class="fu">=</span> b <span class="fu">.+^</span> (rotateBy (<span class="fu">-</span><span class="dv">1</span><span class="fu">/</span><span class="dv">4</span>) v')
<span class="ot">></span>
<span class="ot">> d1 ::</span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> d1 <span class="fu">=</span> circle <span class="dv">1</span>
<span class="ot">></span>
<span class="ot">> d2 ::</span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> d2 <span class="fu">=</span> (pentagon <span class="dv">1</span> <span class="fu">===</span> roundedRect <span class="fl">1.5</span> <span class="fl">0.7</span> <span class="fl">0.3</span>)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> (stroke d1 <span class="fu">#</span> showOrigin <span class="fu"><></span> illustrateEnvelope (r2 (<span class="fu">-</span><span class="fl">0.5</span>, <span class="fl">0.3</span>)) d1)
<span class="ot">></span>       <span class="fu">|||</span> (stroke d2 <span class="fu">#</span> showOrigin <span class="fu"><></span> illustrateEnvelope (r2 (<span class="fl">0.5</span>, <span class="fl">0.2</span>)) d2
<span class="ot">></span>                                   <span class="fu"><></span> illustrateEnvelope (r2 (<span class="fl">0.5</span>, <span class="fu">-</span><span class="fl">0.1</span>)) d2
<span class="ot">></span>           )</code></pre></div></div></div><p>The black arrows represent inputs to the envelopes for the
two diagrams; the envelopes' outputs are the distances
represented by the thick green lines.  The red lines illustrate the
enclosing (hyper)planes (which are really to be thought of as
extending infinitely to either side): notice how they are as close as
possible to the diagrams without intersecting them at all.</p><p>Of course, the <em>base point</em> from which the envelope is
measuring matters quite a lot!  If there were no base point, questions
of the form "<em>how far do you have to go...</em>" would be
meaningless—how far <em>from where</em>?  This base point (indicated by the
red dots in the diagram above) is called the <em>local origin</em> of a
diagram.  Every diagram has its own intrinsic <em>local vector space</em>;
operations on diagrams are always with respect to their local origin,
and you can affect the way diagrams are combined with one another by
moving their local origins.  The <code class="sourceCode">showOrigin</code> function is provided as
a quick way of visualizing the local origin of a diagram (also
illustrated above).  The <code class="sourceCode">showEnvelope</code> method can also be used to
show (an approximation of) the envelope of a diagram.  For example:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/64f050ac3ee174ac.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> d1,<span class="ot"> d2 ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> d1 <span class="fu">=</span> circle <span class="dv">1</span>
<span class="ot">></span> d2 <span class="fu">=</span> (pentagon <span class="dv">1</span> <span class="fu">===</span> roundedRect <span class="fl">1.5</span> <span class="fl">0.7</span> <span class="fl">0.3</span>)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="dv">1</span>
<span class="ot">></span>   [ (d1 <span class="fu">|||</span> d2)          <span class="fu">#</span> showEnvelope' (with <span class="fu">&</span> ePoints <span class="fu">.~</span> <span class="dv">360</span>) <span class="fu">#</span> showOrigin
<span class="ot">></span>   , (d1 <span class="fu">|||</span> d2) <span class="fu">#</span> center <span class="fu">#</span> showEnvelope' (with <span class="fu">&</span> ePoints <span class="fu">.~</span> <span class="dv">360</span>) <span class="fu">#</span> showOrigin
<span class="ot">></span>   ]</code></pre></div></div></div><p>As you can see, the location of the origin can make a big difference!</p></div><div class="section" id="measurement-units"><h2><generated classes="sectnum">2.6   </generated>Measurement units</h2><p>Certain attributes (such as line width, dashing size, arrowhead size,
and font size) can be specified with respect to several different
reference frames.  For example, the lines used to draw a certain
square can be specified as an absolute two pixels wide, or as a
certain percentage of the size of the final diagram, or in units
relative to the size of the square.  More specifically, values of type
<code class="sourceCode"><span class="dt">Measure</span> n</code> represent <code class="sourceCode">n</code> values, interpreted in one of four
"reference frames": <code class="sourceCode">local</code>, <code class="sourceCode">global</code>, <code class="sourceCode">normalized</code>, or <code class="sourceCode">output</code>,
described below in turn.</p><p>In addition to the four reference frames described here, it is
possible to combine them into more complex expressions using a small
DSL for specifying measurements; see <a class="reference internal" href="#measurement-expressions">Measurement expressions</a>.</p><div class="section" id="local-units"><h3>Local units</h3><p><code class="sourceCode">local</code> units are the most straightforward to explain.  Values in
<code class="sourceCode">local</code> units are interpreted in the context of the <em>local</em> vector
space, just as most other length measurements (<em>e.g.</em> arguments to
functions like <code class="sourceCode">circle</code> and <code class="sourceCode">square</code>).  For example, <code class="sourceCode">square <span class="dv">1</span> <span class="fu">#</span> lwL
<span class="fl">0.2</span></code> specifies a square which is drawn with lines one fifth as wide as
its sides are long—and will <em>always</em> be, even if it is scaled: the
line width scales right along with the square. (The <code class="sourceCode"><span class="dt">L</span></code> in <code class="sourceCode">lwL</code>
stands for "Local".)</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/5a5196bce1dfe2ee.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> localSq <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> lwL <span class="fl">0.2</span>
<span class="ot">></span> example <span class="fu">=</span>
<span class="ot">></span>   hsep <span class="fl">0.5</span>
<span class="ot">></span>   [localSq, localSq <span class="fu">#</span> scale <span class="dv">2</span>, localSq <span class="fu">#</span> scaleX <span class="dv">2</span>]</code></pre></div></div></div><p>It's important to note that—as illustrated by the third figure in
the above picture—line width always scales uniformly, even when a
non-uniform scaling is applied.  That is, the line used to draw the
rectangle in the example above is a uniform thickness all the way
around. Previous versions of diagrams had a <code class="sourceCode">freeze</code> operation which
could be used to apply non-uniform scaling to lines; to achieve such
an effect, you can first turn a stroked line into a closed path, as
described in <a class="reference internal" href="#offsets-of-segments-trails-and-paths">Offsets of segments, trails, and paths</a>.</p><p>A important consequence of <code class="sourceCode">local</code> units having the <em>current</em> vector
space as their reference is that attribute-setting functions such as
<code class="sourceCode">lwL</code> do <em>not</em> commute with transformations.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/36bc2935235a23bd.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span>
<span class="ot">></span>   hsep <span class="fl">0.5</span>
<span class="ot">></span>   [ square <span class="dv">1</span> <span class="fu">#</span> lwL <span class="fl">0.2</span> <span class="fu">#</span> scale <span class="dv">2</span>
<span class="ot">></span>   , square <span class="dv">1</span> <span class="fu">#</span> scale <span class="dv">2</span> <span class="fu">#</span> lwL <span class="fl">0.2</span>
<span class="ot">></span>   ]
<span class="ot">></span>   <span class="fu">#</span> frame <span class="fl">0.5</span></code></pre></div></div></div></div><div class="section" id="global-units"><h3>Global units</h3><p>Whereas <code class="sourceCode">local</code> values are interpreted in the current, "local" vector
space, <code class="sourceCode">global</code> values are interpreted in the final, "global" vector
space of the diagram that is rendered.  In the following example,
<code class="sourceCode">theSq</code> is specified as having a <code class="sourceCode">global</code> line width of <code class="sourceCode"><span class="fl">0.05</span></code>; five
differently-scaled copies of the square are laid out, so that the entire
scaled diagram has a width of around <code class="sourceCode"><span class="dv">6</span></code> units.  The lines, having a
line width of <code class="sourceCode">global <span class="fl">0.05</span></code>, are thus about 0.8% of the width of the
entire diagram.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/15620e85d9b23be8.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> theSq <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> lwG <span class="fl">0.05</span>
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span>
<span class="ot">></span>   hsep <span class="fl">0.2</span>
<span class="ot">></span>     (map (\s <span class="ot">-></span> theSq <span class="fu">#</span> scale s) [<span class="fl">0.5</span>, <span class="fl">0.8</span>, <span class="dv">1</span>, <span class="fl">1.5</span>, <span class="dv">2</span>])</code></pre></div></div></div><p>Versions of <code>diagrams</code> prior to <code class="sourceCode"><span class="fl">1.2</span></code> actually had a semantics for
<code class="sourceCode">lw</code> equivalent to <code class="sourceCode">lwG</code>.  One advantage, as can be seen from the
above example, is that different shapes having the same <code class="sourceCode">global</code> line
width, even when differently scaled, will all be drawn with the same
apparent line width. However, <code class="sourceCode">normalized</code> and <code class="sourceCode">output</code> have that
property as well, and are probably more useful; the problem with
<code class="sourceCode">global</code> units is that in order to decide on values, one has to know
the final size of the diagram, which is not typically something one
knows in advance.  In particular, note that applying something like
<code class="sourceCode">scale <span class="dv">20</span></code> to the <code class="sourceCode">example</code> above—a seemingly innocuous
change—would result in extremely thin lines (or even invisible,
depending on the backend), as shown below.  Making this look
reasonable again would require changing the argument to <code class="sourceCode">lwG</code>.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/8cf0a5c8c26b3bf2.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> theSq <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> lwG <span class="fl">0.05</span>
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span>
<span class="ot">></span>   hsep <span class="fl">0.2</span>
<span class="ot">></span>     (map (\s <span class="ot">-></span> theSq <span class="fu">#</span> scale s) [<span class="fl">0.5</span>, <span class="fl">0.8</span>, <span class="dv">1</span>, <span class="fl">1.5</span>, <span class="dv">2</span>])
<span class="ot">></span>   <span class="fu">#</span> scale <span class="dv">20</span></code></pre></div></div></div><p>In short, <code class="sourceCode">global</code> units tend to go against <code>diagrams</code> emphasis on
local, scale-invariant thinking.  They were left in for backwards
compatibility, and because they can occasionaly be useful in special
situations where you do already have some absolute, global coordinate
system in mind: for example, if you know you want to construct a
100x100 diagram using lines that are 1 unit wide.</p></div><div class="section" id="normalized-units"><h3>Normalized units</h3><p><code class="sourceCode">normalized</code> units, like <code class="sourceCode">global</code> units, are measured with respect to
the final size of a diagram. However, for the purposes of interpreting
<code class="sourceCode">normalized</code> units, the diagram is considered to be one "normalized
unit" in both height and width.  For example, a <code class="sourceCode">normalized</code> value of
<code class="sourceCode"><span class="fl">0.1</span></code> means "10% of the height/width of the final diagram".  Thus,
scaling the diagram has no effect on the relative size of the lines
(just as with <code class="sourceCode">local</code>), but lines look consistent even across shapes
that have been scaled differently (as with <code class="sourceCode">global</code>).</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/bba70c65ef4f479b.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> theSq <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> lwN <span class="fl">0.01</span>
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span>
<span class="ot">></span>   hsep <span class="fl">0.2</span>
<span class="ot">></span>     (map (\s <span class="ot">-></span> theSq <span class="fu">#</span> scale s) [<span class="fl">0.5</span>, <span class="fl">0.8</span>, <span class="dv">1</span>, <span class="fl">1.5</span>, <span class="dv">2</span>])
<span class="ot">></span>   <span class="fu">#</span> scale <span class="dv">20</span></code></pre></div></div></div><p>Note that the <code class="sourceCode">scale <span class="dv">20</span></code> threatened in the <code class="sourceCode">global</code> example has been
applied here, but makes no difference: changing the <code class="sourceCode"><span class="dv">20</span></code> to any other
nonzero value has no effect on the appearance of the rendered diagram.</p></div><div class="section" id="output-units"><h3>Output units</h3><p>Values measured in <code class="sourceCode">output</code> units are interpreted with respect to the
<em>requested output size</em> of a diagram.  Sometimes you really do know,
for example, that you want your lines to be exactly 1/2 inch wide when
printed, or exactly 4 pixels wide on the screen. In this case, scaling
a diagram will preserve its appearance, but requesting a different
output size might not.</p><p>One situation in which <code class="sourceCode">output</code> units can be particularly useful is
when preparing a document (paper, blog post, <em>etc.</em>) with multiple
embedded diagrams of various physical sizes.  Using the same <code class="sourceCode">output</code>
value for the line width (or arrowhead length, arrow gap, font size,
<em>etc.</em>) of every diagram ensures that the diagrams will all look
consistent.  (The default for line width is to use <code class="sourceCode">normalized</code> units,
but this means that by default, lines will only look consistent across
multiple diagrams if all the diagrams have the same physical size,
<em>e.g.</em> they are all \(300 \times 200\) pixels.)</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/32fe0db6035da2ba.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> theSq <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> lwO <span class="dv">4</span>
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span>
<span class="ot">></span>   hsep <span class="fl">0.2</span>
<span class="ot">></span>     (map (\s <span class="ot">-></span> theSq <span class="fu">#</span> scale s) [<span class="fl">0.5</span>, <span class="fl">0.8</span>, <span class="dv">1</span>, <span class="fl">1.5</span>, <span class="dv">2</span>])
<span class="ot">></span>   <span class="fu">#</span> scale <span class="dv">20</span></code></pre></div></div></div><p>In the above example, all the squares are drawn with lines exactly 4
pixels wide (at least in theory; antialiasing makes the details a bit
more subtle).  Note that the actual units used (in this case, pixels)
depends on the backend being used.</p></div></div><div class="section" id="types-and-type-classes"><h2><generated classes="sectnum">2.7   </generated>Types and type classes</h2><p><em>Flexibility</em>, <em>power</em>, <em>simplicity</em>: in general, you can have any two
of these but not all three.  Diagrams chooses <em>flexibility</em> and
<em>power</em>, at the expense of <em>simplicity</em>. (In comparison, the excellent
<span class="package"><a href="http://hackage.haskell.org/package/gloss"><code>gloss</code></a></span> library instead chooses <em>flexibility</em> and <em>simplicity</em>.)
In particular, the types in the diagrams library can be quite
intimidating at first.  For example, <code class="sourceCode">hcat</code> is a function which takes
a list of diagrams and lays them out in a horizontal row.  So one
might expect its type to be something like <code class="sourceCode">[<span class="dt">Diagram</span>] <span class="ot">-></span> <span class="dt">Diagram</span></code>.  In
actuality, its type is</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> hcat ::</span> (<span class="dt">Juxtaposable</span> a, <span class="dt">HasOrigin</span> a, <span class="dt">Monoid'</span> a, <span class="dt">V</span> a <span class="fu">~</span> <span class="dt">V2</span>, <span class="dt">N</span> a <span class="fu">~</span> n, <span class="dt">TypeableFloat</span> n)
<span class="ot">></span>    <span class="ot">=></span> [a] <span class="ot">-></span> a</code></pre></div></div><p>which may indeed be intimidating at first glance, and at any rate
takes a bit of time and practice to understand!  The essential idea is
to realize that <code class="sourceCode">hcat</code> is actually quite a bit more general than
previously described: it can lay out not just diagrams, but any
two-dimensional things (<code>V a ~ V2</code> and the constraints on <code>N a</code>)
which can be positioned "next to" one another (<code class="sourceCode"><span class="dt">Juxtaposable</span></code>), can be
translated (<code class="sourceCode"><span class="dt">HasOrigin</span></code>), and are an instance of <code class="sourceCode"><span class="dt">Monoid</span></code> (<code class="sourceCode"><span class="dt">Monoid'</span></code>
is actually a synonym for the combination of <code class="sourceCode"><span class="dt">Monoid</span></code> and
<code class="sourceCode"><span class="dt">Semigroup</span></code>).  This certainly includes diagrams, but it also includes
other things like paths, envelopes, animations, and even tuples,
lists, sets, or maps containing any of these things.</p><p>At first, you may want to just try working through some examples
intuitively, without worrying too much about the types involved.
However, at some point you will of course want to dig deeper into
understanding the types, either to understand an error message (though
for help interpreting some common error messages, see <a class="reference internal" href="#deciphering-error-messages">Deciphering
error messages</a>) or to wield diagrams like a true type ninja.  When
that point comes, you should refer to <a class="reference internal" href="#understanding-diagrams-types">Understanding diagrams types</a>
and the <a class="reference internal" href="#type-class-reference">Type class reference</a>.</p></div></div><div class="section" id="creating-2d-diagrams"><h1><generated classes="sectnum">3   </generated>Creating 2D diagrams</h1><p>The main purpose of <code>diagrams</code> is to construct two-dimensional
vector graphics (although it can be used for more general purposes as
well).  This section explains the building blocks provided by
<span class="package"><a href="http://hackage.haskell.org/package/diagrams-core"><code>diagrams-core</code></a></span> and <span class="package"><a href="http://hackage.haskell.org/package/diagrams-lib"><code>diagrams-lib</code></a></span> for constructing
two-dimensional diagrams.</p><p>All 2D-specific things can be found in <code>Diagrams.TwoD</code>, which
re-exports most of the contents of <code>Diagrams.TwoD.*</code> modules.  This
section also covers many things which are not specific to two
dimensions; later sections will make clear which are which.</p><div class="section" id="basic-2d-types"><h2><generated classes="sectnum">3.1   </generated>Basic 2D types</h2><p><code>Diagrams.TwoD.Types</code> defines types for working with
two-dimensional Euclidean space.</p><div class="section" id="euclidean-2-space"><h3>Euclidean 2-space</h3><p>There are three main type synonyms defined for referring to
two-dimensional space:</p><ul><li><p><code class="sourceCode"><span class="dt">V2</span> n</code> is the type of a two-dimensional Euclidean vector space
(<code class="sourceCode">n</code> is usually <code class="sourceCode"><span class="dt">Double</span></code>). Standard <code>diagrams</code> backends render
images with the positive \(x\)-axis extending to the right, and
the positive \(y\)-axis extending <em>upwards</em>.  This is
consistent with standard mathematical practice, but upside-down with
respect to many common graphics systems.  This is intentional: the
goal is to provide an elegant interface which is abstracted as much
as possible from implementation details.</p><p><code class="sourceCode">unitX</code> and <code class="sourceCode">unitY</code> are unit vectors in the positive \(x\)- and
\(y\)-directions, respectively.  Their negated counterparts are
<code class="sourceCode">unit_X</code> and <code class="sourceCode">unit_Y</code>.</p><p>Vectors of type <code class="sourceCode"><span class="dt">V2</span> <span class="dt">Double</span></code> can be created by passing a pair of type
<code class="sourceCode">(<span class="dt">Double</span>, <span class="dt">Double</span>)</code> to the function <code class="sourceCode">r2</code>; vectors can likewise be
converted back into pairs using <code class="sourceCode">unr2</code>.</p><p>Vectors can also be constructed and pattern-matched using the
utilities defined in <code>Diagrams.Coordinates</code>, which provides a
uniform interface for constructing points and vectors of any
dimension.  Vectors can be created using the syntax <code class="sourceCode">(x <span class="fu">^&</span> y)</code> and
pattern-matched by calling <code class="sourceCode">coords</code> and then matching on the pattern
<code class="sourceCode">(x <span class="fu">:&</span> y)</code>.</p><p>For more in-depth information on working with <code class="sourceCode"><span class="dt">V2</span> <span class="dt">Double</span></code>, <a class="reference external" href="vector.html">see this
tutorial</a>.</p></li><li><p><code class="sourceCode"><span class="dt">P2</span> n</code> is the type of points in two-dimensional space. It is a synonym
for <code class="sourceCode"><span class="dt">Point</span> <span class="dt">V2</span> n</code>.  The distinction between points and vectors is
important; see <a class="reference internal" href="#vectors-and-points">Vectors and points</a>.</p><p>Points can be created from pairs of coordinates using <code class="sourceCode">p2</code> and
converted back using <code class="sourceCode">unp2</code>. They can also be constructed and
destructed using the same syntax as for vectors, as defined in
<code>Diagrams.Coordinates</code>.</p><p>For more in-depth information on working with <code class="sourceCode"><span class="dt">P2</span></code>, <a class="reference external" href="vector.html">see this
tutorial</a>.</p></li><li><p><code class="sourceCode"><span class="dt">T2</span> n</code> is the type of two-dimensional affine transformations.  It is a
synonym for <code class="sourceCode"><span class="dt">Transformation</span> <span class="dt">V2</span> n</code>.</p></li></ul></div><div class="section" id="angles"><h3>Angles</h3><p>The type <code class="sourceCode"><span class="dt">Angle</span> n</code> represents two-dimensional angles.  Angles can be
expressed in radians, degrees, or fractions of a circle. Isomorphisms
<code class="sourceCode">turn</code>, <code class="sourceCode">rad</code>, and <code class="sourceCode">deg</code> are provided (represented using the <code class="sourceCode"><span class="dt">Iso</span></code>
type from the <span class="package"><a href="http://hackage.haskell.org/package/lens"><code>lens</code></a></span> package), which convert between abstract
<code class="sourceCode"><span class="dt">Angle</span> n</code> values and <code class="sourceCode">n</code> values with various units.  To construct
an <code class="sourceCode"><span class="dt">Angle</span></code>, use the <code class="sourceCode">(<span class="fu">@@</span>)</code> operator, as in <code class="sourceCode">(<span class="dv">3</span> <span class="fu">@@</span> deg)</code> or <code class="sourceCode">(<span class="dv">3</span> <span class="fu">@@</span>
rad)</code>. To project an <code class="sourceCode"><span class="dt">Angle</span></code> back to a scalar, use the <code class="sourceCode">(<span class="fu">^.</span>)</code>
operator, as in <code class="sourceCode">someAngle <span class="fu">^.</span> rad</code>.</p><ul><li><p><code class="sourceCode">turn</code> represents fractions of a circle.  A value of <code class="sourceCode"><span class="dv">1</span> <span class="fu">@@</span> turn</code> represents
a full turn, <code class="sourceCode"><span class="dv">1</span><span class="fu">/</span><span class="dv">4</span> <span class="fu">@@</span> turn</code> constructs a right angle, and so on.  The
measure of an Angle <code>a</code> in turns (represented with <code class="sourceCode"><span class="dt">Double</span></code>)
can be obtained using <code class="sourceCode">a <span class="fu">^.</span> turn</code>.</p></li><li><p><code class="sourceCode">rad</code> represents angles measured in radians.  A value of <code class="sourceCode">tau</code> (that
is, \(\tau = 2 \pi\)) represents a full turn. (If you haven't heard of
\(\tau\), see <a class="reference external" href="http://tauday.com">The Tau Manifesto</a>.)</p></li><li><p><code class="sourceCode">deg</code> represents angles measured in degrees.  A value of <code class="sourceCode"><span class="dv">360</span></code>
represents a full turn.</p></li></ul><p><code class="sourceCode"><span class="ot">fullTurn ::</span> <span class="dt">Angle</span></code> represents one full turn, equivalent to <code class="sourceCode"><span class="dv">1</span> <span class="fu">@@</span>
turn</code>, <code class="sourceCode">tau <span class="fu">@@</span> rad</code>, or <code class="sourceCode"><span class="dv">360</span> <span class="fu">@@</span> deg</code>.  <code class="sourceCode"><span class="ot">halfTurn ::</span> <span class="dt">Angle</span></code> is also
provided for convenience.</p><p>There is no <code class="sourceCode"><span class="dt">Num</span></code> instance for <code class="sourceCode"><span class="dt">Angle</span></code>; this is intentional, since,
for example, it is not clear what units would be used for a bare
number used as an <code class="sourceCode"><span class="dt">Angle</span></code>, and multiplying two <code class="sourceCode"><span class="dt">Angle</span></code>s is
meaningless and should not be allowed.  <code class="sourceCode"><span class="dt">Angle</span></code> does have an
<code class="sourceCode"><span class="dt">Additive</span></code> instance, which means you can add and subtract angles using
<code class="sourceCode">(<span class="fu">^+^</span>)</code> and <code class="sourceCode">(<span class="fu">^-^</span>)</code>, and negate an angle with <code class="sourceCode">negated</code>.  The <code class="sourceCode">(<span class="fu">*^</span>)</code>,
<code class="sourceCode">(<span class="fu">^*</span>)</code>, and <code class="sourceCode">(<span class="fu">^/</span>)</code> operators can also be used to multiply or divide an
<code class="sourceCode"><span class="dt">Angle</span></code> by a constant factor: for example, if <code class="sourceCode"><span class="ot">theta ::</span> <span class="dt">Angle</span></code> then
<code class="sourceCode">theta <span class="fu">^/</span> <span class="dv">3</span></code> is the angle representing one-third of <code class="sourceCode">theta</code>.</p><p>In two dimensions, the direction of a vector can be represented by an
angle measured counterclockwise from the positive \(x\)-axis (shown in
green below).  For some vector <code class="sourceCode">u</code>, this angle can be found by <code class="sourceCode">u <span class="fu">^.</span> _theta</code>.</p><div class="exampleimg"><div style="text-align: center"><img src="images/19e71e61354704b8.png" width="500" height="200" /></div></div></div><div class="section" id="directions"><h3>Directions</h3><p>Whereas a vector is described by a direction and a magnitude, some
functions only depend on the direction.  <code class="sourceCode"><span class="dt">Direction</span> v n</code> is the type
of directions of vectors of type <code class="sourceCode">v n</code>; for example, <code class="sourceCode"><span class="dt">Direction</span> <span class="dt">V2</span>
<span class="dt">Double</span></code> represents directions in 2D Euclidean space.  The <code class="sourceCode">direction</code>
function converts a vector to its <code class="sourceCode"><span class="dt">Direction</span></code>; <code class="sourceCode">fromDirection</code> creates a
unit (length 1) vector in the given direction.</p><p><code class="sourceCode">xDir</code> and <code class="sourceCode">yDir</code> are provided as the directions of the positive x-
and y-axes, respectively.</p><p>The relationship between <code class="sourceCode"><span class="dt">Angle</span></code>s and <code class="sourceCode"><span class="dt">Direction</span></code>s is similar to
that between vectors and points, though unfortunately there cannot be
a law-abiding <code class="sourceCode"><span class="dt">Affine</span></code> instance.</p><ul><li><p>The <code class="sourceCode"><span class="dt">Angle</span></code> between two fixed <code class="sourceCode"><span class="dt">Direction</span></code>s can be found with
<code class="sourceCode">angleBetweenDirs</code>, which is commutative and returns a positive
angle between \(0\) and \(1/2\) turn, or <code class="sourceCode">signedAngleBetweenDirs</code>, which
satisfies <code class="sourceCode">signedAngleBetweenDirs d1 d2 <span class="fu">==</span> negated (signedAngleBetweenDirs
d2 d1)</code> and returns a positive angle when the second direction is
clockwise from the first.</p></li><li><p>An <code class="sourceCode"><span class="dt">Angle</span></code> can be "added" to a <code class="sourceCode"><span class="dt">Direction</span></code> by simply using <code class="sourceCode">rotate</code>
to rotate the <code class="sourceCode"><span class="dt">Direction</span></code> by the <code class="sourceCode"><span class="dt">Angle</span></code>.</p></li></ul></div></div><div class="section" id="primitive-shapes"><h2><generated classes="sectnum">3.2   </generated>Primitive shapes</h2><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams-lib"><code>diagrams-lib</code></a></span> provides many standard two-dimensional shapes for
use in constructing diagrams.</p><div class="section" id="circles-and-ellipses"><h3>Circles and ellipses</h3><p>Circles can be created with the <code class="sourceCode">unitCircle</code> and <code class="sourceCode">circle</code>
functions, defined in <code>Diagrams.TwoD.Ellipse</code>.</p><p>For example,</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/a1bd905b424bc88d.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> circle <span class="fl">0.5</span> <span class="fu"><></span> unitCircle</code></pre></div></div></div><p><code class="sourceCode">unitCircle</code> creates a circle of radius 1 centered at the
origin; <code class="sourceCode">circle</code> takes the desired radius as an argument.</p><p>Every ellipse is the image of the unit circle under some affine
transformation, so ellipses can be created by appropriately <a class="reference internal" href="#d-transformations">scaling
and rotating</a> circles.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/3564e4ddbb783bcc.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> unitCircle <span class="fu">#</span> scaleX <span class="fl">0.5</span> <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">6</span>)</code></pre></div></div></div><p>For convenience the standard library also provides <code class="sourceCode">ellipse</code>, for
creating an ellipse with a given eccentricity, and <code class="sourceCode">ellipseXY</code>, for
creating an axis-aligned ellipse with specified radii in the x and y
directions.</p></div><div class="section" id="arcs"><h3>Arcs</h3><p><code>Diagrams.TwoD.Arc</code> provides a function <code class="sourceCode">arc</code>, which constructs a
radius-one circular arc starting at a first direction and extending
through a given <a class="reference internal" href="#angles">angle</a> , as well as <code class="sourceCode">wedge</code> which constructs a wedge
shape with a given radius, <code class="sourceCode">annularWedge</code> which expects an outer and
inner radius, and various other functions for conveniently
constructing arcs.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/a2a4ed8937b316a0.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> hsep <span class="fl">0.5</span> [arc d a, wedge <span class="dv">1</span> d a, annularWedge <span class="dv">1</span> <span class="fl">0.6</span> d a]
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">>     d ::</span> <span class="dt">Direction</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span>     d <span class="fu">=</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">4</span>) xDir
<span class="ot">>     a ::</span> <span class="dt">Angle</span> <span class="dt">Double</span>
<span class="ot">></span>     a <span class="fu">=</span> (<span class="dv">4</span> <span class="fu">*</span> tau <span class="fu">/</span> <span class="dv">7</span> <span class="fu">-</span> tau <span class="fu">/</span> <span class="dv">4</span>) <span class="fu">@@</span> rad</code></pre></div></div></div><p>(Note that the parentheses in the definition of <code>a</code> are not strictly
necessary, as <code class="sourceCode">(<span class="fu">@@</span>)</code> has lower precedence (namely, 5) than <code class="sourceCode">(<span class="fu">-</span>)</code>
(which has precedence 6).)</p></div><div class="section" id="pre-defined-shapes"><h3>Pre-defined shapes</h3><p><code>Diagrams.TwoD.Shapes</code> provides a number of pre-defined
polygons and other path-based shapes.  For example:</p><ul><li><p><code class="sourceCode">triangle</code> constructs an equilateral triangle with sides of a
given length.</p></li><li><p><code class="sourceCode">square</code> constructs a square with a given side length; <code class="sourceCode">unitSquare</code>
constructs a square with sides of length <code class="sourceCode"><span class="dv">1</span></code>.</p></li><li><p><code class="sourceCode">pentagon</code>, <code class="sourceCode">hexagon</code>, ..., <code class="sourceCode">dodecagon</code> construct other regular
polygons with sides of a given length. (For constructing polygons
with a given <em>radius</em>, see <a class="reference internal" href="#general-polygons">General polygons</a>.)</p></li><li><p>In general, <code class="sourceCode">regPoly</code> constructs a regular polygon with any number
of sides.</p></li><li><p><code class="sourceCode">rect</code> constructs a rectangle of a given width and height.</p></li><li><p><code class="sourceCode">roundedRect</code> constructs a rectangle with circular rounded corners.</p></li><li><p><code class="sourceCode">roundedRect'</code> works like <code class="sourceCode">roundedRect</code> but allowing a different radius to be set for each corner, using <code class="sourceCode"><span class="dt">RoundedRectOpts</span></code>.</p></li></ul><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/e105c2a2ae302d14.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> square <span class="dv">1</span>
<span class="ot">></span>       <span class="fu">|||</span> rect <span class="fl">0.3</span> <span class="fl">0.5</span>
<span class="ot">></span>       <span class="fu">|||</span> triangle <span class="dv">1</span>
<span class="ot">></span>       <span class="fu">|||</span> roundedRect  <span class="fl">0.5</span> <span class="fl">0.4</span> <span class="fl">0.1</span>
<span class="ot">></span>       <span class="fu">|||</span> roundedRect  <span class="fl">0.5</span> <span class="fl">0.4</span> (<span class="fu">-</span><span class="fl">0.1</span>)
<span class="ot">></span>       <span class="fu">|||</span> roundedRect' <span class="fl">0.7</span> <span class="fl">0.4</span> (with <span class="fu">&</span> radiusTL <span class="fu">.~</span> <span class="fl">0.2</span>
<span class="ot">></span>                                      <span class="fu">&</span> radiusTR <span class="fu">.~</span> <span class="fu">-</span><span class="fl">0.2</span>
<span class="ot">></span>                                      <span class="fu">&</span> radiusBR <span class="fu">.~</span> <span class="fl">0.1</span>)</code></pre></div></div></div><p>Completing the hodgepodge in <code>Diagrams.TwoD.Shapes</code> for now, the
functions <code class="sourceCode">hrule</code> and <code class="sourceCode">vrule</code> create horizontal and vertical lines of
a given length, respectively.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/eab2303c9f5bea78.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> c <span class="fu">|||</span> hrule <span class="dv">1</span> <span class="fu">|||</span> c
<span class="ot">></span>   <span class="kw">where</span> c <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu"><></span> vrule <span class="dv">2</span></code></pre></div></div></div></div><div class="section" id="general-polygons"><h3>General polygons</h3><p>The <code class="sourceCode">polygon</code> function from <code>Diagrams.TwoD.Polygons</code> can be used
to construct a wide variety of polygons.  Its argument is a record of
optional parameters that control the generated polygon:</p><ul><li><p><code class="sourceCode">polyType</code> specifies one of several methods for determining the
vertices of the polygon:</p><ul><li><p><code class="sourceCode"><span class="dt">PolyRegular</span></code> indicates a regular polygon with a certain number
of sides and a given <em>radius</em>.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/1aeac85fe456633d.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> p <span class="dv">6</span> <span class="fu">|||</span> p <span class="dv">24</span>
<span class="ot">></span>   <span class="kw">where</span> p n <span class="fu">=</span> polygon (with
<span class="ot">></span>                 <span class="fu">&</span> polyType <span class="fu">.~</span> <span class="dt">PolyRegular</span> n <span class="dv">1</span> )</code></pre></div></div></div></li><li><p><code class="sourceCode"><span class="dt">PolySides</span></code> specifies the vertices using a list of external angles between
edges, and a list of edge lengths. More precisely, the first edge length is
between the first and second vertex, while the first external angle is
between the first and second edge. In the example below, the first vertex is
on the bottom right.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/f9815fd4c8d975da.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> polygon ( with
<span class="ot">></span>   <span class="fu">&</span> polyType <span class="fu">.~</span> <span class="dt">PolySides</span>
<span class="ot">></span>       [ <span class="dv">20</span> <span class="fu">@@</span> deg, <span class="dv">90</span> <span class="fu">@@</span> deg, <span class="dv">40</span> <span class="fu">@@</span> deg, <span class="dv">100</span> <span class="fu">@@</span> deg ]
<span class="ot">></span>       [ <span class="dv">1</span>        , <span class="dv">5</span>        , <span class="dv">2</span>        , <span class="dv">4</span>          ]
<span class="ot">></span>   )</code></pre></div></div></div></li><li><p><code class="sourceCode"><span class="dt">PolyPolar</span></code> specifies the vertices using polar coordinates: a
list of central angles between vertices, and a list of vertex
radii.</p></li></ul></li><li><p><code class="sourceCode">polyOrient</code> specifies the <code class="sourceCode"><span class="dt">PolyOrientation</span></code>: the polygon can be
oriented with an edge parallel to the \(x\)-axis (<code class="sourceCode"><span class="dt">OrientH</span></code>),
with an edge parallel to the \(y\)-axis (<code class="sourceCode"><span class="dt">OrientV</span></code>), or with an
edge perpendicular to any given vector.  You may also specify that
no special orientation should be applied, in which case the first
vertex of the polygon will be located along the positive
\(x\)-axis.</p></li><li><p>Additionally, a center other than the origin can be specified using
<code class="sourceCode">polyCenter</code>.</p></li></ul><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/9b467ddac9e79773.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> poly1 <span class="fu">=</span> polygon ( with <span class="fu">&</span> polyType  <span class="fu">.~</span> <span class="dt">PolyRegular</span> <span class="dv">13</span> <span class="dv">5</span>
<span class="ot">></span>                        <span class="fu">&</span> polyOrient <span class="fu">.~</span> <span class="dt">OrientV</span> )
<span class="ot">></span> poly2 <span class="fu">=</span> polygon ( with <span class="fu">&</span> polyType  <span class="fu">.~</span> <span class="dt">PolyPolar</span> (repeat (<span class="dv">1</span><span class="fu">/</span><span class="dv">40</span> <span class="fu">@@</span> turn))
<span class="ot">></span>                                                 (take <span class="dv">40</span> <span class="fu">$</span> cycle [<span class="dv">2</span>,<span class="dv">7</span>,<span class="dv">4</span>,<span class="dv">6</span>]) )
<span class="ot">></span> example <span class="fu">=</span> (poly1 <span class="fu">|||</span> strutX <span class="dv">1</span> <span class="fu">|||</span> poly2)</code></pre></div></div></div><p>Notice the idiom of using <code class="sourceCode">with</code> to construct a record of default
options and selectively overriding particular options by name. <code class="sourceCode">with</code>
is a synonym for <code class="sourceCode">def</code> from the type class <code class="sourceCode"><span class="dt">Default</span></code>, which specifies
a default value for types which are instances.  You can read more
about this idiom in the section <a class="reference internal" href="#faking-optional-named-arguments">Faking optional named arguments</a>.</p></div><div class="section" id="star-polygons"><h3>Star polygons</h3><p>A "star polygon" is a polygon where the edges do not connect
consecutive vertices; for example:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/2dae098b1a6035d0.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> star (<span class="dt">StarSkip</span> <span class="dv">3</span>) (regPoly <span class="dv">13</span> <span class="dv">1</span>) <span class="fu">#</span> strokeP</code></pre></div></div></div><p><code>Diagrams.TwoD.Polygons</code> provides the <code class="sourceCode">star</code> function for
creating star polygons of this sort, although it is actually quite a
bit more general.</p><p>As its second argument, <code class="sourceCode">star</code> expects a list of points.  One way to
generate a list of points is with polygon-generating functions such as
<code class="sourceCode">polygon</code> or <code class="sourceCode">regPoly</code>, or indeed, any function which can output any
<code class="sourceCode"><span class="dt">TrailLike</span></code> type (see the section about <a class="reference internal" href="#traillike">TrailLike</a>), since a list of
points is an instance of the <code class="sourceCode"><span class="dt">TrailLike</span></code> class.  But of course, you are
free to construct the list of points using whatever method you like.</p><p>As its first argument, <code class="sourceCode">star</code> takes a value of type <code class="sourceCode"><span class="dt">StarOpts</span></code>, for
which there are two possibilities:</p><ul><li><p><code class="sourceCode"><span class="dt">StarSkip</span></code> specifies that every \(n\) th vertex should be
connected by an edge.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/2b87d3e27f8bd15e.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> strokeP (star (<span class="dt">StarSkip</span> <span class="dv">2</span>) (regPoly <span class="dv">8</span> <span class="dv">1</span>))
<span class="ot">></span>       <span class="fu">|||</span> strutX <span class="dv">1</span>
<span class="ot">></span>       <span class="fu">|||</span> strokeP (star (<span class="dt">StarSkip</span> <span class="dv">3</span>) (regPoly <span class="dv">8</span> <span class="dv">1</span>))</code></pre></div></div></div><p>As you can see, <code class="sourceCode">star</code> may result in a path with multiple components,
if the argument to <code class="sourceCode"><span class="dt">StarSkip</span></code> and the number of vertices have a
nontrivial common divisor.</p></li><li><p><code class="sourceCode"><span class="dt">StarFun</span></code> takes as an argument a function of type <code class="sourceCode">(<span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Int</span>)</code>,
which specifies which vertices should be connected to which other
vertices.  Given the function \(f\), vertex \(i\) is
connected to vertex \(j\) if and only if \(f(i) \equiv j \pmod
n\), where \(n\) is the number of vertices.  This can be
used as a compact, precise way of specifying how to connect a set of
points (or as a fun way to visualize functions in \(Z_n\)!).</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/58be9c88a8b678f2.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">></span> <span class="ot">{-# LANGUAGE FlexibleContexts      #-}</span>
<span class="ot">></span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.TwoD.Text</span> (<span class="dt">Text</span>)
<span class="ot">></span>
<span class="ot">></span> funs          <span class="fu">=</span> map (flip (<span class="fu">^</span>)) [<span class="dv">2</span><span class="fu">..</span><span class="dv">6</span>]
<span class="ot">> visualize ::</span> (<span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Int</span>) <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> visualize f   <span class="fu">=</span> strokeP' (with <span class="fu">&</span> vertexNames <span class="fu">.~</span> [[<span class="dv">0</span> <span class="fu">..</span> <span class="dv">6</span><span class="ot"> ::</span> <span class="dt">Int</span>]] )
<span class="ot">></span>                     (regPoly <span class="dv">7</span> <span class="dv">1</span>)
<span class="ot">></span>                   <span class="fu">#</span> lw none
<span class="ot">></span>                   <span class="fu">#</span> showLabels
<span class="ot">></span>                   <span class="fu">#</span> fontSize (local <span class="fl">0.6</span>)
<span class="ot">></span>              <span class="fu"><></span> star (<span class="dt">StarFun</span> f) (regPoly <span class="dv">7</span> <span class="dv">1</span>)
<span class="ot">></span>                   <span class="fu">#</span> strokeP <span class="fu">#</span> lw thick <span class="fu">#</span> lc red
<span class="ot">></span> example       <span class="fu">=</span> center <span class="fu">.</span> hsep <span class="fl">0.5</span> <span class="fu">$</span> map visualize funs</code></pre></div></div></div></li></ul><p>You may notice that all the above examples need to call <code class="sourceCode">strokeP</code> (or
<code class="sourceCode">strokeP'</code>), which converts a path into a diagram.  Many functions
similar to <code class="sourceCode">star</code> are polymorphic in their return type over any
<code class="sourceCode"><span class="dt">TrailLike</span></code>, but <code class="sourceCode">star</code> is not. As we have seen, <code class="sourceCode">star</code> may need to
construct a path with multiple components, which is not supported by
the <code class="sourceCode"><span class="dt">TrailLike</span></code> class.</p></div></div><div class="section" id="composing-diagrams"><h2><generated classes="sectnum">3.3   </generated>Composing diagrams</h2><p>The <code>diagrams</code> framework is fundamentally <em>compositional</em>: complex
diagrams are created by combining simpler diagrams in various ways.
Many of the combination methods discussed in this section are defined
in <code>Diagrams.Combinators</code>.</p><div class="section" id="superimposing-diagrams-with-atop"><h3>Superimposing diagrams with <code>atop</code></h3><p>The most fundamental way to combine two diagrams is to place one on
top of the other with <code class="sourceCode">atop</code>.  The diagram <code class="sourceCode">d1 <span class="ot">`atop`</span> d2</code> is formed
by placing <code class="sourceCode">d1</code>'s local origin on top of <code class="sourceCode">d2</code>'s local origin; that is,
by identifying their local vector spaces.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/3bf48386bdab58d6.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> circle <span class="dv">1</span> <span class="ot">`atop`</span> square (sqrt <span class="dv">2</span>)</code></pre></div></div></div><p>As noted before, diagrams form a <a class="reference internal" href="#semigroups-and-monoids">monoid</a> with composition given by
superposition.  <code class="sourceCode">atop</code> is simply a synonym for <code class="sourceCode">mappend</code> (or <code class="sourceCode">(<span class="fu"><></span>)</code>),
specialized to two dimensions.</p><p>This also means that a list of diagrams can be stacked with <code class="sourceCode">mconcat</code>;
that is, <code class="sourceCode">mconcat [d1, d2, d3, <span class="fu">...</span>]</code> is the diagram with <code class="sourceCode">d1</code> on top
of <code class="sourceCode">d2</code> on top of <code class="sourceCode">d3</code> on top of...</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/d2e70dfb82af44b6.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> mconcat [ circle <span class="fl">0.1</span> <span class="fu">#</span> fc green
<span class="ot">></span>                   , triangle <span class="dv">1</span> <span class="fu">#</span> scale <span class="fl">0.4</span> <span class="fu">#</span> fc yellow
<span class="ot">></span>                   , square <span class="dv">1</span>   <span class="fu">#</span> fc blue
<span class="ot">></span>                   , circle <span class="dv">1</span>   <span class="fu">#</span> fc red
<span class="ot">></span>                   ]</code></pre></div></div></div></div><div class="section" id="juxtaposing-diagrams"><h3>Juxtaposing diagrams</h3><p>Fundamentally, <code class="sourceCode">atop</code> is actually the <em>only</em> way to compose diagrams;
however, there are a number of other combining methods (all ultimately
implemented in terms of <code class="sourceCode">atop</code>) provided for convenience.</p><p>Two diagrams can be placed <em>next to</em> each other using <code class="sourceCode">beside</code>.  The
first argument to <code class="sourceCode">beside</code> is a vector specifying a direction.  The
second and third arguments are diagrams, which are placed next to each
other so that the vector points from the first diagram to the second.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/b41fefe262e36c19.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> beside (r2 (<span class="dv">20</span>,<span class="dv">30</span>))
<span class="ot">></span>                  (circle <span class="dv">1</span> <span class="fu">#</span> fc orange)
<span class="ot">></span>                  (circle <span class="fl">1.5</span> <span class="fu">#</span> fc purple)
<span class="ot">></span>           <span class="fu">#</span> showOrigin</code></pre></div></div></div><p>As can be seen from the above example, the <em>length</em> of the vector
makes no difference, only its <em>direction</em> is taken into account. (To
place diagrams at a certain fixed distance from each other, see
<code class="sourceCode">cat'</code>.)  As can also be seen, the local origin of the new, combined
diagram is the same as the local origin of the first diagram.  This
makes <code class="sourceCode">beside v</code> associative, so diagrams under <code class="sourceCode">beside v</code> form a
semigroup.  In fact, they form a monoid, since <code class="sourceCode">mempty</code> is a left and
right identity for <code class="sourceCode">beside v</code>, as can be seen in the example below:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/ec929dd4167aaefe.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> hsep <span class="dv">1</span> <span class="fu">.</span> map showOrigin
<span class="ot">></span>         <span class="fu">$</span> [ d, mempty <span class="fu">|||</span> d, d <span class="fu">|||</span> mempty ]
<span class="ot">></span>   <span class="kw">where</span> d <span class="fu">=</span> square <span class="dv">1</span></code></pre></div></div></div><p>In older versions of <code>diagrams</code>, the local origin of the combined
diagram was at the point of tangency between the two diagrams.  To
recover the old behavior, simply perform an alignment on the first
diagram in the same direction as the argument to <code class="sourceCode">beside</code> before
combining (see <a class="reference internal" href="#alignment">Alignment</a>):</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/d73123ed3348c2d4.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> beside (r2 (<span class="dv">20</span>,<span class="dv">30</span>))
<span class="ot">></span>                  (circle <span class="dv">1</span>   <span class="fu">#</span> fc orange <span class="fu">#</span> align (r2 (<span class="dv">20</span>,<span class="dv">30</span>)))
<span class="ot">></span>                  (circle <span class="fl">1.5</span> <span class="fu">#</span> fc purple)
<span class="ot">></span>           <span class="fu">#</span> showOrigin</code></pre></div></div></div><p>If you want to place two diagrams next to each other using the local
origin of the <em>second</em> diagram, you can use something like <code class="sourceCode">beside' <span class="fu">=</span>
flip <span class="fu">.</span> beside <span class="fu">.</span> negated</code>, that is, use a vector in the opposite
direction and give the diagrams in the other order.</p><p>Since placing diagrams next to one another horizontally and vertically
is quite common, special combinators are provided for convenience.
<code class="sourceCode">(<span class="fu">|||</span>)</code> and <code class="sourceCode">(<span class="fu">===</span>)</code> are specializations of <code class="sourceCode">beside</code> which juxtapose
diagrams in the \(x\)- and \(y\)-directions, respectively.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/df78cbcb11d8a95c.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> d1 <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> fc red
<span class="ot">></span> d2 <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> fc blue
<span class="ot">></span> example <span class="fu">=</span> (d1 <span class="fu">|||</span> d2) <span class="fu">|||</span> strutX <span class="dv">3</span> <span class="fu">|||</span> ( d1
<span class="ot">></span>                                          <span class="fu">===</span>
<span class="ot">></span>                                          d2  )</code></pre></div></div></div></div><div class="section" id="juxtaposing-without-composing"><h3>Juxtaposing without composing</h3><p>Sometimes, one may wish to <em>position</em> a diagram next to another
diagram without actually composing them.  This can be accomplished
with the <code class="sourceCode">juxtapose</code> function.  In particular, <code class="sourceCode">juxtapose v d1 d2</code>
returns a modified version of <code class="sourceCode">d2</code> which has been translated to be
next to <code class="sourceCode">d1</code> in the direction of <code class="sourceCode">v</code>.  (In fact, <code class="sourceCode">beside</code> itself is
implemented as a call to <code class="sourceCode">juxtapose</code> followed by a call to <code class="sourceCode">(<span class="fu"><></span>)</code>.)</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/5c2fbe40f327f4c9.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> d1 <span class="fu">=</span> juxtapose unitX             (square <span class="dv">1</span>) (circle <span class="dv">1</span> <span class="fu">#</span> fc red)
<span class="ot">></span> d2 <span class="fu">=</span> juxtapose (unitX <span class="fu">^+^</span> unitY) (square <span class="dv">1</span>) (circle <span class="dv">1</span> <span class="fu">#</span> fc green)
<span class="ot">></span> d3 <span class="fu">=</span> juxtapose unitY             (square <span class="dv">1</span>) (circle <span class="dv">1</span> <span class="fu">#</span> fc blue)
<span class="ot">></span> example <span class="fu">=</span> circles <span class="fu">|||</span> strutX <span class="dv">1</span> <span class="fu">|||</span> (circles <span class="fu"><></span> square <span class="dv">1</span>)
<span class="ot">></span>   <span class="kw">where</span> circles <span class="fu">=</span> mconcat [d1, d2, d3]</code></pre></div></div></div><p>See <a class="reference internal" href="#envelopes-and-local-vector-spaces">envelopes and local vector spaces</a> for more information on what
"next to" means, and <a class="reference internal" href="#envelopes">Envelopes</a> for information on
functions available for manipulating envelopes.  To learn about how
envelopes are implemented, see the <a class="reference external" href="core.html">core library reference</a>.</p></div><div class="section" id="concatenating-diagrams"><h3>Concatenating diagrams</h3><p>We have already seen one way to combine a list of diagrams, using
<code class="sourceCode">mconcat</code> to stack them.  Several other methods for combining lists of
diagrams are also provided in <code>Diagrams.Combinators</code>.</p><p>The simplest method of combining multiple diagrams is <code class="sourceCode">position</code>,
which takes a list of diagrams paired with points, and places the
local origin of each diagram at the indicated point.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/c3fc8b8ab21ef6d6.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> position (zip (map mkPoint [<span class="fu">-</span><span class="dv">3</span>, <span class="fu">-</span><span class="fl">2.8</span> <span class="fu">..</span> <span class="dv">3</span>]) (repeat spot))
<span class="ot">></span>   <span class="kw">where</span> spot       <span class="fu">=</span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc black
<span class="ot">></span>         mkPoint x <span class="fu">=</span> p2 (x,x<span class="fu">*</span>x)</code></pre></div></div></div><p><code class="sourceCode">cat</code> is an iterated version of <code class="sourceCode">beside</code>, which takes a direction
vector and a list of diagrams, laying out the diagrams beside one
another in a row.  The local origins of the subdiagrams will be placed
along a straight line in the direction of the given vector, and the
local origin of the first diagram in the list will be used as the
local origin of the final result.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/ba8c01e44277c679.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> cat (r2 (<span class="dv">2</span>, <span class="fu">-</span><span class="dv">1</span>)) (map p [<span class="dv">3</span><span class="fu">..</span><span class="dv">8</span>]) <span class="fu">#</span> showOrigin
<span class="ot">></span>   <span class="kw">where</span> p n <span class="fu">=</span> regPoly n <span class="dv">1</span></code></pre></div></div></div><p>Semantically, <code class="sourceCode">cat v <span class="fu">===</span> foldr (beside v) mempty</code>, although the actual
implementation of <code class="sourceCode">cat</code> uses a more efficient balanced fold.</p><p>For more control over the way in which the diagrams are laid out, use
<code class="sourceCode">cat'</code>, a variant of <code class="sourceCode">cat</code> which also takes a <code class="sourceCode"><span class="dt">CatOpts</span></code> record.  See
the documentation for <code class="sourceCode">cat'</code> and <code class="sourceCode"><span class="dt">CatOpts</span></code> to learn about the various
possibilities.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/ddeb74997f10acd9.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> cat' (r2 (<span class="dv">2</span>,<span class="fu">-</span><span class="dv">1</span>)) (with <span class="fu">&</span> catMethod <span class="fu">.~</span> <span class="dt">Distrib</span> <span class="fu">&</span> sep <span class="fu">.~</span> <span class="dv">2</span> ) (map p [<span class="dv">3</span><span class="fu">..</span><span class="dv">8</span>])
<span class="ot">></span>   <span class="kw">where</span> p n <span class="fu">=</span> regPoly n <span class="dv">1</span> <span class="fu">#</span> scale (<span class="dv">1</span> <span class="fu">+</span> fromIntegral n<span class="fu">/</span><span class="dv">4</span>)
<span class="ot">></span>                           <span class="fu">#</span> showOrigin</code></pre></div></div></div><p>For convenience, <code>Diagrams.TwoD.Combinators</code> also provides
<code class="sourceCode">hcat</code>, <code class="sourceCode">hcat'</code>, <code class="sourceCode">vcat</code>, and <code class="sourceCode">vcat'</code>, variants of <code class="sourceCode">cat</code> and <code class="sourceCode">cat'</code>
which concatenate diagrams horizontally and vertically.  In addition,
since using <code class="sourceCode">hcat'</code> or <code class="sourceCode">vcat'</code> with some separation tends to be
common, <code class="sourceCode">hsep</code> and <code class="sourceCode">vsep</code> are provided as short synonyms; that is,
<code class="sourceCode">hsep s <span class="fu">=</span> hcat' (with <span class="fu">&</span> sep <span class="fu">.~</span> s)</code>, and similarly for <code class="sourceCode">vsep</code>.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/2405fe5a64d6cab1.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> hsep <span class="fl">0.2</span> (map square [<span class="fl">0.3</span>, <span class="fl">0.7</span> <span class="fu">..</span> <span class="dv">2</span>])</code></pre></div></div></div><p>Finally, <code class="sourceCode">appends</code> is like an iterated variant of <code class="sourceCode">beside</code>, with the
important difference that multiple diagrams are placed next to a
single central diagram without reference to one another; simply
iterating <code class="sourceCode">beside</code> causes each of the previously appended diagrams to
be taken into account when deciding where to place the next one.  Of
course, <code class="sourceCode">appends</code> is implemented in terms of <code class="sourceCode">juxtapose</code> (see
<a class="reference internal" href="#juxtaposing-without-composing">Juxtaposing without composing</a>).</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/3bd1855a11830277.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> c        <span class="fu">=</span> circle <span class="dv">1</span>
<span class="ot">></span> dirs     <span class="fu">=</span> iterate (rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">7</span>)) unitX
<span class="ot">></span> cdirs    <span class="fu">=</span> zip dirs (replicate <span class="dv">7</span> c)
<span class="ot">></span> example1 <span class="fu">=</span> appends c cdirs
<span class="ot">></span> example2 <span class="fu">=</span> foldl (\a (v,b) <span class="ot">-></span> beside v a b) c cdirs
<span class="ot">></span> example  <span class="fu">=</span> example1 <span class="fu">|||</span> strutX <span class="dv">3</span> <span class="fu">|||</span> example2</code></pre></div></div></div></div></div><div class="section" id="modifying-diagrams"><h2><generated classes="sectnum">3.4   </generated>Modifying diagrams</h2><div class="section" id="attributes-and-styles"><h3>Attributes and styles</h3><p>Every diagram has a <em>style</em> which is an arbitrary collection of
<em>attributes</em>.  This section will describe some of the default
attributes which are provided by the <code>diagrams</code> library and
recognized by most backends.  However, you can easily create your own
attributes as well; for details, see the <a class="reference external" href="core.html">core library reference</a>.</p><p>In many examples, you will see attributes applied to diagrams using
the <code class="sourceCode">(<span class="fu">#</span>)</code> operator.  Keep in mind that there is nothing special about
this operator as far as attributes are concerned. It is merely
backwards function application, which is used for attributes since it
often reads better to have the main diagram come first, followed by
modifications to its attributes.  See <a class="reference internal" href="#postfix-transformation">Postfix transformation</a>.</p><p>In general, inner attributes (that is, attributes applied earlier)
override outer ones.  Note, however, that this is not a requirement.
Each attribute may define its own specific method for combining
multiple values.  Again, see the <a class="reference external" href="core.html">core library reference</a> for more
details.</p><p>Most of the attributes discussed in this section are defined in
<code>Diagrams.TwoD.Attributes</code>.</p></div><div class="section" id="texture"><h3>Texture</h3><p>Two-dimensional diagrams can be filled and stroked with a <code class="sourceCode"><span class="dt">Texture</span></code>. A
<code class="sourceCode"><span class="dt">Texture</span></code> can be either a solid color, a linear gradient or a radial
gradient. Not all backends support gradients, in particular gradients are
supported by the SVG, Cairo, and Rasterific backends (see <a class="reference internal" href="#rendering-backends">Rendering backends</a>).
Future releases should also support patterns as textures. The data type
for a texture is</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">data</span> <span class="dt">Texture</span> <span class="fu">=</span> <span class="dt">SC</span> <span class="dt">SomeColor</span> <span class="fu">|</span> <span class="dt">LG</span> <span class="dt">LGradient</span> <span class="fu">|</span> <span class="dt">RG</span> <span class="dt">RGradient</span></code></pre></div></div><p>and <code class="sourceCode"><span class="dt">Prism</span></code> s <code class="sourceCode">_SC</code>, <code class="sourceCode">_LG</code>, <code class="sourceCode">_RG</code> are provided for access.</p><div class="section" id="color-and-opacity"><h4>Color and Opacity</h4><p>The color used to stroke the paths can be set with the <code class="sourceCode">lc</code> (line color)
function and the color used to fill them with the <code class="sourceCode">fc</code> (fill color) function.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/3a9640d2cb5025d4.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> circle <span class="fl">0.2</span> <span class="fu">#</span> lc purple <span class="fu">#</span> fc yellow</code></pre></div></div></div><p>By default, diagrams use a black line color and a completely
transparent fill color.</p><p>Colors themselves are handled by the <span class="package"><a href="http://hackage.haskell.org/package/colour"><code>colour</code></a></span> package, which
provides a large set of predefined color names as well as many more
sophisticated color operations; see its documentation for more
information.  The <span class="package"><a href="http://hackage.haskell.org/package/colour"><code>colour</code></a></span> package uses a different type for
colors with an alpha channel (<em>i.e.</em> transparency). To make use of
transparent colors you can use <code class="sourceCode">lcA</code> and <code class="sourceCode">fcA</code>. The <span class="package"><a href="http://hackage.haskell.org/package/palette"><code>palette</code></a></span> package
provides additional sets of colors and algorithms for creating harmonious
color combinations.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/eba1605fae9759cd.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Data.Colour</span> (withOpacity)
<span class="ot">></span> <span class="kw">import </span><span class="dt">Data.Colour.Palette.BrewerSet</span>
<span class="ot">></span>
<span class="ot">></span> blues   <span class="fu">=</span> map (blue <span class="ot">`withOpacity`</span>) [<span class="fl">0.1</span>, <span class="fl">0.2</span> <span class="fu">..</span> <span class="fl">1.0</span>]
<span class="ot">></span> alphaEx <span class="fu">=</span> hcat' (with <span class="fu">&</span> catMethod <span class="fu">.~</span> <span class="dt">Distrib</span> <span class="fu">&</span> sep <span class="fu">.~</span> <span class="dv">1</span> )
<span class="ot">></span>                 (zipWith fcA blues (repeat (circle <span class="dv">1</span>)))
<span class="ot">></span>
<span class="ot">></span> colors  <span class="fu">=</span> brewerSet <span class="dt">Pastel1</span> <span class="dv">9</span>
<span class="ot">></span> paletteEx <span class="fu">=</span> hsep <span class="fl">0.3</span> (zipWith fc colors (repeat (rect <span class="fl">0.5</span> <span class="dv">1</span> <span class="fu">#</span> lw none)))
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> vsep <span class="dv">1</span> ([alphaEx, paletteEx] <span class="fu">#</span> map centerX)</code></pre></div></div></div><p>Another source of predefined color names is the
<code>Diagrams.Color.XKCD</code> module, containing over 900 common names for
colors as determined by the <a class="reference external" href="https://xkcd.com/color/rgb/">XKCD color name survey</a>.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/ca4562a67163750d.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.Color.XKCD</span>
<span class="ot">></span>
<span class="ot">></span> colors <span class="fu">=</span> [booger, poisonGreen, cinnamon, petrol, vibrantPurple]
<span class="ot">></span> example <span class="fu">=</span> hcat (zipWith fcA colors (repeat (circle <span class="dv">1</span> <span class="fu">#</span> lw none)))</code></pre></div></div></div><p>Transparency can also be tweaked with the <code class="sourceCode"><span class="dt">Opacity</span></code> attribute, which
sets the opacity/transparency of a diagram as a whole. Applying
<code class="sourceCode">opacity p</code> to a diagram, where <code class="sourceCode">p</code> is a value between <code class="sourceCode"><span class="dv">0</span></code> and <code class="sourceCode"><span class="dv">1</span></code>,
results in a diagram <code class="sourceCode">p</code> times as opaque.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/bccb85d4ad61073f.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> s c     <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> fc c
<span class="ot">></span> reds    <span class="fu">=</span> (s darkred <span class="fu">|||</span> s red) <span class="fu">===</span> (s pink <span class="fu">|||</span> s indianred)
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="dv">1</span> <span class="fu">.</span> take <span class="dv">4</span> <span class="fu">.</span> iterate (opacity <span class="fl">0.7</span>) <span class="fu">$</span> reds</code></pre></div></div></div><p>Some backends support setting fill and stroke opacities separately,
with <code class="sourceCode">fillOpacity</code> and <code class="sourceCode">strokeOpacity</code>.</p><p>Grouped opacity can be applied using the <code class="sourceCode">opacityGroup</code> annotation,
which is currently supported by the <span class="package"><a href="http://hackage.haskell.org/package/diagrams-svg"><code>diagrams-svg</code></a></span>,
<span class="package"><a href="http://hackage.haskell.org/package/diagrams-pgf"><code>diagrams-pgf</code></a></span>, and (as of version 1.3.1) the
<span class="package"><a href="http://hackage.haskell.org/package/diagrams-rasterific"><code>diagrams-rasterific</code></a></span> backends.  In the example to the left
below, the section where the two transparent circles overlap is
darker, just as if <em>e.g.</em> two circles made out of colored cellophane
were overlapped.  If this documentation was compiled with a backend
that supports opacity grouping (<em>e.g.</em> Rasterific or SVG), then the
example on the right shows two transparent circles without a darker
section where they overlap—the transparency has been applied to the
group of diagrams as a whole, as if it were a single piece of
cellophane cut in the shape of overlapping circles.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/1e4dc4eb4637abc7.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> cir <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> lw none <span class="fu">#</span> fc red
<span class="ot">></span> overlap <span class="fu">=</span> (cir <span class="fu"><></span> cir <span class="fu">#</span> translateX <span class="dv">1</span>)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="dv">1</span> [ overlap <span class="fu">#</span> opacity <span class="fl">0.3</span>, overlap <span class="fu">#</span> opacityGroup <span class="fl">0.3</span> ]
<span class="ot">></span>           <span class="fu">#</span> centerX
<span class="ot">></span>        <span class="fu"><></span> rect <span class="dv">9</span> <span class="fl">0.1</span> <span class="fu">#</span> fc lightblue <span class="fu">#</span> lw none</code></pre></div></div></div><p>To "set the background color" of a diagram, use the <code class="sourceCode">bg</code>
function—which does not actually set any attributes, but simply
superimposes the diagram on top of a bounding rectangle of the given
color. The <code class="sourceCode">bgFrame</code> function is similar but the background is expanded
to frame the diagram by a specified amount.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/9406966372679be4.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> t <span class="fu">=</span> regPoly <span class="dv">3</span> <span class="dv">1</span>
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="fl">0.2</span> [t, t <span class="fu">#</span> bg orange, t <span class="fu">#</span> bgFrame <span class="fl">0.1</span> orange]</code></pre></div></div></div></div><div class="section" id="linear-gradients"><h4>Linear Gradients</h4><p>A linear gradient must have a list of color stops, a starting point, an ending point,
a transformation and a spread method. Color stops are pairs of (color, fraction) where
the fraction is usually between 0 and 1 that are mapped onto the start and end
points. The starting point and endping point are
specified in local coordinates. Typically the transformation starts as the identity
transform <code class="sourceCode">mempty</code> and records any transformations that are applied to the object
using the gradient. The spread method defines how space beyond the starting and
ending points should be handled: <code class="sourceCode"><span class="dt">GradPad</span></code> will fill the space with the final stop
color, <code class="sourceCode"><span class="dt">GradRepeat</span></code> will restart the gradient, and <code class="sourceCode"><span class="dt">GradReflect</span></code> will restart the
gradient but with the stops reversed. This is the data type for a linear gradient:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">data</span> <span class="dt">LGradient</span> n <span class="fu">=</span> <span class="dt">LGradient</span>
<span class="ot">></span>   {<span class="ot"> _lGradStops        ::</span> [<span class="dt">GradientStop</span> n]
<span class="ot">></span>   ,<span class="ot"> _lGradStart        ::</span> <span class="dt">P2</span> n,
<span class="ot">></span>   ,<span class="ot"> _lGradEnd          ::</span> <span class="dt">P2</span> n,
<span class="ot">></span>   ,<span class="ot"> _lGradTrans        ::</span> <span class="dt">T2</span> n,
<span class="ot">></span>   ,<span class="ot"> _lGradSpreadMethod ::</span> <span class="dt">SpreadMethod</span>
<span class="ot">></span>   }</code></pre></div></div><p>Lenses are provided to access the record fields. In addition the
functions <code class="sourceCode">mkStops</code> taking a list of triples (color, fraction,
opacity) and <code class="sourceCode">mkLinearGradient</code> which takes a list of stops, a start
and end point, and a spread method and creates a <code class="sourceCode"><span class="dt">Texture</span></code> are
provided for convenience.  In this example we demonstrate how to make
linear gradients with the <code class="sourceCode">mkLinearGradient</code> functions and how to
adjust it using the lenses and prisms.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/f76c35f29287db75.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> stops <span class="fu">=</span> mkStops [(gray, <span class="dv">0</span>, <span class="dv">1</span>), (white, <span class="fl">0.5</span>, <span class="dv">1</span>), (purple, <span class="dv">1</span>, <span class="dv">1</span>)]
<span class="ot">></span> gradient <span class="fu">=</span> mkLinearGradient stops ((<span class="fu">-</span><span class="fl">0.5</span>) <span class="fu">^&</span> <span class="dv">0</span>) (<span class="fl">0.5</span> <span class="fu">^&</span> <span class="dv">0</span>) <span class="dt">GradPad</span>
<span class="ot">></span> sq1 <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> fillTexture  gradient
<span class="ot">></span> sq2 <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> fillTexture (gradient <span class="fu">&</span> _LG <span class="fu">.</span> lGradSpreadMethod <span class="fu">.~</span> <span class="dt">GradRepeat</span>
<span class="ot">></span>                                        <span class="fu">&</span> _LG <span class="fu">.</span> lGradStart        <span class="fu">.~</span> (<span class="fu">-</span><span class="fl">0.1</span>) <span class="fu">^&</span> <span class="dv">0</span>
<span class="ot">></span>                                        <span class="fu">&</span> _LG <span class="fu">.</span> lGradEnd          <span class="fu">.~</span> <span class="fl">0.1</span> <span class="fu">^&</span> <span class="dv">0</span>
<span class="ot">></span>                              )
<span class="ot">></span> sq3 <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> fillTexture (gradient <span class="fu">&</span> _LG <span class="fu">.</span> lGradSpreadMethod <span class="fu">.~</span> <span class="dt">GradReflect</span>
<span class="ot">></span>                                        <span class="fu">&</span> _LG <span class="fu">.</span> lGradStart        <span class="fu">.~</span> (<span class="fu">-</span><span class="fl">0.1</span>) <span class="fu">^&</span> <span class="dv">0</span>
<span class="ot">></span>                                        <span class="fu">&</span> _LG <span class="fu">.</span> lGradEnd          <span class="fu">.~</span> <span class="fl">0.1</span> <span class="fu">^&</span> <span class="dv">0</span>
<span class="ot">></span>                              )
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="fl">0.25</span> [sq1, sq2, sq3]</code></pre></div></div></div><p>Here we apply the gradient to the stroke only and give it starting and
ending points towards the corners.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/5b228d67e7c8f73b.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> stops <span class="fu">=</span> mkStops [(teal, <span class="dv">0</span>, <span class="dv">1</span>), (orange, <span class="dv">1</span>, <span class="dv">1</span>)]
<span class="ot">></span> gradient <span class="fu">=</span> mkLinearGradient stops ((<span class="fu">-</span><span class="dv">1</span>) <span class="fu">^&</span> (<span class="fu">-</span><span class="dv">1</span>)) (<span class="dv">1</span> <span class="fu">^&</span> <span class="dv">1</span>) <span class="dt">GradPad</span>
<span class="ot">></span> example <span class="fu">=</span> rect <span class="dv">3</span> <span class="dv">1</span> <span class="fu">#</span> lineTexture  gradient <span class="fu">#</span> lwO <span class="dv">15</span> <span class="fu">#</span> fc black <span class="fu">#</span> opacity <span class="fl">0.75</span></code></pre></div></div></div></div><div class="section" id="radial-gradients"><h4>Radial Gradients</h4><p>Radial gradients are similar, only they begin at the perimeter of an inner cirlce and
end at the perimeter of an outer circle.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">data</span> <span class="dt">RGradient</span> n <span class="fu">=</span> <span class="dt">RGradient</span>
<span class="ot">></span>     {<span class="ot"> _rGradStops        ::</span> [<span class="dt">GradientStop</span> n]
<span class="ot">></span>     ,<span class="ot"> _rGradCenter0      ::</span> <span class="dt">P2</span> n
<span class="ot">></span>     ,<span class="ot"> _rGradRadius0      ::</span> n
<span class="ot">></span>     ,<span class="ot"> _rGradCenter1      ::</span> <span class="dt">P2</span> n
<span class="ot">></span>     ,<span class="ot"> _rGradRadius1      ::</span> n
<span class="ot">></span>     ,<span class="ot"> _rGradTrans        ::</span> <span class="dt">T2</span> n
<span class="ot">></span>     ,<span class="ot"> _rGradSpreadMethod ::</span> <span class="dt">SpreadMethod</span> }</code></pre></div></div><p>Where radius and center 0 are for the inner circle, and 1 for the outer circle.
In this example we place the inner circle off center and place a circle filled
with the radial gradient on top of a rectangle filled with a linear gradient
to create a 3D effect.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/b7eec2e68bb02395.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> radial <span class="fu">=</span> mkRadialGradient (mkStops [(white,<span class="dv">0</span>,<span class="dv">1</span>), (black,<span class="dv">1</span>,<span class="dv">1</span>)])
<span class="ot">></span>                           ((<span class="fu">-</span><span class="fl">0.15</span>) <span class="fu">^&</span> (<span class="fl">0.15</span>)) <span class="fl">0.06</span> (<span class="dv">0</span> <span class="fu">^&</span> <span class="dv">0</span>) <span class="fl">0.5</span>
<span class="ot">></span>                           <span class="dt">GradPad</span>
<span class="ot">></span>
<span class="ot">></span> linear <span class="fu">=</span> mkLinearGradient (mkStops [(black,<span class="dv">0</span>,<span class="dv">1</span>), (white,<span class="dv">1</span>,<span class="dv">1</span>)])
<span class="ot">></span>                           (<span class="dv">0</span> <span class="fu">^&</span> (<span class="fu">-</span><span class="fl">0.5</span>)) (<span class="dv">0</span> <span class="fu">^&</span> <span class="fl">0.5</span>)
<span class="ot">></span>                           <span class="dt">GradPad</span>
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> circle <span class="fl">0.35</span> <span class="fu">#</span> fillTexture radial <span class="fu">#</span> lw none
<span class="ot">></span>        <span class="fu"><></span> rect <span class="dv">2</span> <span class="dv">1</span> <span class="fu">#</span> fillTexture linear <span class="fu">#</span> lw none</code></pre></div></div></div></div><div class="section" id="line-width"><h4>Line width</h4><p>Line width is actually more subtle than you might think.  Suppose you
create a diagram consisting of a square, and another square twice as
large next to it (using <code class="sourceCode">scale <span class="dv">2</span></code>).  How should they be drawn?  Should
the lines be the same width, or should the larger square use a line
twice as thick?  (Note that similar questions also come up when
considering the dashing style used to draw some shapes—should the
size of the dashes scale with transformations applied to the shapes,
or not?) <code>diagrams</code> allows the user to decide, using <code class="sourceCode"><span class="dt">Measure</span> <span class="dt">Double</span></code>
values to specify things like line width (see <a class="reference internal" href="#measurement-units">Measurement units</a>).</p><p>In many situations, it is desirable to have lines drawn in a uniform
way, regardless of any scaling applied to shapes.  This is what
happens with line widths measured in <code class="sourceCode">global</code>, <code class="sourceCode">normalized</code> or
<code class="sourceCode">output</code> units, as in the following example:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/284d12b4ef82d4bb.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> hcat
<span class="ot">></span>   [ square <span class="dv">1</span>
<span class="ot">></span>   , square <span class="dv">1</span> <span class="fu">#</span> scale <span class="dv">2</span>
<span class="ot">></span>   , circle <span class="dv">1</span> <span class="fu">#</span> scaleX <span class="dv">3</span>
<span class="ot">></span>   ]
<span class="ot">></span>   <span class="fu">#</span> dashingN [<span class="fl">0.03</span>,<span class="fl">0.03</span>] <span class="dv">0</span>
<span class="ot">></span>   <span class="fu">#</span> lwN <span class="fl">0.01</span></code></pre></div></div></div><p>For line widths that scale along with a diagram, use <code class="sourceCode">local</code>; in this
case line widths will be scaled in proportion to the geometeric
average of the scaling transformations applied to the diagram.</p><p>The <code class="sourceCode"><span class="dt">LineWidth</span></code> attribute is used to alter the <em>width</em> with which
paths are stroked. The most general functions that can be used to set
the line width are <code class="sourceCode">lineWidth</code> and its synonym <code class="sourceCode">lw</code>, which take an
argument of type <code class="sourceCode"><span class="dt">Measure</span> <span class="dt">V2</span> n</code>.  Since typing things like <code class="sourceCode">lineWidth
(normalized <span class="fl">0.01</span>)</code> is cumbersome, there are also shortcuts provided:
<code class="sourceCode">lwG</code>, <code class="sourceCode">lwN</code>, <code class="sourceCode">lwO</code>, and <code class="sourceCode">lwL</code> all take an argument of type <code class="sourceCode"><span class="dt">Double</span></code>
and wrap it in <code class="sourceCode">global</code>, <code class="sourceCode">normalized</code>, <code class="sourceCode">output</code> and <code class="sourceCode">local</code>,
respectively.</p><p>There are also predefined <code class="sourceCode"><span class="dt">Measure</span> n</code> values with intuitive names,
namely, <code class="sourceCode">ultraThin</code>, <code class="sourceCode">veryThin</code>, <code class="sourceCode">thin</code>, <code class="sourceCode">medium</code>, <code class="sourceCode">thick</code>,
<code class="sourceCode">veryThick</code>, <code class="sourceCode">ultraThick</code>, and <code class="sourceCode">none</code> (the default is <code class="sourceCode">medium</code>), which
should often suffice for setting the line width.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/f05e0ea8eed5df4d.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> line <span class="fu">=</span> strokeT <span class="fu">.</span> fromOffsets <span class="fu">$</span> [unitX]
<span class="ot">></span> example <span class="fu">=</span> vcat' (with <span class="fu">&</span> sep <span class="fu">.~</span> <span class="fl">0.1</span>)
<span class="ot">></span>   [line <span class="fu">#</span> lw w <span class="fu">|</span> w <span class="ot"><-</span> [ultraThin, veryThin, thin,
<span class="ot">></span>                        medium, thick, veryThick, ultraThick]]</code></pre></div></div></div><p>In the above example, there is no discernible difference between
<code class="sourceCode">ultraThin</code> and <code class="sourceCode">veryThin</code> (depending on the resolution of your
display you may not see any difference with <code class="sourceCode">thin</code> either); these
names all describe <code class="sourceCode">normalized</code> measurements with a physical lower
bound, so the physical width of the resulting lines depends on the
physical size of the rendered diagram.  At larger rendering sizes the
differences between the smaller widths become apparent.</p><p>Note that line width does not affect the envelope of diagrams at all.
To stroke a line "internally", turning it into a <code class="sourceCode"><span class="dt">Path</span></code> value
enclosing the stroked area (which <em>does</em> contribute to the envelope),
you can use one of the functions described in the section <a class="reference internal" href="#offsets-of-segments-trails-and-paths">Offsets of
segments, trails, and paths</a>.</p></div><div class="section" id="other-line-parameters"><h4>Other line parameters</h4><p>Many rendering backends provide some control over the particular way
in which lines are drawn.  Currently, <code>diagrams</code> provides built-in
support for three aspects of line drawing:</p><ul><li><p><code class="sourceCode">lineCap</code> sets the <code class="sourceCode"><span class="dt">LineCap</span></code> style.</p></li><li><p><code class="sourceCode">lineJoin</code> sets the <code class="sourceCode"><span class="dt">LineJoin</span></code> style.</p></li><li><p><code class="sourceCode">dashing</code> allows for drawing dashed lines with arbitrary dashing
patterns.</p></li></ul><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/e82b063f5a9ef83f.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> path <span class="fu">=</span> fromVertices (map p2 [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="fl">0.3</span>), (<span class="dv">2</span>,<span class="dv">0</span>), (<span class="fl">2.2</span>,<span class="fl">0.3</span>)]) <span class="fu">#</span> lwO <span class="dv">20</span>
<span class="ot">></span> example <span class="fu">=</span> center <span class="fu">.</span> vcat' (with <span class="fu">&</span> sep <span class="fu">.~</span> <span class="fl">0.1</span> )
<span class="ot">></span>           <span class="fu">$</span> map (path <span class="fu">#</span>)
<span class="ot">></span>             [ lineCap <span class="dt">LineCapButt</span>   <span class="fu">.</span> lineJoin <span class="dt">LineJoinMiter</span>
<span class="ot">></span>             , lineCap <span class="dt">LineCapRound</span>  <span class="fu">.</span> lineJoin <span class="dt">LineJoinRound</span>
<span class="ot">></span>             , lineCap <span class="dt">LineCapSquare</span> <span class="fu">.</span> lineJoin <span class="dt">LineJoinBevel</span>
<span class="ot">></span>             , dashingN [<span class="fl">0.03</span>,<span class="fl">0.06</span>,<span class="fl">0.09</span>,<span class="fl">0.03</span>] <span class="dv">0</span>
<span class="ot">></span>             ]</code></pre></div></div></div></div><div class="section" id="the-hasstyle-class"><h4>The <code>HasStyle</code> class</h4><p>Functions such as <code class="sourceCode">fc</code>, <code class="sourceCode">lc</code>, <code class="sourceCode">lw</code>, and <code class="sourceCode">lineCap</code> do not take only
diagrams as arguments.  They take any type which is an instance of the
<code class="sourceCode"><span class="dt">HasStyle</span></code> type class.  Of course, diagrams themselves are an
instance.</p><p>However, the <code class="sourceCode"><span class="dt">Style</span></code> type is also an instance.  This is useful in
writing functions which offer the caller flexible control over the
style of generated diagrams.  The general pattern is to take a <code class="sourceCode"><span class="dt">Style</span></code>
(or several) as an argument, then apply it to a diagram along with
some default attributes:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> myFun style <span class="fu">=</span> d <span class="fu">#</span> applyStyle style <span class="fu">#</span> lc red <span class="fu">#</span> <span class="fu">...</span>
<span class="ot">></span>   <span class="kw">where</span> d <span class="fu">=</span> <span class="fu">...</span></code></pre></div></div><p>This way, any attributes provided by the user in the <code class="sourceCode">style</code> argument
will override the default attributes specified afterwards.</p><p>To call <code class="sourceCode">myFun</code>, a user can construct a <code class="sourceCode"><span class="dt">Style</span></code> by starting with an
empty style (<code class="sourceCode">mempty</code>, since <code class="sourceCode"><span class="dt">Style</span></code> is an instance of <code class="sourceCode"><span class="dt">Monoid</span></code>) and
applying the desired attributes:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> foo <span class="fu">=</span> myFun (mempty <span class="fu">#</span> fontSize (local <span class="dv">2</span>) <span class="fu">#</span> lw none <span class="fu">#</span> fc green)</code></pre></div></div><p>If the type <code class="sourceCode"><span class="dt">T</span></code> is an instance of <code class="sourceCode"><span class="dt">HasStyle</span></code>, then <code class="sourceCode">[<span class="dt">T</span>]</code> is also.
This means that you can apply styles uniformly to entire lists of
diagrams at once, which occasionally comes in handy, for example, to
assign a default attribute to all diagrams in a list which do not
already have one:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/60dd14d0695e7fef.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> hcat <span class="fu">$</span>
<span class="ot">></span>   [circle <span class="dv">1</span>, square <span class="dv">2</span>, triangle <span class="dv">2</span> <span class="fu">#</span> fc yellow, hexagon <span class="dv">1</span>] <span class="fu">#</span> fc blue</code></pre></div></div></div><p>Likewise, there are <code class="sourceCode"><span class="dt">HasStyle</span></code> instances for pairs, <code class="sourceCode"><span class="dt">Map</span></code>s, <code class="sourceCode"><span class="dt">Set</span></code>s,
and functions.</p></div></div><div class="section" id="static-attributes"><h3>Static attributes</h3><p>Diagrams can also have "static attributes" which are applied at a
specific node in the tree representing a diagram.  Currently, only
two static attributes are provided:</p><ul><li><p>Hyperlinks are supported only by the SVG backend.  To turn a diagram
into a hyperlink, use the <code class="sourceCode">href</code> function.</p></li><li><p>Transparency grouping via the <code class="sourceCode">opacityGroup</code> function is supported
only by the SVG, PGF and (as of 1.3) Rasterific backends; see <a class="reference internal" href="#color-and-opacity">Color and Opacity</a>.</p></li></ul><p>More static attributes (for example, node IDs) and wider backend
support may be added in future versions.</p></div><div class="section" id="d-transformations"><h3>2D Transformations</h3><p>Any diagram can be transformed by applying arbitrary affine
transformations to it. <em>Affine</em> transformations include <em>linear</em>
transformations (rotation, scaling, reflection, shears—anything
which leaves the origin fixed and sends lines to lines) as well as
translations.  In the simplified case of the real line, an affine
transformation is any function of the form \(f(x) = mx + b\).
Generalizing to \(d\) dimensions, an affine transformation is a
vector function of the form \(f(\mathbf{v}) = \mathbf{M}\mathbf{v} +
\mathbf{b}\), where \(\mathbf{M}\) is a \(d \times d\)
matrix representing a linear transformation, and \(\mathbf{b}\) is
a \(d\)-dimensional vector representing a translation.  More
general, non-affine transformations, including projective
transformations, are referred to in <code>diagrams</code> as <a class="reference internal" href="#deformations">Deformations</a>.</p><p><code>Diagrams.TwoD.Transform</code> defines a number of common affine
transformations in two-dimensional space. (To construct
transformations more directly, see <code>Diagrams.Core.Transform</code>.)</p><p>Every transformation comes in two variants, a noun form and a verb
form.  For example, there are two functions for scaling along the
\(x\)-axis, <code class="sourceCode">scalingX</code> and <code class="sourceCode">scaleX</code>.  The noun form (<em>e.g.</em>
<code class="sourceCode">scalingX</code>) constructs a <code class="sourceCode"><span class="dt">Transformation</span></code> value, which can then be
stored in a data structure, passed as an argument, combined with other
transformations, <em>etc.</em>, and ultimately applied to a diagram (or other
<code class="sourceCode"><span class="dt">Transformable</span></code> value) with the <code class="sourceCode">transform</code> function.  The verb form
directly applies the transformation.  The verb form is much more
common (and the documentation below will only discuss verb forms), but
getting one's hands on a first-class <code class="sourceCode"><span class="dt">Transformation</span></code> value can
occasionally be useful.</p><div class="warning bs-callout bs-callout-warning"><p>Both the verb and noun variants of transformations are monoids, and
can be composed with <code class="sourceCode">(<span class="fu"><></span>)</code>. However, the results are quite distinct,
as shown in this example.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/dcf2d836ca4a753c.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> ell <span class="fu">=</span> text <span class="st">"L"</span> <span class="fu"><></span> square <span class="dv">1</span> <span class="fu">#</span> lw none
<span class="ot">></span> alpha <span class="fu">=</span> <span class="dv">45</span> <span class="fu">@@</span> deg
<span class="ot">></span>
<span class="ot">></span> dia1 <span class="fu">=</span> ell <span class="fu">#</span> translateX <span class="dv">2</span> <span class="fu">#</span> rotate alpha
<span class="ot">></span> dia2 <span class="fu">=</span> ell <span class="fu">#</span> ( rotate alpha <span class="fu"><></span> translateX <span class="dv">2</span> )
<span class="ot">></span> dia3 <span class="fu">=</span> ell <span class="fu">#</span> transform ( rotation alpha <span class="fu"><></span> translationX <span class="dv">2</span> )
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span>
<span class="ot">></span>   hsep <span class="dv">2</span>
<span class="ot">></span>     [ (dia1 <span class="fu"><></span> orig)
<span class="ot">></span>     , vrule <span class="dv">4</span>
<span class="ot">></span>     , (dia2 <span class="fu"><></span> orig)
<span class="ot">></span>     , vrule <span class="dv">4</span>
<span class="ot">></span>     , (dia3 <span class="fu"><></span> orig)
<span class="ot">></span>     ]
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     orig <span class="fu">=</span> circle <span class="fl">0.05</span> <span class="fu">#</span> fc red <span class="fu">#</span> lw none</code></pre></div></div></div><p><code class="sourceCode">dia1</code> is the intended result: a character L translated along the X axis,
and then rotated 45 degrees around the origin.</p><p><code class="sourceCode">dia2</code> shows the result of naively composing the verb versions of
the transformations: a superposition of a rotated L and a
translated L.  To understand this, consider that <code class="sourceCode">(rotate alpha)</code>
is a <em>function</em>, and functions as monoid instances (<code class="sourceCode"><span class="dt">Monoid</span> m <span class="ot">=></span>
<span class="dt">Monoid</span> (a <span class="ot">-></span> m)</code>) are composed as <code class="sourceCode">(f <span class="fu"><></span> g) x <span class="fu">=</span> f x <span class="fu"><></span> g x</code>.  To
quote the <a class="reference external" href="http://www.haskell.org/haskellwiki/Typeclassopedia#Instances_4">Typeclassopedia</a>: if <code class="sourceCode">a</code> is a Monoid, then so is the
function type <code class="sourceCode">e <span class="ot">-></span> a</code> for any <code class="sourceCode">e</code>; in particular, <code class="sourceCode">g <span class="ot">`mappend`</span>
h</code> is the function which applies both <code class="sourceCode">g</code> and <code class="sourceCode">h</code> to its argument
and then combines the results using the underlying Monoid instance
for <code class="sourceCode">a</code>.</p><p>Hence <code class="sourceCode">ell <span class="fu">#</span> ( rotate alpha <span class="fu"><></span> translateX <span class="dv">2</span> )</code> is
the same as the superposition of two diagrams: <code class="sourceCode">rotate alpha ell <span class="fu"><></span>
translateX <span class="dv">2</span> ell</code>.</p><p><code class="sourceCode">dia3</code> shows how the noun versions can be composed (using the
<code class="sourceCode"><span class="dt">Monoid</span></code> instance for <code class="sourceCode"><span class="dt">Transformation</span></code>) with the intended result.</p></div><div class="section" id="affine-transformations-in-general"><h4>Affine transformations in general</h4><p>Before looking at specific two-dimensional transformations, it's worth
saying a bit about transformations in general (a fuller treatment can
be found in the <a class="reference external" href="core.html">core library reference</a>).  The <code class="sourceCode"><span class="dt">Transformation</span></code> type
is defined in <code>Diagrams.Core.Transform</code>, from the
<span class="package"><a href="http://hackage.haskell.org/package/diagrams-core"><code>diagrams-core</code></a></span> package.  <code class="sourceCode"><span class="dt">Transformation</span></code> is parameterized by
the vector space over which it acts, and the type of scalars; recall
that <code class="sourceCode"><span class="dt">T2</span> n</code> is provided as a synonym for <code class="sourceCode"><span class="dt">Transformation</span> <span class="dt">V2</span> n</code>.</p><p><code class="sourceCode"><span class="dt">Transformation</span> v n</code> is a <code class="sourceCode"><span class="dt">Monoid</span></code> for any vector space <code class="sourceCode">v</code>:</p><ul><li><p><code class="sourceCode">mempty</code> is the identity transformation;</p></li><li><p><code class="sourceCode">mappend</code> is composition of transformations: <code class="sourceCode">t1 <span class="ot">`mappend`</span> t2</code>
(also written <code class="sourceCode">t1 <span class="fu"><></span> t2</code>) performs first <code class="sourceCode">t2</code>, then <code class="sourceCode">t1</code>.</p></li></ul><p>To invert a transformation, use <code class="sourceCode">inv</code>.  For any transformation <code class="sourceCode">t</code>,</p><p><code class="sourceCode">t <span class="fu"><></span> inv t <span class="fu">===</span> inv t <span class="fu"><></span> t <span class="fu">===</span> mempty</code>.</p><p>To apply a transformation, use <code class="sourceCode">transform</code>.</p></div><div class="section" id="rotation"><h4>Rotation</h4><p>Use <code class="sourceCode">rotate</code> to rotate a diagram counterclockwise by a given <a class="reference internal" href="#angles">angle</a>
about the origin.  Since <code class="sourceCode">rotate</code> takes an <code class="sourceCode"><span class="dt">Angle</span> n</code>, you must specify an
angle unit, such as <code class="sourceCode">rotate (<span class="dv">80</span> <span class="fu">@@</span> deg)</code>.  In the common case that you
wish to rotate by an angle specified as a certain fraction of a
circle, like <code class="sourceCode">rotate (<span class="dv">1</span><span class="fu">/</span><span class="dv">8</span> <span class="fu">@@</span> turn)</code>, you can use <code class="sourceCode">rotateBy</code>
instead. <code class="sourceCode">rotateBy</code> takes a <code class="sourceCode"><span class="dt">Double</span></code> argument expressing the number of
turns, so in this example you would only have to write <code class="sourceCode">rotateBy
(<span class="dv">1</span><span class="fu">/</span><span class="dv">8</span>)</code>.</p><p>You can also use <code class="sourceCode">rotateAbout</code> in the case that you want to rotate
about some point other than the origin.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/373c0669dec316c6.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> eff <span class="fu">=</span> text <span class="st">"F"</span> <span class="fu"><></span> square <span class="dv">1</span> <span class="fu">#</span> lw none
<span class="ot">></span> rs  <span class="fu">=</span> map rotateBy [<span class="dv">1</span><span class="fu">/</span><span class="dv">7</span>, <span class="dv">2</span><span class="fu">/</span><span class="dv">7</span> <span class="fu">..</span> <span class="dv">6</span><span class="fu">/</span><span class="dv">7</span>]
<span class="ot">></span> example <span class="fu">=</span> hcat <span class="fu">.</span> map (eff <span class="fu">#</span>) <span class="fu">$</span> rs</code></pre></div></div></div></div><div class="section" id="scaling-and-reflection"><h4>Scaling and reflection</h4><p>Scaling by a given factor is accomplished with <code class="sourceCode">scale</code> (which scales
uniformly in all directions), <code class="sourceCode">scaleX</code> (which scales along the \(x\)-axis
only), or <code class="sourceCode">scaleY</code> (which scales along the \(y\)-axis only).  All of these
can be used both for enlarging (with a factor greater than one) and
shrinking (with a factor less than one).  Using a negative factor
results in a reflection (in the case of <code class="sourceCode">scaleX</code> and <code class="sourceCode">scaleY</code>) or a
180-degree rotation (in the case of <code class="sourceCode">scale</code>).</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/79fa4241f4b577fb.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> eff <span class="fu">=</span> text <span class="st">"F"</span> <span class="fu"><></span> square <span class="dv">1</span> <span class="fu">#</span> lw none
<span class="ot">></span> ts  <span class="fu">=</span> [ scale (<span class="dv">1</span><span class="fu">/</span><span class="dv">2</span>), id, scale <span class="dv">2</span>,    scaleX <span class="dv">2</span>,    scaleY <span class="dv">2</span>
<span class="ot">></span>       ,                  scale (<span class="fu">-</span><span class="dv">1</span>), scaleX (<span class="fu">-</span><span class="dv">1</span>), scaleY (<span class="fu">-</span><span class="dv">1</span>)
<span class="ot">></span>       ]
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hcat <span class="fu">.</span> map (eff <span class="fu">#</span>) <span class="fu">$</span> ts</code></pre></div></div></div><p>Scaling by zero is forbidden.  Let us never speak of it again.</p><p>For convenience, <code class="sourceCode">reflectX</code> and <code class="sourceCode">reflectY</code> perform reflection along
the \(x\)- and \(y\)-axes, respectively.  Their names can be
confusing (does <code class="sourceCode">reflectX</code> reflect <em>along</em> the \(x\)-axis or
<em>across</em> the \(x\)-axis?) but you can just remember that
<code class="sourceCode">reflectX <span class="fu">=</span> scaleX (<span class="fu">-</span><span class="dv">1</span>)</code>, and similarly for <code class="sourceCode">reflectY</code>; that is,
<code>reflectQ</code> affects <code>Q</code>-coordinates.</p><p><code class="sourceCode">reflectXY</code> swaps the \(x\)- and \(y\)-coordinates, that is,
it reflects across the line \(y = x\).  To reflect across any
other line, use <code class="sourceCode">reflectAbout</code>.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/1dda3462775087eb.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> eff <span class="fu">=</span> text <span class="st">"F"</span> <span class="fu"><></span> square <span class="dv">1</span> <span class="fu">#</span> lw none
<span class="ot">></span> example <span class="fu">=</span> eff
<span class="ot">></span>        <span class="fu"><></span> reflectAbout (p2 (<span class="fl">0.2</span>,<span class="fl">0.2</span>)) (rotateBy (<span class="fu">-</span><span class="dv">1</span><span class="fu">/</span><span class="dv">10</span>) xDir) eff</code></pre></div></div></div></div><div class="section" id="translation"><h4>Translation</h4><p>Translation is achieved with <code class="sourceCode">translate</code>, <code class="sourceCode">translateX</code>, and
<code class="sourceCode">translateY</code>, which should be self-explanatory.</p></div><div class="section" id="transformation-matrices"><h4>Transformation matrices</h4><p>Internally, diagrams does not use matrices to represent affine
transformations, but <code>Diagrams.Transform.Matrix</code> provides several
functions for converting back and forth between <code class="sourceCode"><span class="dt">Transformation</span></code>s and
their matrix representations.</p></div><div class="section" id="conjugation"><h4>Conjugation</h4><p><code>Diagrams.Transform</code> also exports some useful transformation
utilities which are not specific to two dimensions.  The <code class="sourceCode">conjugate</code>
function performs conjugation: <code class="sourceCode">conjugate t1 t2 <span class="fu">==</span> inv t1 <span class="fu"><></span> t2 <span class="fu"><></span>
t1</code>, that is, it performs <code class="sourceCode">t1</code>, then <code class="sourceCode">t2</code>, then undoes <code class="sourceCode">t1</code>.</p><p><code class="sourceCode">underT</code> performs a transformation using conjugation.  It takes as
arguments a function <code class="sourceCode">f</code> as well as a transformation to conjugate by,
and produces a function which performs the transformation, then <code class="sourceCode">f</code>,
then the inverse of the transformation.  For example, scaling by a
factor of 2 along the diagonal line \(y = x\) can be accomplished
thus:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/a7b8b3094caa4061.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> eff <span class="fu">=</span> text <span class="st">"F"</span> <span class="fu"><></span> square <span class="dv">1</span> <span class="fu">#</span> lw none
<span class="ot">></span> example <span class="fu">=</span> (scaleX <span class="dv">2</span> <span class="ot">`underT`</span> rotation (<span class="fu">-</span><span class="dv">1</span><span class="fu">/</span><span class="dv">8</span> <span class="fu">@@</span> turn)) eff</code></pre></div></div></div><p>The letter F is first rotated so that the desired scaling axis lies
along the \(x\)-axis; then <code class="sourceCode">scaleX</code> is performed; then it is rotated back
to its original position.</p><p>Note that <code class="sourceCode">reflectAbout</code> and <code class="sourceCode">rotateAbout</code> are implemented using
<code class="sourceCode">underT</code>.</p><p>Some functions for producing <code class="sourceCode"><span class="dt">Iso</span></code>s (from the <span class="package"><a href="http://hackage.haskell.org/package/lens"><code>lens</code></a></span> library)
are also provided, which serve a similar purpose to <code class="sourceCode">conjugate</code> and
<code class="sourceCode">underT</code>, but can be more convenient when working in a <code>lens</code>-y
style.  For example, the <code class="sourceCode">transformed</code> function takes a
<code class="sourceCode"><span class="dt">Transformation</span></code> and yields an <code class="sourceCode"><span class="dt">Iso</span></code> between untransformed and
transformed things.  <code class="sourceCode">movedTo</code>, <code class="sourceCode">movedFrom</code>, and <code class="sourceCode">translated</code> work
similarly, but specific to translation.</p></div><div class="section" id="id12 the-transformable-class"><h4>The <code>Transformable</code> class</h4><p>Transformations can be applied not just to diagrams, but values of any
type which is an instance of the <code class="sourceCode"><span class="dt">Transformable</span></code> type class.
Instances of <code class="sourceCode"><span class="dt">Transformable</span></code> include vectors, points, trails, paths,
envelopes, and <code class="sourceCode"><span class="dt">Transformations</span></code> themselves.  In addition,
tuples, lists, maps, or sets of <code class="sourceCode"><span class="dt">Transformable</span></code> things are also
<code class="sourceCode"><span class="dt">Transformable</span></code> in the obvious way.</p></div></div><div class="section" id="deformations"><h3>Deformations</h3><p>The affine transformations represented by <code class="sourceCode"><span class="dt">Transformation</span></code> include the
most commonly used transformations, but occasionally other sorts are
useful.  Non-affine transformations are represented by the
<code class="sourceCode"><span class="dt">Deformation</span></code> type.  The design is quite similar to that of
<code class="sourceCode"><span class="dt">Transformation</span></code>.  A <code class="sourceCode"><span class="dt">Deformation</span></code> is parameterized by the vector
spaces over which it acts: most generally, it may send objects in one
vector space to objects in another.  There is a <code class="sourceCode"><span class="dt">Deformable</span></code> type
class with a function <code class="sourceCode">deform</code>, which applies a <code class="sourceCode"><span class="dt">Deformation</span></code> to a
<code class="sourceCode"><span class="dt">Deformable</span></code> value.  There is also a function <code class="sourceCode">deform'</code> which takes an
extra tolerance parameter; applying deformations usually involves
approximation.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/25a4f0aa732c2a20.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> wibble ::</span> <span class="dt">Deformation</span> <span class="dt">V2</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> wibble <span class="fu">=</span> <span class="dt">Deformation</span> <span class="fu">$</span> \p <span class="ot">-></span>
<span class="ot">></span>   ((p<span class="fu">^.</span>_x) <span class="fu">+</span> <span class="fl">0.3</span> <span class="fu">*</span> cos ((p <span class="fu">^.</span> _y) <span class="fu">*</span> tau)) <span class="fu">^&</span> (p <span class="fu">^.</span> _y)
<span class="ot">></span>   <span class="co">-- perturb x-coordinates by the cosine of the y-coordinate</span>
<span class="ot">></span>
<span class="ot">> circles ::</span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> circles <span class="fu">=</span> mconcat <span class="fu">.</span> map circle <span class="fu">$</span> [<span class="dv">3</span>, <span class="fl">2.6</span>, <span class="fl">2.2</span>]
<span class="ot">></span>
<span class="ot">> example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> example <span class="fu">=</span> circles <span class="fu">#</span> deform' <span class="fl">0.0001</span> wibble <span class="fu">#</span> strokeP
<span class="ot">></span>         <span class="fu">#</span> fillRule <span class="dt">EvenOdd</span> <span class="fu">#</span> fc purple <span class="fu">#</span> frame <span class="dv">1</span></code></pre></div></div></div><p>Because the <code class="sourceCode">deform</code> function is so general, type signatures are often
required on both its inputs and results, as in the example above;
otherwise ambiguous type errors are likely to result.</p><p><code class="sourceCode"><span class="dt">Deformation</span> v v n</code> is a <code class="sourceCode"><span class="dt">Monoid</span></code> for any vector space <code class="sourceCode">v n</code>. (In
general, <code class="sourceCode"><span class="dt">Deformation</span> u v n</code> maps objects with vector space <code class="sourceCode">u</code> to
ones with vector space <code class="sourceCode">v</code>.)  New deformations can be formed by
composing two deformations.  The composition of an affine
transformation with a <code class="sourceCode"><span class="dt">Deformation</span></code> is also a <code class="sourceCode"><span class="dt">Deformation</span></code>.
<code class="sourceCode">asDeformation</code> converts a <code class="sourceCode"><span class="dt">Transformation</span></code> to an equivalent
<code class="sourceCode"><span class="dt">Deformation</span></code>, "forgetting" the inverse and other extra information
which distinguishes affine transformations.</p><p>The very general nature of deformations prevents certain types
from being <code class="sourceCode"><span class="dt">Deformable</span></code>.  Because not every <code class="sourceCode"><span class="dt">Deformation</span></code> is
invertible, diagrams cannot be deformed.  In general, for two points
\(p\) and \(q\), and a deformation \(D\), there may be no
deformation \(D_v\) such that \(Dp - Dq = D_v(p-q)\).  For
this reason, only points and concretely located types are deformable.
Finally, segments are not deformable because the image of the segment
may not be representable by a single segment.  The <code class="sourceCode"><span class="dt">Deformable</span></code>
instances for trails and paths will approximate each segment by
several segments as necessary.  Points, <code class="sourceCode"><span class="dt">Located</span></code> trails, and paths
are all deformable.</p><p>Because approximation and subdivision are required for many
<code class="sourceCode"><span class="dt">Deformable</span></code> instances, the type class provides a function <code class="sourceCode">deform'</code>,
which takes the approximation accuracy as its first argument.  For
trails and paths, <code class="sourceCode">deform</code> (without a prime) calls <code class="sourceCode">deform'</code> with an
error limit of 0.01 times the object's size.</p><p><code>Diagrams.TwoD.Deform</code> defines parallel and perspective
projections along the principal axes in 2 dimensions. The below
example projects the vertices of a square orthogonally onto the
\(x\)- and \(y\)-axes, and also using a perspective projection
onto the line \(x = 1\).</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/913dc963d4728e78.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> sq <span class="fu">=</span> unitSquare <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">17</span>) <span class="fu">#</span> translate (<span class="dv">3</span> <span class="fu">^&</span> <span class="dv">2</span>)<span class="ot"> ::</span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> sqPts <span class="fu">=</span> concat <span class="fu">$</span> pathVertices sq  <span class="co">--XXX dont forget to change back to pathPoints</span>
<span class="ot">></span> marks <span class="fu">=</span> repeat <span class="fu">.</span> lw none <span class="fu">$</span> circle <span class="fl">0.05</span>
<span class="ot">></span> spots c pts <span class="fu">=</span> atPoints pts (marks <span class="fu">#</span> fc c)
<span class="ot">></span> connectPoints pts1 pts2
<span class="ot">></span>   <span class="fu">=</span> zipWith (<span class="fu">~~</span>) pts1 pts2
<span class="ot">></span>   <span class="fu">#</span> mconcat
<span class="ot">></span>   <span class="fu">#</span> dashingL [<span class="fl">0.1</span>, <span class="fl">0.1</span>] <span class="dv">0</span>
<span class="ot">></span> example <span class="fu">=</span>
<span class="ot">></span>   mconcat
<span class="ot">></span>   [ spots blue sqPts
<span class="ot">></span>   , strokeP sq
<span class="ot">></span>   , spots green (map (deform parallelX0) sqPts)
<span class="ot">></span>   , spots green (map (deform parallelY0) sqPts)
<span class="ot">></span>   , spots green (map (deform perspectiveX1) sqPts)
<span class="ot">></span>   , connectPoints sqPts (map (deform parallelX0) sqPts)
<span class="ot">></span>   , connectPoints sqPts (map (deform parallelY0) sqPts)
<span class="ot">></span>   , connectPoints sqPts (repeat origin)
<span class="ot">></span>   ]</code></pre></div></div></div></div><div class="section" id="alignment"><h3>Alignment</h3><p>Since diagrams are always combined with respect to their local
origins, moving a diagram's local origin affects the way it combines
with others.  The position of a diagram's local origin is referred to
as its <em>alignment</em>.</p><p>The functions <code class="sourceCode">moveOriginBy</code> and <code class="sourceCode">moveOriginTo</code> are provided for
explicitly moving a diagram's origin, by an absolute amount and to an
absolute location, respectively.  <code class="sourceCode">moveOriginBy</code> and <code class="sourceCode">translate</code> are
actually dual, in the sense that</p><pre><code>moveOriginBy v === translate (negated v).</code></pre><p>This duality comes about since <code class="sourceCode">translate</code> moves a diagram with
respect to its origin, whereas <code class="sourceCode">moveOriginBy</code> moves the <em>origin</em> with
respect to the <em>diagram</em>.  Both are provided so that you can use
whichever one corresponds to the most natural point of view in a given
situation, without having to worry about inserting calls to <code class="sourceCode">negated</code>.</p><p>Often, however, one wishes to move a diagram's origin with respect to
its "boundary".  Here, boundary usually refers to the diagram's
envelope or trace, with envelope being the default (see <a class="reference internal" href="#envelopes">Envelopes</a>
and <a class="reference internal" href="#traces">Traces</a> for more information). To this end, some general tools
are provided in <code>Diagrams.Align</code>, and specialized 2D-specific
ones by <code>Diagrams.TwoD.Align</code>.</p><p>Functions like <code class="sourceCode">alignT</code> (align Top) and <code class="sourceCode">alignBR</code> (align Bottom Right)
move the local origin to the edge of the envelope:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/2e5d204c631e481f.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> s <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> fc yellow
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="fl">0.5</span>
<span class="ot">></span>   [ s <span class="fu">#</span> showOrigin
<span class="ot">></span>   , s <span class="fu">#</span> alignT  <span class="fu">#</span> showOrigin
<span class="ot">></span>   , s <span class="fu">#</span> alignBR <span class="fu">#</span> showOrigin
<span class="ot">></span>   ]</code></pre></div></div></div><p>There are two things to note about the above example.  First, notice
how <code class="sourceCode">alignT</code> and <code class="sourceCode">alignBR</code> move the local origin of the square in the
way you would expect.  Second, notice that when placed "next to" each
other using the <code class="sourceCode">(<span class="fu">|||</span>)</code> operator (here implicitly via <code class="sourceCode">hsep</code>), the
squares are placed so that their local origins fall on a horizontal
line.</p><p>Functions like <code class="sourceCode">alignY</code> allow finer control over the alignment.  In
the below example, the origin is moved to a series of locations
interpolating between the bottom and top of the square:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/5134bba6ed3d4617.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> s <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> fc yellow
<span class="ot">></span> example <span class="fu">=</span> hcat <span class="fu">.</span> map showOrigin
<span class="ot">></span>         <span class="fu">$</span> zipWith alignY [<span class="fu">-</span><span class="dv">1</span>, <span class="fu">-</span><span class="fl">0.8</span> <span class="fu">..</span> <span class="dv">1</span>] (repeat s)</code></pre></div></div></div><p>To center an object along an axis we provide the functions <code class="sourceCode">centerX</code>
and <code class="sourceCode">centerY</code>. An object can be simultaneously centered along both axes
(actually along all of its basis vectors) using the <code class="sourceCode">center</code> function
(or <code class="sourceCode">centerXY</code> in the specific case of two dimensions).</p><p>The align functions have sister functions like <code class="sourceCode">snugL</code> and <code class="sourceCode">snugX</code>
that work the same way as <code class="sourceCode">alignL</code> and <code class="sourceCode">alignX</code>. The difference is
that the <code class="sourceCode">snug</code> class of functions use the trace as the boundary
instead of the envelope. For example, here we want to snug a convex
shape (the orange triangle) next to a concave shape (the blue
polygon):</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/3de89fcdc1f5c84c.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.TwoD.Align</span>
<span class="ot">></span>
<span class="ot">></span> concave <span class="fu">=</span> polygon ( with <span class="fu">&</span> polyType <span class="fu">.~</span> <span class="dt">PolyPolar</span> [a, b, b, b]
<span class="ot">></span>                   [ <span class="fl">0.25</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>] <span class="fu">&</span> polyOrient <span class="fu">.~</span> <span class="dt">NoOrient</span> )
<span class="ot">></span>                   <span class="fu">#</span> fc blue <span class="fu">#</span> lw none
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     a <span class="fu">=</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">8</span> <span class="fu">@@</span> turn
<span class="ot">></span>     b <span class="fu">=</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">4</span> <span class="fu">@@</span> turn
<span class="ot">></span>
<span class="ot">></span> convex <span class="fu">=</span> polygon (with <span class="fu">&</span> polyType <span class="fu">.~</span> <span class="dt">PolyPolar</span> [a,b] [<span class="fl">0.25</span>, <span class="dv">1</span>, <span class="dv">1</span>]
<span class="ot">></span>                        <span class="fu">&</span> polyOrient <span class="fu">.~</span> <span class="dt">NoOrient</span>)
<span class="ot">></span>                        <span class="fu">#</span> fc orange <span class="fu">#</span> lw none
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     a <span class="fu">=</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">8</span> <span class="fu">@@</span> turn
<span class="ot">></span>     b <span class="fu">=</span> <span class="dv">3</span><span class="fu">/</span><span class="dv">4</span> <span class="fu">@@</span> turn
<span class="ot">></span>
<span class="ot">></span> aligned <span class="fu">=</span> (concave <span class="fu">#</span> center <span class="fu">#</span> alignR <span class="fu">#</span> showOrigin)
<span class="ot">></span>        <span class="fu"><></span> (convex <span class="fu">#</span> center <span class="fu">#</span> alignL <span class="fu">#</span> showOrigin)
<span class="ot">></span>
<span class="ot">></span> snugged <span class="fu">=</span> (concave <span class="fu">#</span> center <span class="fu">#</span> snugR <span class="fu">#</span> showOrigin)
<span class="ot">></span>        <span class="fu"><></span> (convex <span class="fu">#</span> center <span class="fu">#</span> snugL <span class="fu">#</span> showOrigin)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> aligned <span class="fu">|||</span> strutX <span class="fl">0.5</span> <span class="fu">|||</span> snugged</code></pre></div></div></div><p>The <code class="sourceCode">snugR</code> function moves the origin of the blue polygon to the
rightmost edge of its trace in the diagram on the right, whereas in
the left diagram the <code class="sourceCode">alignR</code> function puts it at the edge of the
envelope.</p></div><div class="section" id="aligned-composition"><h3>Aligned composition</h3><p>Sometimes, it is desirable to compose some diagrams according to a
certain alignment, but <em>without</em> affecting their local origins.  The
<code class="sourceCode">composeAligned</code> function can be used for this purpose.  It takes as
arguments an alignment function (such as <code class="sourceCode">alignT</code> or <code class="sourceCode">snugL</code>), a
composition function of type <code class="sourceCode">[<span class="dt">Diagram</span>] <span class="ot">-></span> <span class="dt">Diagram</span></code>, and produces a
new composition function which works by first aligning the diagrams
before composing them.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/9ee072af16ad26b0.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> (hsep <span class="dv">2</span> <span class="fu">#</span> composeAligned alignT) (map circle [<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>])
<span class="ot">></span>         <span class="fu">#</span> showOrigin</code></pre></div></div></div></div></div><div class="section" id="trails-and-paths"><h2><generated classes="sectnum">3.5   </generated>Trails and paths</h2><p>Trails and paths are some of the most fundamental tools in
<code>diagrams</code>.  They can be used not only directly to draw things, but
also as guides to help create and position other diagrams.</p><p>For additional practice and a more "hands-on" experience learning
about trails and paths, see the <a class="reference external" href="paths.html">trails and paths tutorial</a>.</p><div class="section" id="segments"><h3>Segments</h3><p>The most basic component of trails and paths is a <code class="sourceCode"><span class="dt">Segment</span></code>, which is
some sort of primitive path from one point to another.  Segments are
<em>translationally invariant</em>; that is, they have no inherent location,
and applying a translation to a segment has no effect (however, other
sorts of transformations, such as rotations and scales, have the
effect you would expect). In other words, a segment is not a way to
get from some particular point A to another point B; it is a way to
get from <em>wherever you currently happen to be</em> to <em>somewhere else</em>.</p><p>Currently, <code>diagrams</code> supports two types of segment, defined in
<code>Diagrams.Segment</code>:</p><ul><li><p>A <em>linear</em> segment is simply a straight line, defined by an offset
from its beginning point to its end point; you can construct one
using <code class="sourceCode">straight</code>.</p></li><li><p>A <em>Bézier</em> segment is a cubic curve defined by an offset from its
beginning to its end, along with two control points; you can
construct one using <code class="sourceCode">bezier3</code> (or <code class="sourceCode">bézier3</code>, if you are feeling
snobby).  An example is shown below, with the endpoints shown in red
and the control points in blue.  <a class="reference external" href="http://en.wikipedia.org/wiki/Bézier_curve">Bézier curves</a> always start off
from the beginning point heading towards the first control point,
and end up at the final point heading away from the last control
point.  That is, in any drawing of a Bézier curve like the one
below, the curve will be tangent to the two dotted lines.</p></li></ul><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/ea0eb62e81f040d5.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> illustrateBézier c1 c2 x2
<span class="ot">></span>     <span class="fu">=</span>  endpt
<span class="ot">></span>     <span class="fu"><></span> endpt  <span class="fu">#</span> translate x2
<span class="ot">></span>     <span class="fu"><></span> ctrlpt <span class="fu">#</span> translate c1
<span class="ot">></span>     <span class="fu"><></span> ctrlpt <span class="fu">#</span> translate c2
<span class="ot">></span>     <span class="fu"><></span> l1
<span class="ot">></span>     <span class="fu"><></span> l2
<span class="ot">></span>     <span class="fu"><></span> fromSegments [bézier3 c1 c2 x2]
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     dashed  <span class="fu">=</span> dashingN [<span class="fl">0.03</span>,<span class="fl">0.03</span>] <span class="dv">0</span>
<span class="ot">></span>     endpt   <span class="fu">=</span> circle <span class="fl">0.05</span> <span class="fu">#</span> fc red  <span class="fu">#</span> lw none
<span class="ot">></span>     ctrlpt  <span class="fu">=</span> circle <span class="fl">0.05</span> <span class="fu">#</span> fc blue <span class="fu">#</span> lw none
<span class="ot">></span>     l1      <span class="fu">=</span> fromOffsets [c1] <span class="fu">#</span> dashed
<span class="ot">></span>     l2      <span class="fu">=</span> fromOffsets [x2 <span class="fu">^-^</span> c2] <span class="fu">#</span> translate c2 <span class="fu">#</span> dashed
<span class="ot">></span>
<span class="ot">></span> x2      <span class="fu">=</span> r2 (<span class="dv">3</span>,<span class="fu">-</span><span class="dv">1</span>)<span class="ot"> ::</span> <span class="dt">V2</span> <span class="dt">Double</span>     <span class="co">-- endpoint</span>
<span class="ot">></span> [c1,c2] <span class="fu">=</span> map r2 [(<span class="dv">1</span>,<span class="dv">2</span>), (<span class="dv">3</span>,<span class="dv">0</span>)]     <span class="co">-- control points</span>
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> illustrateBézier c1 c2 x2</code></pre></div></div></div><p>Independently of the two types of segments explained above, segments
can be either <em>closed</em> or <em>open</em>.  A <em>closed</em> segment has a fixed
endpoint relative to its start.  An <em>open</em> segment, on the other hand,
has an endpoint determined by its context; open segments are used to
implement loops (explained in the <a class="reference internal" href="#trails">Trails</a> section below).  Most
users should have no need to work with open segments.  (For that
matter, most users will have no need to work directly with segments at
all.)</p><p>If you look in the <code>Diagrams.Segment</code> module, you will see quite
a bit of other stuff related to the implementation of trails
(<code class="sourceCode"><span class="dt">SegMeasure</span></code> and so on); this is explained in more detail in the
section <a class="reference internal" href="#trail-and-path-implementation-details">Trail and path implementation details</a>.</p><p>Functions from the <code>Diagrams.TwoD.Curvature</code> module can be used
to compute the curvature of segments at various points.  In future
releases of diagrams this may be extended to tools for finding the
curvature of trails and paths.</p></div><div class="section" id="trails"><h3>Trails</h3><p>Trails are defined in <code>Diagrams.Trail</code>.  Informally, you can
think of trails as lists of segments laid end-to-end.  Since segments
are translation-invariant, so are trails.  More formally, the
semantics of a trail is a continuous (though not necessarily
differentiable) function from the real interval \([0,1]\) to
vectors in some vector space.  This section serves as a reference on
trails; for a more hands-on introduction, refer to the <a class="reference external" href="../doc/paths.html">Trail and path
tutorial</a>.</p><p>There are two types of trail:</p><ul><li><p>A <em>loop</em>, with a type like <code class="sourceCode"><span class="dt">Trail'</span> <span class="dt">Loop</span> v n</code>, is a trail which forms
a "closed loop", ending at the same place where it started.</p><div class="exampleimg"><div style="text-align: center"><img src="images/9a54e0187738997e.png" width="500" height="200" /></div></div><p>Loops in 2D can be filled, as in the example above.</p></li><li><p>A <em>line</em>, with a type like <code class="sourceCode"><span class="dt">Trail'</span> <span class="dt">Line</span> v n</code>, is a trail which does
not form a closed loop, that is, it starts in one place and ends
in another.</p><div class="exampleimg"><div style="text-align: center"><img src="images/a0ff9c1ed3e427cf.png" width="500" height="200" /></div></div><p>Actually, a line can in fact happen to end in the same place where
it starts, but even so it is still not considered closed.  Lines
have no inside and outside, and are never filled.</p><div class="warning bs-callout bs-callout-warning"><p>Lines are never filled, even when they happen to start and end in
the same place!</p></div></li></ul><p>Finally, the type <code class="sourceCode"><span class="dt">Trail</span></code> can contain either a line or a loop.</p><p>The most important thing to understand about lines, loops, and trails
is how to convert between them.</p><ul><li><p>To convert from a line or a loop to a trail, use <code class="sourceCode">wrapLine</code> or
<code class="sourceCode">wrapLoop</code> (or <code class="sourceCode">wrapTrail</code>, if you don't know or care whether the
parameter is a line or loop).</p></li><li><p>To convert from a loop to a line, use <code class="sourceCode">cutLoop</code>.  This results in a
line which just so happens to end where it starts.</p></li><li><p>To convert from a line to a loop, there are two choices:</p><ul><li><p><code class="sourceCode">closeLine</code> adds a new linear segment from the end to the start of
the line.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/360610e63f64b127.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> almostClosed ::</span> <span class="dt">Trail'</span> <span class="dt">Line</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> almostClosed <span class="fu">=</span> fromOffsets <span class="fu">$</span> (map r2
<span class="ot">></span>   [(<span class="dv">2</span>, <span class="fu">-</span><span class="dv">1</span>), (<span class="fu">-</span><span class="dv">3</span>, <span class="fu">-</span><span class="fl">0.5</span>), (<span class="fu">-</span><span class="dv">2</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="fl">0.5</span>)])
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> pad <span class="fl">1.1</span> <span class="fu">.</span> center <span class="fu">.</span> fc orange <span class="fu">.</span> hsep <span class="dv">1</span>
<span class="ot">></span>   <span class="fu">$</span> [ almostClosed <span class="fu">#</span> strokeLine
<span class="ot">></span>     , almostClosed <span class="fu">#</span> closeLine <span class="fu">#</span> strokeLoop
<span class="ot">></span>     ]</code></pre></div></div></div></li><li><p><code class="sourceCode">glueLine</code> simply modifies the endpoint of the final segment to be
the start of the line.  This is most often useful if you have a
line which you know just so happens to end where it starts;
calling <code class="sourceCode">closeLine</code> in such a case would result in the addition of
a gratuitous length-zero segment.</p></li></ul></li></ul><p>Lines form a monoid under concatenation. For example, below we create
a two-segment line called <code>spoke</code> and then construct a starburst
path by concatenating a number of rotated copies.  Note how we call
<code class="sourceCode">glueLine</code> to turn the starburst into a closed loop, so that we can
fill it (lines cannot be filled).  <code class="sourceCode">strokeLoop</code> turns a loop into a
diagram, with the start of the loop at the local origin. (There are
also analogous functions <code class="sourceCode">strokeLine</code> and <code class="sourceCode">strokeTrail</code>.)</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/3103a7e1ede0c3d9.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> spoke ::</span> <span class="dt">Trail'</span> <span class="dt">Line</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> spoke <span class="fu">=</span> fromOffsets <span class="fu">.</span> map r2 <span class="fu">$</span> [(<span class="dv">1</span>,<span class="dv">3</span>), (<span class="dv">1</span>,<span class="fu">-</span><span class="dv">3</span>)]
<span class="ot">></span>
<span class="ot">> burst ::</span> <span class="dt">Trail'</span> <span class="dt">Loop</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> burst <span class="fu">=</span> glueLine <span class="fu">.</span> mconcat <span class="fu">.</span> take <span class="dv">13</span> <span class="fu">.</span> iterate (rotateBy (<span class="fu">-</span><span class="dv">1</span><span class="fu">/</span><span class="dv">13</span>)) <span class="fu">$</span> spoke
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> strokeLoop burst <span class="fu">#</span> fc yellow <span class="fu">#</span> lw thick <span class="fu">#</span> lc orange</code></pre></div></div></div><p>For convenience, there is also a monoid instance for <code class="sourceCode"><span class="dt">Trail</span></code> based on
the instance for lines: any loops are first cut with <code class="sourceCode">cutLine</code>, and
the results concatenated.  Typically this would be used in a situation
where you know that all your trails actually contain lines.</p><p>Loops, on the other hand, have no monoid instance.</p><p>To construct a line, loop, or trail, you can use one of the following:</p><ul><li><p><code class="sourceCode">fromOffsets</code> takes a list of vectors, and turns each one into a
linear segment.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/55ef42622df81f82.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> theLine <span class="fu">=</span> fromOffsets (iterateN <span class="dv">5</span> (rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">20</span>)) unitX)
<span class="ot">></span> example <span class="fu">=</span> theLine <span class="fu">#</span> strokeLine
<span class="ot">></span>         <span class="fu">#</span> lc blue <span class="fu">#</span> lw thick <span class="fu">#</span> center <span class="fu">#</span> pad <span class="fl">1.1</span></code></pre></div></div></div></li><li><p><code class="sourceCode">fromVertices</code> takes a list of vertices, generating linear segments
between them.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/f821668764614d6f.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> vertices <span class="fu">=</span> map p2 <span class="fu">$</span> [(x,y) <span class="fu">|</span> x <span class="ot"><-</span> [<span class="dv">0</span>,<span class="fl">0.2</span> <span class="fu">..</span> <span class="dv">2</span>], y <span class="ot"><-</span> [<span class="dv">0</span>,<span class="dv">1</span>]]
<span class="ot">></span> example <span class="fu">=</span> fromVertices vertices <span class="fu">#</span> strokeLine
<span class="ot">></span>         <span class="fu">#</span> lc red <span class="fu">#</span> center <span class="fu">#</span> pad <span class="fl">1.1</span></code></pre></div></div></div></li><li><p><code class="sourceCode">(<span class="fu">~~</span>)</code> creates a simple linear trail between two points.</p></li><li><p><code class="sourceCode">cubicSpline</code> creates a smooth curve passing through a given list of
points; it is described in more detail in the section on <a class="reference internal" href="#splines">Splines</a>.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/bf05faba1a548acb.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> vertices <span class="fu">=</span> map p2 <span class="fu">.</span> init <span class="fu">$</span> [(x,y) <span class="fu">|</span> x <span class="ot"><-</span> [<span class="dv">0</span>,<span class="fl">0.5</span> <span class="fu">..</span> <span class="dv">2</span>], y <span class="ot"><-</span> [<span class="dv">0</span>,<span class="fl">0.2</span>]]
<span class="ot">></span> theLine <span class="fu">=</span> cubicSpline <span class="dt">False</span> vertices
<span class="ot">></span> example <span class="fu">=</span> mconcat (iterateN <span class="dv">6</span> (rotateBy (<span class="fu">-</span><span class="dv">1</span><span class="fu">/</span><span class="dv">6</span>)) theLine)
<span class="ot">></span>         <span class="fu">#</span> glueLine <span class="fu">#</span> strokeLoop
<span class="ot">></span>         <span class="fu">#</span> lc green <span class="fu">#</span> lw veryThick <span class="fu">#</span> fc aqua <span class="fu">#</span> center <span class="fu">#</span> pad <span class="fl">1.1</span></code></pre></div></div></div></li><li><p><code class="sourceCode">bspline</code> creates a smooth curve controlled by a given list of
points; it is also described in more detail in the section on
<a class="reference internal" href="#splines">Splines</a>.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/06ce1d338b86a736.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> pts <span class="fu">=</span> map p2 (zip [<span class="dv">0</span> <span class="fu">..</span> <span class="dv">8</span>] (cycle [<span class="dv">0</span>, <span class="dv">1</span>]))
<span class="ot">></span> example <span class="fu">=</span> mconcat
<span class="ot">></span>   [ bspline pts
<span class="ot">></span>   , mconcat <span class="fu">$</span> map (place (circle <span class="fl">0.1</span> <span class="fu">#</span> fc blue <span class="fu">#</span> lw none)) pts
<span class="ot">></span>   ]</code></pre></div></div></div></li><li><p><code class="sourceCode">fromSegments</code> takes an explicit list of <code class="sourceCode"><span class="dt">Segment</span></code>s, which can
occasionally be useful if, say, you want to generate some Bézier
curves and assemble them into a trail.</p></li></ul><p>All the above functions construct loops by first constructing a line
and then calling <code class="sourceCode">glueLine</code> (see also the below section on
<a class="reference internal" href="#traillike">TrailLike</a>).</p><p>If you look at the types of these functions, you will note that they
do not, in fact, return just <code class="sourceCode"><span class="dt">Trail</span></code>s: they actually return any type
which is an instance of <code class="sourceCode"><span class="dt">TrailLike</span></code>, which includes lines, loops,
<code class="sourceCode"><span class="dt">Trail</span></code>s, <code class="sourceCode"><span class="dt">Path</span></code>s (to be covered in an upcoming section), <code class="sourceCode"><span class="dt">Diagram</span></code>s,
lists of points, and any of these wrapped in <code class="sourceCode"><span class="dt">Located</span></code> (see below).
See the <a class="reference internal" href="#traillike">TrailLike</a> section for more on the <code class="sourceCode"><span class="dt">TrailLike</span></code> class.</p><p>For details on other functions provided for manipulating trails, see
the documentation for <code>Diagrams.Trail</code>.  One other function worth
mentioning is <code class="sourceCode">explodeTrail</code>, which turns each segment in a trail into
its own individual <code class="sourceCode"><span class="dt">Path</span></code>.  This is useful when you want to construct
a trail but then do different things with its individual segments.
For example, we could construct the same starburst as above but color
the edges individually:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/0179ab3477db16c1.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> spoke ::</span> <span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> spoke <span class="fu">=</span> fromOffsets <span class="fu">.</span> map r2 <span class="fu">$</span> [(<span class="dv">1</span>,<span class="dv">3</span>), (<span class="dv">1</span>,<span class="fu">-</span><span class="dv">3</span>)]
<span class="ot">></span>
<span class="ot">></span> burst <span class="fu">=</span> mconcat <span class="fu">.</span> take <span class="dv">13</span> <span class="fu">.</span> iterate (rotateBy (<span class="fu">-</span><span class="dv">1</span><span class="fu">/</span><span class="dv">13</span>)) <span class="fu">$</span> spoke
<span class="ot">></span>
<span class="ot">></span> colors <span class="fu">=</span> cycle [aqua, orange, deeppink, blueviolet, crimson, darkgreen]
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> lw thick
<span class="ot">></span>         <span class="fu">.</span> mconcat
<span class="ot">></span>         <span class="fu">.</span> zipWith lc colors
<span class="ot">></span>         <span class="fu">.</span> map strokeLocTrail <span class="fu">.</span> explodeTrail
<span class="ot">></span>         <span class="fu">$</span> burst <span class="ot">`at`</span> origin</code></pre></div></div></div><p>(If we wanted to fill the starburst with yellow as before, we would
have to separately draw another copy of the trail with a line width of
zero and fill that; this is left as an exercise for the reader.)</p></div><div class="section" id="located"><h3>Located</h3><p>Something of type <code class="sourceCode"><span class="dt">Located</span> a</code> consists, essentially, of a value of
type <code class="sourceCode">a</code> paired with a point.  In this way, <code class="sourceCode"><span class="dt">Located</span></code> serves to
transform translation-invariant things (such as <code class="sourceCode"><span class="dt">Segment</span></code>s or
<code class="sourceCode"><span class="dt">Trail</span></code>s) into things with a fixed location.  A <code class="sourceCode"><span class="dt">Located</span> <span class="dt">Trail</span></code> is a
<code class="sourceCode"><span class="dt">Trail</span></code> where we have picked a concrete location for its starting
point, and so on.</p><p>The module <code>Diagrams.Located</code> defines the <code class="sourceCode"><span class="dt">Located</span></code> type and
utilities for working with it:</p><ul><li><p><code class="sourceCode">at</code> is used to construct <code class="sourceCode"><span class="dt">Located</span></code> values, and is designed to be
used infix, like <code class="sourceCode">someTrail <span class="ot">`at`</span> somePoint</code>.</p></li><li><p><code class="sourceCode">viewLoc</code>, <code class="sourceCode">unLoc</code>, and <code class="sourceCode">loc</code> can be used to project out the
components of a <code class="sourceCode"><span class="dt">Located</span></code> value.</p></li><li><p><code class="sourceCode">mapLoc</code> can be used to apply a function to the value of type <code class="sourceCode">a</code>
inside a value of type <code class="sourceCode"><span class="dt">Located</span> a</code>.  Note that <code class="sourceCode"><span class="dt">Located</span></code> is not a
<code class="sourceCode"><span class="dt">Functor</span></code>, since it is not possible to change the contained type
arbitrarily: <code class="sourceCode">mapLoc</code> does not change the location, and the vector
space associated to the type <code class="sourceCode">a</code> must therefore remain the same.</p></li></ul><p>Much of the utility of having a concrete type for the <code class="sourceCode"><span class="dt">Located</span></code>
concept (rather than just passing around values paired with points)
lies in the type class instances we can give to <code class="sourceCode"><span class="dt">Located</span></code>:</p><ul><li><p><code class="sourceCode"><span class="dt">HasOrigin</span></code>: translating a <code class="sourceCode"><span class="dt">Located</span> a</code> simply translates the
associated point, leaving the value of type <code class="sourceCode">a</code> unaffected.</p></li><li><p><code class="sourceCode"><span class="dt">Transformable</span></code>: only the linear component of transformations are
applied to the wrapped value (whereas the entire transformation is
applied to the location).</p></li><li><p><code class="sourceCode"><span class="dt">Enveloped</span></code>: the envelope of a <code class="sourceCode"><span class="dt">Located</span> a</code> is the envelope of the
contained <code class="sourceCode">a</code>, translated to the stored location (and similarly for
<code class="sourceCode"><span class="dt">Traced</span></code>).</p></li><li><p>The <code class="sourceCode"><span class="dt">TrailLike</span></code> instance is also useful; see <a class="reference internal" href="#traillike">TrailLike</a>.</p></li></ul></div><div class="section" id="paths"><h3>Paths</h3><p>A <code class="sourceCode"><span class="dt">Path</span></code>, also defined in <code>Diagrams.Path</code>, is a (possibly empty)
collection of <code class="sourceCode"><span class="dt">Located</span> <span class="dt">Trail</span></code>s. Paths of a single trail can be
constructed using the same functions described in the previous
section: <code class="sourceCode">fromSegments</code>, <code class="sourceCode">fromOffsets</code>, <code class="sourceCode">fromVertices</code>, <code class="sourceCode">(<span class="fu">~~</span>)</code>, and
<code class="sourceCode">cubicSpline</code>, <code class="sourceCode">bspline</code>.</p><p><code class="sourceCode"><span class="dt">Path</span></code>s also form a <code class="sourceCode"><span class="dt">Monoid</span></code>, but the binary operation is
<em>superposition</em> (just like that of diagrams).  Paths with
multiple components can be used, for example, to create shapes with
holes:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/c6e268ec6aa2bb8c.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> ring ::</span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> ring <span class="fu">=</span> circle <span class="dv">3</span> <span class="fu"><></span> (circle <span class="dv">2</span> <span class="fu">#</span> reversePath)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> ring <span class="fu">#</span> strokeP <span class="fu">#</span> fc purple</code></pre></div></div></div><p>See the section on <a class="reference internal" href="#fill-rules">Fill rules</a> for more information.</p><p><code class="sourceCode">strokePath</code> (alias <code class="sourceCode">strokeP</code>) turns a path into a diagram, just as
<code class="sourceCode">strokeTrail</code> turns a trail into a diagram. (In fact, <code class="sourceCode">strokeTrail</code>
really works by first turning the trail into a path and then calling
<code class="sourceCode">strokePath</code> on the result.)</p><p><code class="sourceCode">explodePath</code>, similar to <code class="sourceCode">explodeTrail</code>, turns the segments of a path
into individual paths.  Since a path is a collection of trails, each
of which is a sequence of segments, <code class="sourceCode">explodePath</code> actually returns a
list of lists of paths.</p><p>For information on other path manipulation functions such as
<code class="sourceCode">pathFromTrail</code>, <code class="sourceCode">pathFromLocTrail</code>, <code class="sourceCode">pathPoints</code>, <code class="sourceCode">pathVertices</code>,
<code class="sourceCode">pathOffsets</code>, <code class="sourceCode">scalePath</code>, and <code class="sourceCode">reversePath</code>, see the Haddock
documentation in <code>Diagrams.Path</code>.</p></div><div class="section" id="vertices-vs-points"><h3>Vertices vs points</h3><p>A <em>vertex</em> of a trail or path is defined as a sharp corner, <em>i.e.</em> a
non-differentiable point.  This is (mostly) independent of the
implementation of trails and paths.  A <em>point</em>, on the other hand,
refers to the join point between two <code class="sourceCode"><span class="dt">Segment</span></code>s, which is specific to
the implementation of trails as collections of <code class="sourceCode"><span class="dt">Segment</span></code>s.</p><p>For computing vertices, there are a number of functions like
<code class="sourceCode">pathVertices</code>, <code class="sourceCode">trailVertices</code>, <code class="sourceCode">lineVertices</code>, and <code class="sourceCode">loopVertices</code>.
Each of these also has a primed variant, like <code class="sourceCode">trailVertices'</code>, which
takes an extra argument specifying a <em>tolerance</em>: in practice, where
two segments join, we need some tolerance expressing how close the
slopes of the segments must be in order to consider the join point
differentiable (and hence not a vertex).</p><p>For computing points, there are variants <code class="sourceCode">pathPoints</code>, <code class="sourceCode">trailPoints</code>,
<code class="sourceCode">linePoints</code>, and <code class="sourceCode">loopPoints</code>.  However, these are (intentionally)
not exported from <code>Diagrams.Prelude</code>.  To use them, import
<code>Diagrams.Path</code> or <code>Diagrams.Trail</code>.</p><p>In the example below, you can see that a circle has no vertices,
whereas it has four points (exposing the implementation detail that a
circle is constructed out of four Bézier segments; you should not rely
on this!).  On the other hand, a hexagon has the six vertices you
would expect.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/e56441fe16904008.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.Trail</span>  <span class="co">-- for trailPoints</span>
<span class="ot">></span>
<span class="ot">> visPoints ::</span> [<span class="dt">P2</span> <span class="dt">Double</span>] <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> visPoints pts <span class="fu">=</span> atPoints pts (repeat (circle <span class="fl">0.05</span> <span class="fu">#</span> lw none <span class="fu">#</span> fc blue))
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="fl">0.5</span>
<span class="ot">></span>  [ circle <span class="dv">1</span> <span class="ot">`beneath`</span> visPoints (trailVertices (circle <span class="dv">1</span>))
<span class="ot">></span>  , circle <span class="dv">1</span> <span class="ot">`beneath`</span> visPoints (trailPoints (circle <span class="dv">1</span>))
<span class="ot">></span>  , hexagon <span class="dv">1</span> <span class="ot">`beneath`</span> visPoints (trailVertices (hexagon <span class="dv">1</span>))
<span class="ot">></span>  ]</code></pre></div></div></div></div><div class="section" id="stroking-trails-and-paths"><h3>Stroking trails and paths</h3><p>The <code class="sourceCode">strokeTrail</code> and <code class="sourceCode">strokePath</code> functions, which turn trails and paths into
diagrams respectively, have already been mentioned; they are defined
in <code>Diagrams.TwoD.Path</code>.  Both also have primed variants,
<code class="sourceCode">strokeTrail'</code> and <code class="sourceCode">strokePath'</code>, which take a record of <code class="sourceCode"><span class="dt">StrokeOpts</span></code>.
Currently, <code class="sourceCode"><span class="dt">StrokeOpts</span></code> has two fields:</p><ul><li><p><code class="sourceCode">vertexNames</code> takes a list of lists of names, and zips each list
with a component of the path, creating point subdiagrams (using
<code class="sourceCode">pointDiagram</code>) associated with the names.  This means that the
names can be used to later refer to the locations of the path
vertices (see <a class="reference internal" href="#named-subdiagrams">Named subdiagrams</a>).  In the case of <code class="sourceCode">strokeTrail'</code>,
only the first list is used.</p><p>By default, <code class="sourceCode">vertexNames</code> is an empty list.</p></li><li><p><code class="sourceCode">queryFillRule</code> specifies the fill rule (see <a class="reference internal" href="#fill-rules">Fill rules</a>) used to
determine which points are inside the diagram, for the purposes of
its query (see <a class="reference internal" href="#using-queries">Using queries</a>).  Note that it does <em>not</em> affect
how the diagram is actually drawn; for that, use the <code class="sourceCode">fillRule</code>
function.  (This is not exactly a feature, but for various technical
reasons it is not at all obvious how to have this field actually
affect both the query and the rendering of the diagram.)</p><p>By default, <code class="sourceCode">queryFillRule</code> is set to <code class="sourceCode"><span class="dt">Winding</span></code>.</p></li></ul><p>There is also a method <code class="sourceCode">stroke</code>, which takes as input any type which
is an instance of <code class="sourceCode"><span class="dt">ToPath</span></code>, a type class with a single method:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> toPath ::</span> (<span class="dt">Metric</span> (<span class="dt">V</span> t), <span class="dt">OrderedField</span> (<span class="dt">N</span> t))
<span class="ot">></span>        <span class="ot">=></span> t <span class="ot">-></span> <span class="dt">Path</span> (<span class="dt">V</span> t) (<span class="dt">N</span> t)</code></pre></div></div><p>Calling <code class="sourceCode">stroke</code> can sometimes produce errors complaining of an
ambiguous type, which can happen if <code class="sourceCode">stroke</code> is called on something
which is itself polymorphic (<em>e.g.</em> because it can be any instance of
<code class="sourceCode"><span class="dt">TrailLike</span></code>).  The solution in this case is to use type-specific
stroking functions like <code class="sourceCode">strokePath</code>, <code class="sourceCode">strokeTrail</code>, <code class="sourceCode">strokeLocLine</code>,
<em>etc.</em>  See the <a class="reference internal" href="#topath">ToPath</a> reference for more information.</p></div><div class="section" id="offsets-of-segments-trails-and-paths"><h3>Offsets of segments, trails, and paths</h3><p>Given a segment and an offset radius \(r\) we can make an <em>offset segment</em>
that is the distance \(r\) from the original segment.  More specifically,
you can think of the offset as the curve traced by the end of a vector of
length \(r\) perpendicular to the original curve.  This vector goes on the
right of the curve for a positive radius and on the left for a negative radius.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/424e0b5f3ea6ea93.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.TwoD.Offset</span>
<span class="ot">></span>
<span class="ot">> example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="dv">1</span> <span class="fu">$</span> map f
<span class="ot">></span>         [ straight p
<span class="ot">></span>         , bézier3 (r2 (<span class="dv">0</span>,<span class="fl">0.5</span>)) (r2 (<span class="dv">1</span>,<span class="fl">0.5</span>)) p
<span class="ot">></span>         ]
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     p <span class="fu">=</span> r2 (<span class="dv">1</span>,<span class="dv">1</span>)
<span class="ot">>     f ::</span> <span class="dt">Segment</span> <span class="dt">Closed</span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span>     f s <span class="fu">=</span>  fromSegments [s]
<span class="ot">></span>         <span class="fu"><></span> offsetSegment <span class="fl">0.1</span> <span class="fl">0.2</span> s <span class="fu">#</span> strokeLocTrail <span class="fu">#</span> lc blue</code></pre></div></div></div><div class="todo bs-callout bs-callout-info"><p>Animate tracing an offset?</p></div><p>For a straight segment this will clearly be a parallel straight line with
\(r\) as the distance between the lines.  For an counter-clockwise arc of
radius \(R\) the offset will be an arc with the same center, start and end
angles, and radius \(r+R\).  Cubic segments present a problem, however.
The offset of a cubic Bézier curve could be a higher degree curve.  To
accommodate this we approximate the offset with a sequence of segments.  We
now have enough details to write the type for <code class="sourceCode">offsetSegment</code>.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> offsetSegment ::</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Segment</span> <span class="dt">Closed</span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Located</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>)</code></pre></div></div><p>The first parameter to <code class="sourceCode">offsetSegment</code> is an epsilon factor \(\epsilon\).
When the radius is multiplied by \(\epsilon\) we get the maximum allowed
distance a point on the approximate offset can differ from the true offset.
The final parameters are the radius and the segment.  The result is a located
trail.  It is located because the offset's start will be distance \(r\)
away from the segment start which is the origin.</p><p>If we can offset a segment we naturally will want to extend this to offset a
trail.  A first approach might be to simply map <code class="sourceCode">offsetSegment</code> over the
segments of a trail.  But we quickly notice that if the trail has any sharp
corners, the offset will be disconnected!</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/184161d2c8cde59a.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.TwoD.Offset</span>
<span class="ot">></span>
<span class="ot">></span> locatedTrailSegments t <span class="fu">=</span> zipWith at (trailSegments (unLoc t)) (trailVertices t)
<span class="ot">></span>
<span class="ot">></span> bindLoc f <span class="fu">=</span> join' <span class="fu">.</span> mapLoc f
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     join' x <span class="fu">=</span> <span class="kw">let</span> (p,a) <span class="fu">=</span> viewLoc x <span class="kw">in</span> translate (p <span class="fu">.-.</span> origin) a
<span class="ot">></span>
<span class="ot">> offsetTrailNaive ::</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> offsetTrailNaive e r <span class="fu">=</span> mconcat <span class="fu">.</span> map (pathFromLocTrail <span class="fu">.</span> bindLoc (offsetSegment e r))
<span class="ot">></span>                      <span class="fu">.</span> locatedTrailSegments <span class="fu">.</span> (<span class="ot">`at`</span> origin)
<span class="ot">></span>
<span class="ot">> example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> example <span class="fu">=</span> (p <span class="fu">#</span> strokeTrail <span class="fu"><></span> offsetTrailNaive <span class="fl">0.1</span> <span class="fl">0.3</span> p <span class="fu">#</span> stroke <span class="fu">#</span> lc blue)
<span class="ot">></span>         <span class="fu">#</span> lw thick
<span class="ot">></span>   <span class="kw">where</span> p <span class="fu">=</span> fromVertices <span class="fu">.</span> map p2 <span class="fu">$</span> [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="fl">0.3</span>), (<span class="dv">2</span>,<span class="dv">0</span>), (<span class="fl">2.2</span>,<span class="fl">0.3</span>)]</code></pre></div></div></div><p>First let's consider the outside corner where the adjacent offset segments do
not cross.  If we consider sweeping a perpendicular vector along the original
trail we have a problem when we get to a corner.  It is not clear what
<em>perpendicular</em> means for that point.  One solution is to take all points
distance \(r\) from the corner point.  This puts a circle around the corner
of radius \(r\).  Better is to just take the portion of that circle that
transitions from what is perpendicular at the end of the first segment to what
is perpendicular at the start of the next.  We could also choose to join together
offset segments in other sensible ways.  For the choice of join we have the
<code class="sourceCode">_offsetJoin</code> field in the <code class="sourceCode"><span class="dt">OffsetOpts</span></code> record.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/64779d102a7def4e.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.TwoD.Offset</span>
<span class="ot">></span>
<span class="ot">> example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> example <span class="fu">=</span> (p <span class="fu">#</span> strokeTrail <span class="fu"><></span> o <span class="fu">#</span> strokeLocTrail <span class="fu">#</span> lc blue)
<span class="ot">></span>         <span class="fu">#</span> lw thick
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     p <span class="fu">=</span> fromVertices <span class="fu">.</span> map p2 <span class="fu">$</span> [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="fl">0.3</span>), (<span class="dv">2</span>,<span class="dv">0</span>), (<span class="fl">2.2</span>,<span class="fl">0.3</span>)]
<span class="ot">></span>     o <span class="fu">=</span> offsetTrail' (with <span class="fu">&</span> offsetJoin <span class="fu">.~</span> <span class="dt">LineJoinRound</span>) <span class="fl">0.3</span> p</code></pre></div></div></div><p>Inside corners are handled in a way that is consistent with outside corners, but
this yields a result that is most likely undesirable.  Future versions of Diagrams
will include the ability to clip inside corners with several options for how to
do the clipping.</p><div class="todo bs-callout bs-callout-info"><p>Update after implementing clipping.</p></div><p>There are other interesting ways we can join segments.  We implement the standard
line join styles and will also in the future provide the ability to specify a custom
join.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/2229cc355f52f8cb.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.TwoD.Offset</span>
<span class="ot">></span>
<span class="ot">> example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="fl">0.5</span> <span class="fu">$</span> map f [<span class="dt">LineJoinMiter</span>, <span class="dt">LineJoinRound</span>, <span class="dt">LineJoinBevel</span>]
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     f s <span class="fu">=</span> p <span class="fu">#</span> strokeTrail <span class="fu"><></span> (offsetTrail' (with <span class="fu">&</span> offsetJoin <span class="fu">.~</span> s) <span class="fl">0.3</span> p <span class="fu">#</span> strokeLocTrail <span class="fu">#</span> lc blue)
<span class="ot">></span>     p <span class="fu">=</span> fromVertices <span class="fu">.</span> map p2 <span class="fu">$</span> [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">0</span>), (<span class="fl">0.5</span>,<span class="fl">0.7</span>)]</code></pre></div></div></div><p>The <code class="sourceCode"><span class="dt">LineJoinMiter</span></code> style in particular can use more information to dictate how
long a miter join can extend.  A sharp corner can have a miter join that is an
unbounded distance from the original corner.  Usually, however, this long join
is not desired.  Diagrams follows the practice of most graphics software and
provides a <code class="sourceCode">_offsetMiterLimit</code> field in the <code class="sourceCode"><span class="dt">OffsetOpts</span></code> record.  When the join
would be beyond the miter limit, the join is instead done with a straight line
as in the <code class="sourceCode"><span class="dt">LineJoinBevel</span></code> style.  The <code class="sourceCode"><span class="dt">OffsetOpts</span></code> record then has three
parameters:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">data</span> <span class="dt">OffsetOpts</span> <span class="fu">=</span> <span class="dt">OffsetOpts</span>
<span class="ot">></span>     {<span class="ot"> _offsetJoin       ::</span> <span class="dt">LineJoin</span>
<span class="ot">></span>     ,<span class="ot"> _offsetMiterLimit ::</span> <span class="dt">Double</span>
<span class="ot">></span>     ,<span class="ot"> _offsetEpsilon    ::</span> <span class="dt">Double</span>
<span class="ot">></span>     }</code></pre></div></div><p>And the type for <code class="sourceCode">offsetTrail'</code> is (<code class="sourceCode">offsetTrail</code> simply uses the <code class="sourceCode"><span class="dt">Default</span></code>
instance for <code class="sourceCode"><span class="dt">OffsetOpts</span></code>):</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> offsetTrail  ::</span>               <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Located</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>) <span class="ot">-></span> <span class="dt">Located</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>)
<span class="ot">> offsetTrail' ::</span> <span class="dt">OffsetOpts</span> <span class="ot">-></span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Located</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>) <span class="ot">-></span> <span class="dt">Located</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>)
<span class="ot">></span>
<span class="ot">> offsetPath  ::</span>               <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">> offsetPath' ::</span> <span class="dt">OffsetOpts</span> <span class="ot">-></span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span></code></pre></div></div><p>Notice this takes a <code class="sourceCode"><span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span></code> which means it works for both <code class="sourceCode"><span class="dt">Trail'</span> <span class="dt">Line</span> <span class="dt">V2</span> <span class="dt">Double</span></code>
and <code class="sourceCode"><span class="dt">Trail'</span> <span class="dt">Loop</span> <span class="dt">V2</span> <span class="dt">Double</span></code>.  The second parameter is the radius for the offset.  A
negative radius gives a <code class="sourceCode"><span class="dt">Line</span></code> on the right of the curve, or a <code class="sourceCode"><span class="dt">Loop</span></code> inside a
counter-clockwise <code class="sourceCode"><span class="dt">Loop</span></code>.  For <code class="sourceCode">offsetPath</code> we can simply map <code class="sourceCode">offsetTrail</code>
over the trails in the path in the most natural way.</p></div><div class="section" id="expand-segments-trails-and-paths"><h3>Expand segments, trails, and paths</h3><p>Expanding is just like the offset, but instead of producing a curve that
follows one side we follow both sides and produce a <code class="sourceCode"><span class="dt">Loop</span></code> that can be filled
representing all the area within a radius \(r\) of the original curve.</p><p>In addition to specifying how segments are joined, we now have to specify the
transition from the offset on one side of a curve to the other side of a curve.
This is given by the <code class="sourceCode"><span class="dt">LineCap</span></code>.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">data</span> <span class="dt">ExpandOpts</span> <span class="fu">=</span> <span class="dt">ExpandOpts</span>
<span class="ot">></span>     {<span class="ot"> _expandJoin       ::</span> <span class="dt">LineJoin</span>
<span class="ot">></span>     ,<span class="ot"> _expandMiterLimit ::</span> <span class="dt">Double</span>
<span class="ot">></span>     ,<span class="ot"> _expandCap        ::</span> <span class="dt">LineCap</span>
<span class="ot">></span>     ,<span class="ot"> _expandEpsilon    ::</span> <span class="dt">Double</span>
<span class="ot">></span>     }
<span class="ot">></span>
<span class="ot">> expandTrail  ::</span>               <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Located</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>) <span class="ot">-></span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">> expandTrail' ::</span> <span class="dt">ExpandOpts</span> <span class="ot">-></span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Located</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>) <span class="ot">-></span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span>
<span class="ot">> expandPath  ::</span>               <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">> expandPath' ::</span> <span class="dt">ExpandOpts</span> <span class="ot">-></span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span></code></pre></div></div><p>The functionality follows closely to the offset functions, but notice that
the result of <code class="sourceCode">expandTrail</code> is a <code class="sourceCode"><span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span></code> where <code class="sourceCode">offsetTrail</code> resulted in
a <code class="sourceCode"><span class="dt">Located</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>)</code>.  This is because an expanded <code class="sourceCode"><span class="dt">Loop</span></code> will be a pair
of loops, one inside and one outside.  To express this we need a <code class="sourceCode"><span class="dt">Path</span></code>.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/572da8817b0bdc07.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.TwoD.Offset</span>
<span class="ot">></span>
<span class="ot">> example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> example <span class="fu">=</span> (p <span class="fu">#</span> strokeTrail <span class="fu">#</span> lw veryThick <span class="fu">#</span> lc white <span class="fu"><></span> e <span class="fu">#</span> strokePath <span class="fu">#</span> lw none <span class="fu">#</span> fc blue)
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     p <span class="fu">=</span> fromVertices <span class="fu">.</span> map p2 <span class="fu">$</span> [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="fl">0.3</span>), (<span class="dv">2</span>,<span class="dv">0</span>), (<span class="fl">2.2</span>,<span class="fl">0.3</span>)]
<span class="ot">></span>     e <span class="fu">=</span> expandTrail' opts <span class="fl">0.3</span> p
<span class="ot">></span>     opts <span class="fu">=</span> with <span class="fu">&</span> expandJoin <span class="fu">.~</span> <span class="dt">LineJoinRound</span>
<span class="ot">></span>                 <span class="fu">&</span> expandCap  <span class="fu">.~</span> <span class="dt">LineCapRound</span></code></pre></div></div></div><p>As long as the expanded path is filled with the winding fill rule we
do not need to worry about having clipping for inside corners.  It
works out that the extra loop in the rounded line join will match with
the outside corner.  We currently implement all the <code class="sourceCode"><span class="dt">LineCap</span></code> styles,
and plan to support custom styles in future releases.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/ba0f6aea07d1be91.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.TwoD.Offset</span>
<span class="ot">></span>
<span class="ot">> example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="fl">0.5</span> <span class="fu">$</span> map f [<span class="dt">LineCapButt</span>, <span class="dt">LineCapRound</span>, <span class="dt">LineCapSquare</span>]
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     f s <span class="fu">=</span>  p <span class="fu">#</span> strokeTrail <span class="fu">#</span> lw veryThick <span class="fu">#</span> lc white
<span class="ot">></span>         <span class="fu"><></span> expandTrail' (opts s) <span class="fl">0.3</span> p <span class="fu">#</span> stroke <span class="fu">#</span> lw none <span class="fu">#</span> fc blue
<span class="ot">></span>     p <span class="fu">=</span> fromVertices <span class="fu">.</span> map p2 <span class="fu">$</span> [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">0</span>), (<span class="fl">0.5</span>,<span class="fl">0.7</span>)]
<span class="ot">></span>     opts s <span class="fu">=</span> with <span class="fu">&</span> expandJoin <span class="fu">.~</span> <span class="dt">LineJoinRound</span>
<span class="ot">></span>                   <span class="fu">&</span> expandCap  <span class="fu">.~</span> s</code></pre></div></div></div></div><div class="section" id="the-traillike-class traillike"><h3>The <code>TrailLike</code> class</h3><p>As you may have noticed by now, a large class of functions in the
standard library—such as <code class="sourceCode">square</code>, <code class="sourceCode">polygon</code>, <code class="sourceCode">fromVertices</code>, and so
on—generate not just diagrams, but <em>any</em> type which is an instance
of the <code class="sourceCode"><span class="dt">TrailLike</span></code> type class.</p><p>The <code class="sourceCode"><span class="dt">TrailLike</span></code> type class, defined in <code>Diagrams.TrailLike</code>, has
only a single method, <code class="sourceCode">trailLike</code>:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> trailLike ::</span> <span class="dt">Located</span> (<span class="dt">Trail</span> (<span class="dt">V</span> t) (<span class="dt">N</span> t)) <span class="ot">-></span> t</code></pre></div></div><p>That is, a trail-like thing is anything which can be constructed from
a <code class="sourceCode"><span class="dt">Located</span> <span class="dt">Trail</span></code>.</p><p>There are quite a few instances of <code class="sourceCode"><span class="dt">TrailLike</span></code>:</p><ul><li><p><code class="sourceCode"><span class="dt">Trail</span></code>: this instance simply throws away the location.</p></li><li><p><code class="sourceCode"><span class="dt">Trail'</span> <span class="dt">Line</span></code>: throw away the location, and perform <code class="sourceCode">cutLoop</code> if
necessary.  For example, <code class="sourceCode">circle <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Trail'</span> <span class="dt">Line</span> <span class="dt">V2</span> <span class="dt">Double</span></code> is an open \(360^\circ\)
circular arc.</p></li><li><p><code class="sourceCode"><span class="dt">Trail'</span> <span class="dt">Loop</span></code>: throw away the location, and perform <code class="sourceCode">glueLine</code> if
necessary.</p></li><li><p><code class="sourceCode"><span class="dt">Path</span></code>: construct a path with a single component.</p></li><li><p><code class="sourceCode"><span class="dt">Diagram</span> b</code>: as long as the backend <code class="sourceCode">b</code> knows how to render
paths, <code class="sourceCode">trailLike</code> can construct a diagram by stroking the generated
single-component path.</p></li><li><p><code class="sourceCode">[<span class="dt">Point</span> v]</code>: this instance generates the vertices of the trail.</p></li><li><p><code class="sourceCode"><span class="dt">Located</span> (<span class="dt">Trail</span> v)</code>, of course, has an instance which amounts to the
identity function.  More generally, however, <code class="sourceCode"><span class="dt">Located</span> a</code> is an
instance of <code class="sourceCode"><span class="dt">TrailLike</span></code> for <em>any</em> type <code class="sourceCode">a</code> which is also an
instance.  In particular, the resulting <code class="sourceCode"><span class="dt">Located</span> a</code> has the location
of the input <code class="sourceCode"><span class="dt">Located</span> <span class="dt">Trail</span></code>, and a value of type <code class="sourceCode">a</code> generated by
another call to <code class="sourceCode">trailLike</code>.  This is most useful for generating
values of type <code class="sourceCode"><span class="dt">Located</span> (<span class="dt">Trail'</span> <span class="dt">Line</span> v)</code> and <code class="sourceCode"><span class="dt">Located</span> (<span class="dt">Trail'</span> <span class="dt">Loop</span>
v)</code>.  For example, <code class="sourceCode">circle <span class="dv">3</span> <span class="fu">#</span> translateX <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Located</span> (<span class="dt">Trail'</span> <span class="dt">Line</span>
<span class="dt">V2</span> <span class="dt">Double</span>)</code> is an open \(360^\circ\) circular arc centered at
\((2,0)\).</p></li></ul><p>It is quite convenient to be able to use, say, <code class="sourceCode">square <span class="dv">2</span></code> as a
diagram, path, trail, list of vertices, <em>etc.</em>, whichever suits one's
needs.  Otherwise, either a long list of functions would be needed for
each primitive (like <code>square</code>, <code>squarePath</code>, <code>squareTrail</code>,
<code>squareVertices</code>, <code>squareLine</code>, <code>squareLocatedLine</code>, ... ugh!),
or else explicit conversion functions would have to be inserted when
you wanted something other than what the <code class="sourceCode">square</code> function gave you by
default.</p><p>As an (admittedly contrived) example, the following diagram defines
<code class="sourceCode">s</code> as an alias for <code class="sourceCode">square <span class="dv">2</span></code> and then uses it at four different
instances of <code class="sourceCode"><span class="dt">TrailLike</span></code>:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/f8cdb0814a4bd149.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> s <span class="fu">=</span> square <span class="dv">2</span>  <span class="co">-- a squarish thingy.</span>
<span class="ot">></span>
<span class="ot">></span> blueSquares <span class="fu">=</span> atPoints  (concat <span class="fu">.</span> pathVertices <span class="fu">$</span> s) <span class="co">{- 1 -}</span>
<span class="ot">></span>                 (replicate <span class="dv">4</span> (s <span class="co">{- 2 -}</span> <span class="fu">#</span> scale <span class="fl">0.5</span>) <span class="fu">#</span> fc blue)
<span class="ot">></span> paths       <span class="fu">=</span> lc purple <span class="fu">.</span> stroke <span class="fu">$</span> star (<span class="dt">StarSkip</span> <span class="dv">2</span>) s <span class="co">{- 3 -}</span>
<span class="ot">></span> aster       <span class="fu">=</span> center <span class="fu">.</span> lc green <span class="fu">.</span> strokeLine
<span class="ot">></span>             <span class="fu">.</span> mconcat <span class="fu">.</span> take <span class="dv">5</span> <span class="fu">.</span> iterate (rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">5</span>))
<span class="ot">></span>             <span class="fu">.</span> onLineSegments init
<span class="ot">></span>             <span class="fu">$</span> s <span class="co">{- 4 -}</span>
<span class="ot">></span> example <span class="fu">=</span> (blueSquares <span class="fu"><></span> aster <span class="fu"><></span> paths)</code></pre></div></div></div><p>Exercise: figure out which occurrence of <code class="sourceCode">s</code> has which type. (Answers
below.)</p><p>At its best, this type-directed behavior results in a "it just
works/do what I mean" experience.  However, it can occasionally be
confusing, and care is needed.  The biggest gotcha occurs when
combining a number of shapes using <code class="sourceCode">(<span class="fu"><></span>)</code> or <code class="sourceCode">mconcat</code>: diagrams,
paths, trails, and lists of vertices all have <code class="sourceCode"><span class="dt">Monoid</span></code> instances, but
they are all different, so the combination of shapes has different
semantics depending on which type is inferred.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/948a4f1af09aebe9.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> ts <span class="fu">=</span> mconcat <span class="fu">.</span> iterateN <span class="dv">3</span> (rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">9</span>)) <span class="fu">$</span> triangle <span class="dv">1</span>
<span class="ot">></span> example <span class="fu">=</span> (ts <span class="fu">|||</span> strokeP ts <span class="fu">|||</span> strokeLine ts <span class="fu">|||</span> fromVertices ts) <span class="fu">#</span> fc red</code></pre></div></div></div><p>The above example defines <code class="sourceCode">ts</code> by generating three equilateral
triangles offset by 1/9 rotations, then combining them with <code class="sourceCode">mconcat</code>.
The sneaky thing about this is that <code class="sourceCode">ts</code> can have the type of any
<code class="sourceCode"><span class="dt">TrailLike</span></code> instance, and it has completely different meanings
depending on which type is chosen.  The example uses <code class="sourceCode">ts</code> at each of
four different monoidal <code class="sourceCode"><span class="dt">TrailLike</span></code> types:</p><ul><li><p>Since <code class="sourceCode">example</code> is a diagram, the first <code class="sourceCode">ts</code>, used by itself, is
also a diagram; hence it is interpreted as three equilateral
triangle diagrams superimposed on one another with <code class="sourceCode">atop</code>.</p></li><li><p><code class="sourceCode">strokeP</code> turns <code class="sourceCode"><span class="dt">Path</span></code>s into diagrams, so the second <code class="sourceCode">ts</code> has type
<code class="sourceCode"><span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span></code>.  Hence it is interpreted as three closed triangular paths
superimposed into one three-component path, which is then stroked.</p></li><li><p><code class="sourceCode">strokeLine</code> turns <code class="sourceCode"><span class="dt">Trail'</span> <span class="dt">Line</span></code>s into diagrams, so the third
occurrence of <code class="sourceCode">ts</code> has type <code class="sourceCode"><span class="dt">Trail'</span> <span class="dt">Line</span> <span class="dt">V2</span> <span class="dt">Double</span></code>.  It is thus
interpreted as three open triangular trails sequenced end-to-end
into one long open trail.  As a line (<em>i.e.</em> an open trail), it is
not filled (in order to make it filled we could replace <code class="sourceCode">strokeLine
ts</code> with <code class="sourceCode">strokeLoop (glueLine ts)</code>).</p></li><li><p>The last occurrence of <code class="sourceCode">ts</code> is a list of points, namely, the
concatenation of the vertices of the three triangles.  Turning this
into a diagram with <code class="sourceCode">fromVertices</code> generates a single-component,
open trail that visits each of the points in turn.</p></li></ul><p>Of course, one way to avoid all this would be to give <code class="sourceCode">ts</code> a specific
type signature, if you know which type you would like it to be.  Then
using it at a different type will result in a type error, rather than
confusing semantics.</p><p>Answers to the <code class="sourceCode">square <span class="dv">2</span></code> type inference challenge:</p><ol><li><p><code class="sourceCode"><span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span></code></p></li><li><p><code class="sourceCode"><span class="dt">Diagram</span> b <span class="dt">V2</span> <span class="dt">Double</span></code></p></li><li><p><code class="sourceCode">[<span class="dt">Point</span> <span class="dt">V2</span> n]</code></p></li><li><p><code class="sourceCode"><span class="dt">Trail'</span> <span class="dt">Line</span> <span class="dt">V2</span> <span class="dt">Double</span></code></p></li></ol></div><div class="section" id="segments-and-trails-as-parametric-objects"><h3>Segments and trails as parametric objects</h3><p>Both segments and trails, semantically, can be seen as <em>parametric
functions</em>: that is, for each value of a parameter within some given
range (usually \([0,1]\)), there is a corresponding vector value
(or point, for <code class="sourceCode"><span class="dt">Located</span></code> segments and trails).  The entire collection
of such vectors or points makes up the segment or trail.</p><p>The <code>Diagrams.Parametric</code> module provides tools for working with
segments and trails as parametric functions.</p><div class="section" id="parametric"><h4>Parametric</h4><p>As explained above, parametric objects can be viewed semantically as
functions.  In particular, parametric objects of type <code class="sourceCode">p</code> can be seen
as functions of type <code class="sourceCode"><span class="dt">Scalar</span> (<span class="dt">V</span> p) <span class="ot">-></span> <span class="dt">Codomain</span> p</code>, where the type
family <code class="sourceCode"><span class="dt">Codomain</span></code> is defined in such a way as to make this true.  For
example, <code class="sourceCode"><span class="dt">Codomain</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>) <span class="fu">~</span> <span class="dt">V2</span> <span class="dt">Double</span></code>, because a trail can be thought of
as a function <code class="sourceCode"><span class="dt">Double</span> <span class="ot">-></span> <span class="dt">V2</span> <span class="dt">Double</span></code>.</p><p>The <code class="sourceCode"><span class="dt">Parametric</span></code> class defines the single method <code class="sourceCode">atParam</code> which
yields this parametric view of an object:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> atParam ::</span> <span class="dt">Parametric</span> p <span class="ot">=></span> p <span class="ot">-></span> <span class="dt">Scalar</span> (<span class="dt">V</span> p) <span class="ot">-></span> <span class="dt">Codomain</span> p</code></pre></div></div><p>(Note that it is not possible to convert in the other
direction—every function of type <code class="sourceCode"><span class="dt">Scalar</span> (<span class="dt">V</span> p) <span class="ot">-></span> <span class="dt">Codomain</span> p</code> need
not correspond to something of type <code class="sourceCode">p</code>.  For example, to convert from
a function to a trail one would need at the very least a guarantee of
continuity; segments are even more restricted.)</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/54b18096187a701d.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> spline ::</span> <span class="dt">Located</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>)
<span class="ot">></span> spline <span class="fu">=</span> cubicSpline <span class="dt">False</span> [origin, <span class="dv">0</span> <span class="fu">^&</span> <span class="dv">1</span>, <span class="dv">1</span> <span class="fu">^&</span> <span class="dv">1</span>, <span class="dv">1</span> <span class="fu">^&</span> <span class="dv">0</span>] <span class="fu">#</span> scale <span class="dv">3</span>
<span class="ot">></span> pts <span class="fu">=</span> map (spline <span class="ot">`atParam`</span>) [<span class="dv">0</span>, <span class="fl">0.1</span> <span class="fu">..</span> <span class="dv">1</span>]
<span class="ot">></span> spot <span class="fu">=</span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc blue
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> mconcat (map (place spot) pts) <span class="fu"><></span> strokeLocTrail spline</code></pre></div></div></div><p>Instances of <code class="sourceCode"><span class="dt">Parametric</span></code> include:</p><ul><li><p><code class="sourceCode"><span class="dt">Segment</span> <span class="dt">Closed</span></code>: The codomain is the type of vectors.  Note there
is no instance for <code class="sourceCode"><span class="dt">Segment</span> <span class="dt">Open</span></code>, since additional context is
needed to determine the endpoint, and hence the parametrization, of
an open segment.</p></li><li><p><code class="sourceCode"><span class="dt">FixedSegment</span></code>: The codomain is the type of points.</p></li><li><p><code class="sourceCode"><span class="dt">Trail'</span></code>: The codomain is the vector space. Note that there is no
difference between <code class="sourceCode"><span class="dt">Line</span></code> and <code class="sourceCode"><span class="dt">Loop</span></code>.</p></li><li><p><code class="sourceCode"><span class="dt">Trail</span></code>: same as the instance for <code class="sourceCode"><span class="dt">Trail'</span></code>.</p></li><li><p><code class="sourceCode"><span class="dt">Located</span> a</code>: as long as <code class="sourceCode">a</code> is also <code class="sourceCode"><span class="dt">Parametric</span></code> and the codomain of
<code class="sourceCode">a</code> is a vector space, <code class="sourceCode"><span class="dt">Located</span> a</code> is parametric with points as the
codomain.  For example, calling <code class="sourceCode">atParam</code> on a <code class="sourceCode"><span class="dt">Located</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>)</code>
returns a <code class="sourceCode"><span class="dt">P2</span> <span class="dt">Double</span></code>.</p></li></ul><p><code class="sourceCode"><span class="dt">Path</span></code>s are <em>not</em> <code class="sourceCode"><span class="dt">Parametric</span></code>, since they may have multiple trail
components and there is no canonical way to assign them a
parametrization.</p></div><div class="section" id="domainbounds"><h4>DomainBounds</h4><p>The <code class="sourceCode">domainLower</code> and <code class="sourceCode">domainUpper</code> functions simply return the lower
and upper bounds for the parameter.  By default, these will be \(0\) and
\(1\), respectively.  However, it is possible to have objects
parameterized over some interval other than \([0,1]\).</p></div><div class="section" id="endvalues"><h4>EndValues</h4><p>The <code class="sourceCode"><span class="dt">EndValues</span></code> class provides the functions <code class="sourceCode">atStart</code> and <code class="sourceCode">atEnd</code>,
which return the value at the start and end of the parameter interval,
respectively.  In other words, semantically we have <code class="sourceCode">atStart x <span class="fu">=</span> x
<span class="ot">`atParam`</span> domainLower x</code>, but certain types may have more efficient
or accurate ways of computing their start and end values (for example,
Bézier segments explicitly store their endpoints, so there is no need
to evaluate the generic parametric form).</p></div><div class="section" id="sectionable"><h4>Sectionable</h4><p>The <code class="sourceCode"><span class="dt">Sectionable</span></code> class abstracts over parametric things which can be
split into multiple sections (for example, a trail can be split into
two trails laid end-to-end).  It provides three methods:</p><ul><li><p><code class="sourceCode"><span class="ot">splitAtParam ::</span> p <span class="ot">-></span> <span class="dt">Scalar</span> (<span class="dt">V</span> p) <span class="ot">-></span> (p, p)</code> splits something of
type <code class="sourceCode">p</code> at the given parameter into two things of type <code class="sourceCode">p</code>.
The resulting values will be linearly reparameterized to cover the
same parameter space as the parent value.  For example, a segment
with parameter values in \([0,1]\) will be split into two
shorter segments which are also parameterized over \([0,1]\).</p></li><li><p><code class="sourceCode"><span class="ot">section ::</span> p <span class="ot">-></span> <span class="dt">Scalar</span> (<span class="dt">V</span> p) <span class="ot">-></span> <span class="dt">Scalar</span> (<span class="dt">V</span> p) <span class="ot">-></span> p</code> extracts the
subpart of the original lying between the given parameters, linearly
reparameterized to the same domain as the original.</p></li><li><p><code class="sourceCode"><span class="ot">reverseDomain ::</span> p <span class="ot">-></span> p</code> reverses the parameterization.  It
probably should not be in this class and is likely to move elsewhere
in future versions.</p></li></ul></div><div class="section" id="hasarclength"><h4>HasArcLength</h4><p><code class="sourceCode"><span class="dt">HasArcLength</span></code> abstracts over parametric things with a notion of arc
length.  It provides five methods:</p><ul><li><p><code class="sourceCode">arcLengthBounded</code> approximates the arc length of an object to
within a given tolerance, returning an interval which is guaranteed
to contain the true arc length.</p></li><li><p><code class="sourceCode">arcLength</code> is similar to <code class="sourceCode">arcLengthBounded</code>, but returns a single
length value instead of an interval.</p></li><li><p><code class="sourceCode">stdArcLength</code> approximates the arc length up to a standard
accuracy of \(\pm 10^{-6}\).</p></li><li><p><code class="sourceCode">arcLengthToParam</code> converts an arc length to a parameter, up to a
given tolernace</p></li><li><p><code class="sourceCode">stdArcLengthToParam</code> is like <code class="sourceCode">arcLengthToParam</code>, but using a
standard accuracy of \(\pm 10^{-6}\).</p></li></ul></div><div class="section" id="adjusting-length"><h4>Adjusting length</h4><p>Anything which is an instance of <code class="sourceCode"><span class="dt">DomainBounds</span></code>, <code class="sourceCode"><span class="dt">Sectionable</span></code>, and
<code class="sourceCode"><span class="dt">HasArcLength</span></code> can be "adjusted" using the <code class="sourceCode">adjust</code> function, which
provides a number of options for changing the length and extent.</p></div><div class="section" id="computing-tangents-and-normals"><h4>Computing tangents and normals</h4><p>The <code>Diagrams.Tangent</code> module contains functions for computing
tangent vectors and normal vectors to segments and trails, at an
arbitrary parametmer (<code class="sourceCode">tangentAtParam</code>, <code class="sourceCode">normalAtParam</code>) or at the
start or end (<code class="sourceCode">tangentAtStart</code>, <code class="sourceCode">tangentAtEnd</code>, <code class="sourceCode">normalAtStart</code>,
<code class="sourceCode">normalAtEnd</code>). (The start/end functions are provided because such
tangent and normal vectors may often be computed more quickly and
precisely than using the general formula with a parameter of 0 or 1.)</p></div></div><div class="section" id="splines"><h3>Splines</h3><p>Constructing Bézier segments by hand is tedious.  The
<code>Diagrams.CubicSpline</code> module provides two functions for creating
smooth curves given a list of points.</p><p>The <code class="sourceCode">cubicSpline</code> function, given a list of points, constructs a
smooth curved path passing through each point in turn.  The first
argument to <code class="sourceCode">cubicSpline</code> is a boolean value indicating whether the
path should be closed.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/635a9adf47223277.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> pts <span class="fu">=</span> map p2 [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">2</span>,<span class="dv">3</span>), (<span class="dv">5</span>,<span class="fu">-</span><span class="dv">2</span>), (<span class="fu">-</span><span class="dv">4</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">3</span>)]
<span class="ot">></span> spot <span class="fu">=</span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc blue <span class="fu">#</span> lw none
<span class="ot">></span> mkPath closed <span class="fu">=</span> position (zip pts (repeat spot))
<span class="ot">></span>              <span class="fu"><></span> cubicSpline closed pts
<span class="ot">></span> example <span class="fu">=</span> mkPath <span class="dt">False</span> <span class="fu">|||</span> strutX <span class="dv">2</span> <span class="fu">|||</span> mkPath <span class="dt">True</span></code></pre></div></div></div><p>For more precise control over the generation of curved paths, see the
<code>Diagrams.TwoD.Path.Metafont</code> module from
<span class="package"><a href="http://hackage.haskell.org/package/diagrams-contrib"><code>diagrams-contrib</code></a></span>, which also has <a class="reference external" href="metafont.html">its own tutorial</a>.</p><p><code>Diagrams.CubicSpline</code> also provides the <code class="sourceCode">bspline</code> function,
which creates a smooth curve (to be precise, a uniform cubic B-spline)
with the given points as control points.  The curve begins and ends at
the first and last points, but in general does not pass through the
intermediate points.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/06ce1d338b86a736.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> pts <span class="fu">=</span> map p2 (zip [<span class="dv">0</span> <span class="fu">..</span> <span class="dv">8</span>] (cycle [<span class="dv">0</span>, <span class="dv">1</span>]))
<span class="ot">></span> example <span class="fu">=</span> mconcat
<span class="ot">></span>   [ bspline pts
<span class="ot">></span>   , mconcat <span class="fu">$</span> map (place (circle <span class="fl">0.1</span> <span class="fu">#</span> fc blue <span class="fu">#</span> lw none)) pts
<span class="ot">></span>   ]</code></pre></div></div></div><p>One major difference between <code class="sourceCode">cubicSpline</code> and <code class="sourceCode">bspline</code> is that the
curves generated by <code class="sourceCode">cubicSpline</code> depend on the control points in a
global way—that is, changing one control point could alter the
entire curve—whereas with <code class="sourceCode">bspline</code>, each control point only affects
a local portion of the curve.</p></div><div class="section" id="fill-rules"><h3>Fill rules</h3><p>There are two main algorithms or "rules" used when determining which
areas to fill with color when filling the interior of a path: the
<em>winding rule</em> and the <em>even-odd rule</em>.  The rule used to draw a
path-based diagram can be set with <code class="sourceCode">fillRule</code>, defined in
<code>Diagrams.TwoD.Path</code>. For simple, non-self-intersecting paths,
determining which points are inside is quite simple, and the two
algorithms give the same results. However, for self-intersecting
paths, they usually result in different regions being filled.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/00bb795eaeaa40db.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> loopyStar <span class="fu">=</span> fc red
<span class="ot">></span>           <span class="fu">.</span> mconcat <span class="fu">.</span> map (cubicSpline <span class="dt">True</span>)
<span class="ot">></span>           <span class="fu">.</span> pathVertices
<span class="ot">></span>           <span class="fu">.</span> star (<span class="dt">StarSkip</span> <span class="dv">3</span>)
<span class="ot">></span>           <span class="fu">$</span> regPoly <span class="dv">7</span> <span class="dv">1</span>
<span class="ot">></span> example <span class="fu">=</span> loopyStar <span class="fu">#</span> fillRule <span class="dt">EvenOdd</span>
<span class="ot">></span>       <span class="fu">|||</span> strutX <span class="dv">1</span>
<span class="ot">></span>       <span class="fu">|||</span> loopyStar <span class="fu">#</span> fillRule <span class="dt">Winding</span></code></pre></div></div></div><ul><li><p>The <em>even-odd rule</em> specifies that a point is inside the path if a
straight line extended from the point off to infinity (in one
direction only) crosses the path an odd number of times.  Points
with an even number of crossings are outside the path.  This rule is
simple to implement and works perfectly well for
non-self-intersecting paths.  For self-intersecting paths, however,
it results in a pattern of alternating filled and unfilled
regions, as seen in the above example.  Sometimes this pattern is
desirable for its own sake.</p></li><li><p>The <em>winding rule</em> specifies that a point is inside the path if its
<em>winding number</em> is nonzero.  The winding number measures how many
times the path "winds" around the point, and can be intuitively
computed as follows: imagine yourself standing at the given point,
facing some point on the path.  You hold one end of an (infinitely
stretchy) rope; the other end of the rope is attached to a train
sitting at the point on the path at which you are looking.  Now the
train begins traveling around the path. As it goes, you keep hold of
your end of the rope while standing fixed in place, not turning at
all.  After the train has completed one circuit around the path,
look at the rope: if it is wrapped around you some number of times,
you are inside the path; if it is not wrapped around you, you are
outside the path.  More generally, we say that the number of times
the rope is wrapped around you (positive for one direction and
negative for the other) is the point's winding number.</p><div class="todo bs-callout bs-callout-info"><p>Draw a picture of you and the train</p></div><p>For example, if you stand outside a circle looking at a train
traveling around it, the rope will move from side to side as the
train goes around the circle, but ultimately will return to exactly
the state in which it started.  If you are standing inside the
circle, however, the rope will end up wrapped around you once.</p><p>For paths with multiple components, the winding number is simply the
sum of the winding numbers for the individual components.  This
means, for example, that "holes" can be created in shapes using a
path component traveling in the <em>opposite direction</em> from the outer
path.</p><p>This rule does a much better job with self-intersecting paths, and
it turns out to be (with some clever optimizations) not much more
difficult to implement or inefficient than the even-odd rule.</p></li></ul><p>You should be aware that queries (see <a class="reference internal" href="#using-queries">Using queries</a>) use the
winding rule by default, and are not affected by the path fill rule
attribute.  Thus, if you apply the even-odd rule to a diagram, the
query may not match in the way you expect.  For this reason, if you
want to make a shape with holes in it, it is usually better to form
the holes from paths winding in the opposite direction (using
<code class="sourceCode">reversePath</code> and the winding rule) than from the even-odd rule.  For
example, in the diagram below, the annulus on the left is formed using
the even-odd fill rule, and the one on the right with the default
winding rule and a reversed inner circle.  The dark blue points
indicate places where the associated query evaluates to true.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/f9504096907eed2a.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> points <span class="fu">=</span> [x <span class="fu">^&</span> <span class="dv">0</span> <span class="fu">|</span> x <span class="ot"><-</span> [<span class="fu">-</span><span class="fl">2.3</span>, <span class="fu">-</span><span class="fl">2.1</span> <span class="fu">..</span> <span class="fl">2.3</span>]]
<span class="ot">></span> dia1 <span class="fu">=</span> (circle <span class="dv">2</span> <span class="fu"><></span> circle <span class="dv">1</span>) <span class="fu">#</span> strokeP <span class="fu">#</span> fillRule <span class="dt">EvenOdd</span> <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">100</span>)
<span class="ot">></span> dia2 <span class="fu">=</span> (circle <span class="dv">2</span> <span class="fu"><></span> reversePath (circle <span class="dv">1</span>)) <span class="fu">#</span> strokeP <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">100</span>)
<span class="ot">></span>
<span class="ot">></span> illustrate d <span class="fu">=</span> ((d <span class="fu">#</span> fc grey) <span class="ot">`beneath`</span>) <span class="fu">.</span> mconcat <span class="fu">.</span> map drawPt <span class="fu">$</span> points
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     drawPt p <span class="fu">|</span> inquire d p <span class="fu">=</span> circle <span class="fl">0.1</span> <span class="fu">#</span> fc blue <span class="fu">#</span> moveTo p
<span class="ot">></span>              <span class="fu">|</span> otherwise   <span class="fu">=</span> circle <span class="fl">0.07</span> <span class="fu">#</span> fc lightblue <span class="fu">#</span> moveTo p
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> illustrate dia1 <span class="fu">|||</span> strutX <span class="dv">1</span> <span class="fu">|||</span> illustrate dia2</code></pre></div></div></div><p>If you do want to make a diagram whose query uses the even-odd rule,
you can use the <code class="sourceCode">strokePath'</code> function.</p></div><div class="section" id="clipping"><h3>Clipping</h3><p>With backends that support clipping, paths can be used to <em>clip</em> other
diagrams.  Only the portion of a clipped diagram falling inside the
clipping path will be drawn.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/7c7aac8e23b1d104.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> square <span class="dv">3</span>
<span class="ot">></span>         <span class="fu">#</span> fc green
<span class="ot">></span>         <span class="fu">#</span> lw veryThick
<span class="ot">></span>         <span class="fu">#</span> clipBy (square <span class="fl">3.2</span> <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">10</span>))</code></pre></div></div></div><p>Several functions are available, depending on what envelope and trace
you want the resulting diagram to have.  <code class="sourceCode">clipBy</code> uses the envelope
and trace of the original diagram.  <code class="sourceCode">clipped</code> uses the envelope and
trace of the clipping path.  <code class="sourceCode">clipTo</code> uses the intersection of the two
envelopes, and a trace which matches the displayed outline of the
diagram.  Note that in general the intersection of envelopes is larger
than the envelope of an intersection.  Diagrams does not have a
function which returns the tight envelope of the intersection.</p><p>Altering a diagram's envelope can also be accomplished using <code class="sourceCode">withEnvelope</code>
(see <a class="reference internal" href="#envelope-related-functions">Envelope-related functions</a>).  The <code class="sourceCode">rectEnvelope</code> function is also
provided for the special case of setting a diagram's envelope to some
rectangle, often used for the purpose of selecting only a part of a
diagram to be "viewed" in the final output.  It takes a point—the
lower-left corner of the viewing rectangle—and the vector from the
lower-left to upper-right corner.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/31f49540b94bcb50.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> circles <span class="fu">=</span> (c <span class="fu">|||</span> c) <span class="fu">===</span> (c <span class="fu">|||</span> c) <span class="kw">where</span> c <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> fc fuchsia
<span class="ot">></span> example <span class="fu">=</span> circles <span class="fu">#</span> center <span class="fu">#</span> rectEnvelope (p2 (<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">1</span>)) (r2 (<span class="fl">1.3</span>, <span class="fl">0.7</span>))</code></pre></div></div></div><p>Note in the above example how the actual portion of the diagram that
ends up being visible is larger than the specification given to
<code class="sourceCode">rectEnvelope</code>—this is because the aspect ratio of the requested
output image does not match the aspect ratio of the rectangle given to
<code class="sourceCode">rectEnvelope</code> (and also because of the use of <code class="sourceCode">frame</code> by the
framework which renders the user manual examples).  If the aspect
ratios matched the viewed portion would be exactly that specified in
the call to <code class="sourceCode">rectEnvelope</code>.</p></div><div class="section" id="boolean-operations-on-paths"><h3>Boolean operations on paths</h3><p>The <code>Diagrams.TwoD.Path.Boolean</code> module from
<span class="package"><a href="http://hackage.haskell.org/package/diagrams-contrib"><code>diagrams-contrib</code></a></span> contains functions for computing boolean
combinations of paths, such as union, intersection, difference, and
symmetric difference.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/842ddb95b25d4e23.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import qualified</span> <span class="dt">Diagrams.TwoD.Path.Boolean</span> <span class="kw">as</span> <span class="dt">B</span>
<span class="ot">></span>
<span class="ot">></span> thing1,<span class="ot"> thing2 ::</span> <span class="dt">Path</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span> thing1 <span class="fu">=</span> square <span class="dv">1</span>
<span class="ot">></span> thing2 <span class="fu">=</span> circle <span class="fl">0.5</span> <span class="fu">#</span> translate (<span class="fl">0.5</span> <span class="fu">^&</span> (<span class="fu">-</span><span class="fl">0.5</span>))
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="fl">0.5</span> <span class="fu">.</span> fc green <span class="fu">.</span> map strokePath <span class="fu">$</span>
<span class="ot">></span>   [ B.union        <span class="dt">Winding</span> (thing1 <span class="fu"><></span> thing2)
<span class="ot">></span>   , B.intersection <span class="dt">Winding</span> thing1     thing2
<span class="ot">></span>   , B.difference   <span class="dt">Winding</span> thing1     thing2
<span class="ot">></span>   , B.exclusion    <span class="dt">Winding</span> thing1     thing2
<span class="ot">></span>   ]</code></pre></div></div></div></div><div class="section" id="trail-and-path-implementation-details"><h3>Trail and path implementation details</h3><p>Trails are implemented using <a class="reference external" href="http://apfelmus.nfshost.com/articles/monoid-fingertree.html">finger trees</a>: in particular, lines are
finger trees of closed segments, while loops consist of a finger tree
of closed segments plus a single final open segment.</p><p>The benefit of using a finger tree (instead of just, say, a list, or
even a <code class="sourceCode"><span class="dt">Seq</span></code> structure from <code>Data.Sequence</code>) is that it allows
caching monoidal "measures" of the entire trail.  In particular, the
finger trees underlying trails cache</p><ul><li><p>the number of segments</p></li><li><p>the total arc length (up to a standard error tolerance)</p></li><li><p>the total offset (vector from start to end)</p></li><li><p>the envelope</p></li></ul><p>For more details, see the <code>Diagrams.Segment</code> and
<code>Diagrams.Trail</code> modules.</p><p>Another interesting aspect of the implementation is that upon stroking
a path to form a diagram, instead of simply putting the entire path
into a primitive, we separate out the lines and loops into two path
primitives.  This is helpful for backends because they often have to
do some active work to <em>avoid</em> filling lines, and if
<span class="package"><a href="http://hackage.haskell.org/package/diagrams-lib"><code>diagrams-lib</code></a></span> did not do this separation, they would essentially
have to end up doing it themselves.</p></div></div><div class="section" id="arrows"><h2><generated classes="sectnum">3.6   </generated>Arrows</h2><p><code>Diagrams.TwoD.Arrow</code> and <code>Diagrams.TwoD.Arrowheads</code> provide
specialized functionality for drawing arrows. Note that arrows are
drawn with scale-invariant heads and tails (see <a class="reference internal" href="#scale-invariance">Scale-invariance</a>).
Arrows can be used to connect various things including literal points,
named subdiagrams, or their traces. For more detailed information,
examples, and exercises, see the <a class="reference external" href="arrow.html">Arrows tutorial</a>.</p><p>To create arrows, one may use the functions:</p><ul><li><p><code class="sourceCode">arrowBetween</code> to connect points;</p></li><li><p><code class="sourceCode">connect</code> to connect diagrams;</p></li><li><p><code class="sourceCode">connectOutside</code> to connect points on the boundary (trace) of
diagrams (for an example, see the <a class="reference external" href="../gallery/SymmetryCube.html">symmetry cube</a> example in the
gallery);</p></li></ul><ul><li><p><code class="sourceCode">connectPerim</code> to connect points on the traces of diagrams at
particular external angles;</p></li><li><p><code class="sourceCode">arrowAt</code> to place an arrow at a point;</p></li><li><p><code class="sourceCode">arrowV</code> to create an arrow with the magnitude and direction of a given
vector.</p></li></ul><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/6c84e32fc7af14d0.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> sPt <span class="fu">=</span> <span class="fl">0.50</span> <span class="fu">^&</span> <span class="fl">0.50</span>
<span class="ot">></span> ePt <span class="fu">=</span> <span class="fl">5.2</span> <span class="fu">^&</span> <span class="fl">0.50</span>
<span class="ot">></span>
<span class="ot">></span> <span class="co">-- Connect two points.</span>
<span class="ot">></span> ex1 <span class="fu">=</span> arrowBetween sPt ePt
<span class="ot">></span>
<span class="ot">></span> d <span class="fu">=</span> octagon <span class="dv">1</span> <span class="fu">#</span> lc blue <span class="fu">#</span> lw ultraThick <span class="fu">#</span> showOrigin
<span class="ot">></span> ds <span class="fu">=</span> d <span class="fu">#</span> named <span class="st">"1"</span> <span class="fu">|||</span> strut <span class="dv">3</span> <span class="fu">|||</span> d <span class="fu">#</span> named <span class="st">"2"</span>
<span class="ot">></span>
<span class="ot">></span> <span class="co">-- Connect two diagrams and two points on their trails.</span>
<span class="ot">></span> ex23 <span class="fu">=</span> ds <span class="fu">#</span> connect <span class="st">"1"</span> <span class="st">"2"</span>
<span class="ot">></span>           <span class="fu">#</span> connectPerim <span class="st">"1"</span> <span class="st">"2"</span> (<span class="dv">15</span><span class="fu">/</span><span class="dv">16</span> <span class="fu">@@</span> turn) (<span class="dv">9</span><span class="fu">/</span><span class="dv">16</span> <span class="fu">@@</span> turn)
<span class="ot">></span>
<span class="ot">></span> <span class="co">-- Place an arrow at (0,0) the size and direction of (0,1).</span>
<span class="ot">></span> ex4 <span class="fu">=</span> arrowAt (<span class="dv">0</span> <span class="fu">^&</span> <span class="dv">0</span>) unit_Y
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> (ex1
<span class="ot">></span>           <span class="fu">===</span>
<span class="ot">></span>           strutY <span class="fl">0.5</span>
<span class="ot">></span>           <span class="fu">===</span>
<span class="ot">></span>           (ex23 <span class="fu"><></span> ex4)) <span class="fu">#</span> center</code></pre></div></div></div><p>Notice that the arrows in the above diagram all have the same dart
shaped head, no tail, and a straight shaft. All of these aspects, and
many others, can be customized using companion functions to the ones
above, whose names end with an apostrophe.  For example, the companion
to <code class="sourceCode">connect</code> is <code class="sourceCode">connect'</code>. These companion functions take an extra
<code class="sourceCode"><span class="dt">ArrowOpts</span></code> record, whose fields are:</p><ul><li><p><code class="sourceCode">arrowHead</code> and <code class="sourceCode">arrowTail</code>, to specify the shape of the head and
tail. The <code>Diagrams.TwoD.Arrowheads</code> module exports the
arrowheads <code class="sourceCode">tri</code>, <code class="sourceCode">dart</code>, <code class="sourceCode">spike</code>, <code class="sourceCode">thorn</code>, <code class="sourceCode">lineHead</code>,
and <code class="sourceCode">noHead</code>;
the default is <code class="sourceCode">dart</code>. For tails we have <code class="sourceCode">quill</code>, <code class="sourceCode">block</code>, <code class="sourceCode">lineTail</code>, and
<code class="sourceCode">noTail</code>; <code class="sourceCode">noTail</code> is the default. Addtionally, any head can be used
as a tail by appending a <code class="sourceCode"><span class="ch">'</span></code> (e.g. <code class="sourceCode">dart'</code>). There are also
functions that can be used to create custom heads and tails (see
<code>Diagrams.TwoD.Arrow</code>).</p></li><li><p><code class="sourceCode">arrowShaft</code> is any <code class="sourceCode"><span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span></code>; it will be sized automatically to
fit between the endpoints of the arrow.</p></li><li><p><code class="sourceCode">headLength</code> and <code class="sourceCode">tailLength</code> specify the size of the head and tail,
defined as the length of the head or tail plus the joint connecting
it to the shaft. Their value is of
type <code class="sourceCode"><span class="dt">Measure</span> <span class="dt">V2</span> <span class="dt">Double</span></code> (see  <a class="reference internal" href="#measurement-units">Measurement units</a>). The
default value is <code class="sourceCode">normal</code> which is a synonym for <code class="sourceCode">normalized <span class="fl">0.035</span></code>.
A traversal called <code class="sourceCode">lengths</code> sets both the <code class="sourceCode">headLength</code> and <code class="sourceCode">tailLength</code>
at the same time.</p></li><li><p><code class="sourceCode">headGap</code> and <code class="sourceCode">tailGap</code> both default to <code class="sourceCode">none</code> and are used to indicate
the amount of space between the end of the arrow and the location it
is pointing at. They are also of type <code class="sourceCode"><span class="dt">Measure</span> <span class="dt">V2</span> <span class="dt">Double</span></code>.
A traversal called <code class="sourceCode">gaps</code> is provided to set
both the <code class="sourceCode">headGap</code> and <code class="sourceCode">tailGap</code> simultaneously.</p></li><li><p><code class="sourceCode">headStyle</code>, <code class="sourceCode">tailStyle</code> and <code class="sourceCode">shaftStyle</code> are used to pass in style
functions like <code class="sourceCode">fc blue <span class="fu">.</span> opacity <span class="fl">0.75</span></code> to customize parts of the
arrow. (By default, the entire
arrow, including head and tail, is drawn using the current line
texture.)</p></li></ul><p>The Lenses <code class="sourceCode">headTexture</code>, <code class="sourceCode">tailTexture</code>, and <code class="sourceCode">shaftTexture</code> are provided
for conveniently setting the texture of a head or tail. Addtionally, the
function <code class="sourceCode">solid</code> converts a color to a texture. For example,
<code class="sourceCode">(with <span class="fu">&</span> headTexture <span class="fu">.~</span> solid blue)</code> will set the head color to blue.</p><p>The following example demonstrates the use of various <code class="sourceCode"><span class="dt">ArrowOpts</span></code>.
See <a class="reference internal" href="#named-subdiagrams">Named subdiagrams</a> for the use of names and the <code class="sourceCode">named</code>
function.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/5c3b7946c706c3a7.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> c <span class="fu">=</span> circle <span class="dv">2</span> <span class="fu">#</span> fc lightgray <span class="fu">#</span> lw none <span class="fu">#</span> showOrigin
<span class="ot">></span>
<span class="ot">></span> row1 <span class="fu">=</span> hsep <span class="dv">3</span>
<span class="ot">></span>   [ c <span class="fu">#</span> named <span class="st">"1"</span>, c <span class="fu">#</span> named <span class="st">"3"</span>
<span class="ot">></span>   , c <span class="fu">#</span> named <span class="st">"5"</span>, c <span class="fu">#</span> named <span class="st">"7"</span>
<span class="ot">></span>   ]
<span class="ot">></span> row2 <span class="fu">=</span> hsep <span class="dv">3</span>
<span class="ot">></span>   [ c <span class="fu">#</span> named <span class="st">"2"</span>, c <span class="fu">#</span> named <span class="st">"4"</span>
<span class="ot">></span>   , c <span class="fu">#</span> named <span class="st">"6"</span>, c <span class="fu">#</span> named <span class="st">"8"</span>
<span class="ot">></span>   ]
<span class="ot">></span>
<span class="ot">></span> d <span class="fu">=</span> row1 <span class="fu">===</span> strutY <span class="dv">5</span> <span class="fu">===</span> row2
<span class="ot">></span>
<span class="ot">></span> shaft1 <span class="fu">=</span> trailFromVertices (map p2 [(<span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="fl">0.2</span>), (<span class="dv">2</span>, <span class="fl">0.2</span>)])
<span class="ot">></span> shaft2 <span class="fu">=</span> cubicSpline <span class="dt">False</span> (map p2 [(<span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">1</span>, <span class="fl">0.2</span>), (<span class="dv">2</span>, <span class="fl">0.2</span>)])
<span class="ot">></span> shaft3 <span class="fu">=</span> arc xDir (<span class="dv">1</span><span class="fu">/</span><span class="dv">6</span> <span class="fu">@@</span> turn)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> d
<span class="ot">></span>    <span class="fu">#</span> connect' (with <span class="fu">&</span> arrowTail <span class="fu">.~</span> quill <span class="fu">&</span> lengths <span class="fu">.~</span> large
<span class="ot">></span>                     <span class="fu">&</span> tailTexture <span class="fu">.~</span> solid orange <span class="fu">&</span> headTexture <span class="fu">.~</span> solid orange
<span class="ot">></span>                     <span class="fu">&</span> arrowHead <span class="fu">.~</span> spike
<span class="ot">></span>                     <span class="fu">&</span> shaftStyle <span class="fu">%~</span> lw veryThick ) <span class="st">"1"</span> <span class="st">"2"</span>
<span class="ot">></span>    <span class="fu">#</span> connect' (with <span class="fu">&</span> arrowTail <span class="fu">.~</span> thorn' <span class="fu">&</span> lengths <span class="fu">.~</span> large
<span class="ot">></span>                     <span class="fu">&</span> arrowHead <span class="fu">.~</span> thorn
<span class="ot">></span>                     <span class="fu">&</span> arrowShaft <span class="fu">.~</span> shaft1 <span class="fu">&</span> shaftStyle <span class="fu">%~</span> lw veryThick ) <span class="st">"3"</span> <span class="st">"4"</span>
<span class="ot">></span>    <span class="fu">#</span> connect' (with <span class="fu">&</span> arrowTail <span class="fu">.~</span> block <span class="fu">&</span> gaps <span class="fu">.~</span> small
<span class="ot">></span>                     <span class="fu">&</span> arrowHead <span class="fu">.~</span> dart <span class="fu">&</span> headLength <span class="fu">.~</span> large
<span class="ot">></span>                     <span class="fu">&</span> arrowShaft <span class="fu">.~</span> shaft2
<span class="ot">></span>                     <span class="fu">&</span> headStyle <span class="fu">%~</span> fc blue <span class="fu">&</span> tailStyle <span class="fu">%~</span> fc blue
<span class="ot">></span>                     <span class="fu">&</span> shaftStyle <span class="fu">%~</span> lw veryThick <span class="fu">.</span> lc blue ) <span class="st">"5"</span> <span class="st">"6"</span>
<span class="ot">></span>    <span class="fu">#</span> connect' (with <span class="fu">&</span> arrowShaft <span class="fu">.~</span> shaft3
<span class="ot">></span>                     <span class="fu">&</span> arrowHead <span class="fu">.~</span> tri <span class="fu">&</span> headLength <span class="fu">.~</span> large
<span class="ot">></span>                     <span class="fu">&</span> headStyle <span class="fu">%~</span> fc red <span class="fu">.</span> opacity <span class="fl">0.5</span>
<span class="ot">></span>                     <span class="fu">&</span> shaftStyle <span class="fu">%~</span> lw veryThick <span class="fu">.</span> lc black <span class="fu">.</span> opacity <span class="fl">0.5</span> ) <span class="st">"7"</span> <span class="st">"8"</span></code></pre></div></div></div></div><div class="section" id="text"><h2><generated classes="sectnum">3.7   </generated>Text</h2><div class="warning bs-callout bs-callout-warning"><p>Note: The various backends differ substantially in their
text-handling capabilities.  For this and other reasons, there are
two ways to add text to diagrams, each with advantages.  The
method in this section is heavily dependant on backend support.
The Cairo backend has the most complete support; in particular,
this is the best approach for complex (non-Roman) scripts.  The
Rasterific backend also has good text support, via the
<span class="package"><a href="http://hackage.haskell.org/package/FontyFruity"><code>FontyFruity</code></a></span> package.  You may also want to look at the
<span class="package"><a href="http://hackage.haskell.org/package/SVGFonts"><code>SVGFonts</code></a></span> package, described in the section <a class="reference internal" href="#native-font-support">Native font
support</a> below, which converts text directly into <code class="sourceCode"><span class="dt">Path</span></code>s.</p></div><p>Text objects, defined in <code>Diagrams.TwoD.Text</code>, can be created
most simply with the <code class="sourceCode">text</code> function, which turns a <code class="sourceCode"><span class="dt">String</span></code> into a
diagram with (centered) text:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/e11b440491006888.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> text <span class="st">"Hello world!"</span> <span class="fu"><></span> rect <span class="dv">8</span> <span class="dv">1</span></code></pre></div></div></div><p>Text with different alignments can be created using <code class="sourceCode">topLeftText</code> or
<code class="sourceCode">baselineText</code> (or, more generally, <code class="sourceCode">alignedText</code>, though it is not
supported by all backends—the SVG backend in particular only
supports an approximation to <code class="sourceCode">alignedText</code>):</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/d88c78d3a11b9c69.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> pt <span class="fu">=</span> circle <span class="fl">0.1</span> <span class="fu">#</span> fc red
<span class="ot">></span>
<span class="ot">></span> t1 <span class="fu">=</span> pt <span class="fu"><></span> topLeftText         <span class="st">"top left"</span>   <span class="fu"><></span> rect <span class="dv">8</span> <span class="dv">1</span>
<span class="ot">></span> t2 <span class="fu">=</span> pt <span class="fu"><></span> baselineText        <span class="st">"baseline"</span>   <span class="fu"><></span> rect <span class="dv">8</span> <span class="dv">1</span>
<span class="ot">></span> t3 <span class="fu">=</span> pt <span class="fu"><></span> alignedText <span class="fl">0.7</span> <span class="fl">0.5</span> <span class="st">"(0.7, 0.5)"</span> <span class="fu"><></span> rect <span class="dv">8</span> <span class="dv">1</span>
<span class="ot">></span>
<span class="ot">></span> d1 <span class="fu">=/=</span> d2 <span class="fu">=</span> d1 <span class="fu">===</span> strutY <span class="dv">2</span> <span class="fu">===</span> d2
<span class="ot">></span> example <span class="fu">=</span> t1 <span class="fu">=/=</span> t2 <span class="fu">=/=</span> t3</code></pre></div></div></div><p>The most important thing to keep in mind when working with text
objects is that they <em>take up no space</em>: they have a <em>point envelope</em>
at the origin, <em>i.e.</em> for the purposes of things like <code class="sourceCode">beside</code>, they
have a width and height of zero. (Note, however, this is not the same
as having an <em>empty</em> envelope.  In particular, they still behave in an
intuitive manner when included as arguments to things like <code class="sourceCode">hcat</code>.)
If we omitted the rectangle from the above example, there would be no
output. Except: the PGF backend has the ability to create enveloped text
as does the Rasterific backend by using the <code>Diagrams.Backend.Rasterific.Text</code>
module.</p><div class="warning bs-callout bs-callout-warning"><p>Text objects take up no space!</p></div><p>The main reason for this is that computing the size of some text in a
given font is rather complicated, and <code>diagrams</code> cannot (yet) do it
natively.</p><p>Text is colored with the current fill color (see <a class="reference internal" href="#color-and-opacity">Color and
Opacity</a>).  Various other attributes of text can be set using <code class="sourceCode">font</code>,
<code class="sourceCode">fontWeight</code>, and <code class="sourceCode">fontSlant</code>.  The convenience function <code class="sourceCode">italic</code> and
<code class="sourceCode">oblique</code> are provided for setting the font slant, and for weight
there are functions <code class="sourceCode">bold</code>, <code class="sourceCode">bolder</code>, <code class="sourceCode">lighter</code>, <code class="sourceCode">thinWeight</code>,
<code class="sourceCode">ultraLight</code>, <code class="sourceCode">light</code>, <code class="sourceCode">mediumWeight</code>, <code class="sourceCode">heavy</code>, <code class="sourceCode">semiBold</code>, and
<code class="sourceCode">ultraBold</code>.  Note that many backends do not support font weights
besides <code class="sourceCode">bold</code>; the SVG backend supports all font weights.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/bd510282e8595330.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> text' s t <span class="fu">=</span> text t <span class="fu">#</span> fontSize (local s) <span class="fu"><></span> strutY (s <span class="fu">*</span> <span class="fl">1.3</span>)
<span class="ot">></span> example <span class="fu">=</span> center <span class="fu">$</span>
<span class="ot">></span>       text' <span class="dv">10</span> <span class="st">"Hello"</span> <span class="fu">#</span> italic
<span class="ot">></span>   <span class="fu">===</span> text' <span class="dv">5</span> <span class="st">"there"</span>  <span class="fu">#</span> bold <span class="fu">#</span> font <span class="st">"freeserif"</span>
<span class="ot">></span>   <span class="fu">===</span> text' <span class="dv">3</span> <span class="st">"world"</span>  <span class="fu">#</span> fc green</code></pre></div></div></div><div class="section" id="font-size"><h3>Font size</h3><p>Font size is set using the <code class="sourceCode">fontSize</code> function, and is specified by a
value of type <code class="sourceCode"><span class="dt">Measure</span> <span class="dt">V2</span> <span class="dt">Double</span></code> (see <a class="reference internal" href="#measurement-units">Measurement units</a>).</p><ul><li><p>Text with a <code class="sourceCode">local</code> font size is measured relative to its local
vector space.  Such text is transformed normally by any
transformations applied to it.  For example, in the diagram below,
<code class="sourceCode">fontSize (local <span class="dv">1</span>)</code> is specified (this is actually the default, so
it could be omitted without changing the diagram). Note how the F's
are the same size as a unit box, and scale, stretch, and rotate
along with it.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/16287c6a33ccea9f.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> eff <span class="fu">=</span> (text <span class="st">"F"</span> <span class="fu"><></span> square <span class="dv">1</span>) <span class="fu">#</span> fontSize (local <span class="dv">1</span>)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hcat
<span class="ot">></span>   [eff, eff <span class="fu">#</span> scale <span class="dv">2</span>, eff <span class="fu">#</span> scaleX <span class="dv">2</span>, eff <span class="fu">#</span> scaleY <span class="dv">2</span>, eff <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">12</span>)]</code></pre></div></div></div></li><li><p>Text whose font size is specified in any measurement other than
<code class="sourceCode">local</code> (that is, <code class="sourceCode">normalized</code>, <code class="sourceCode">global</code>, or <code class="sourceCode">output</code>) behaves
differently.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/eff9f62c766aad42.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> eff <span class="fu">=</span> (text <span class="st">"F"</span> <span class="fu"><></span> square <span class="dv">1</span>) <span class="fu">#</span> fontSize (normalized <span class="fl">0.1</span>)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hcat
<span class="ot">></span>   [eff, eff <span class="fu">#</span> scale <span class="dv">2</span>, eff <span class="fu">#</span> scaleX <span class="dv">2</span>, eff <span class="fu">#</span> scaleY <span class="dv">2</span>, eff <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">12</span>)]</code></pre></div></div></div><p>There are several things to notice about the above example
diagram, which is identical to the previous one except for the
fact that <code class="sourceCode">normalized <span class="fl">0.1</span></code> is used instead of <code class="sourceCode">local <span class="dv">1</span></code>:</p><ul><li><p>The F's are 1/10th the size of the overall diagram.  If
we added more copies of <code class="sourceCode">eff</code> to the right, but kept the
physical size of the rendered image the same, the F's would
remain the same physical size on the screen, but would get
bigger relative to the boxes (since the boxes would be smaller
in absolute terms).</p></li><li><p>The F's are all about the same size—in particular, the uniform
scaling applied to the second F has no effect, and the fourth F is
not twice as tall as the others.  Note, however, that the final F
rotates with the square as expected.  Note also that the third and
fourth F's are squished, as one would expect from a non-uniform
scaling.  The hand-wavy slogan is that non-<code class="sourceCode">local</code>-sized text is
"affected by transformations, but without changing size".</p><p>The technical specification is that applying a transformation
\(T\) to non-<code class="sourceCode">local</code>-sized text actually results in applying
the transformation \(\frac{1}{|T|} T\), where \(|T|\) denotes the
<em>average scaling factor</em> of the transformation \(T\), computed
as the square root of the positive determinant of \(T\).  This
behaves nicely: for example, the average scaling factor of <code class="sourceCode">scale
k</code> is <code class="sourceCode">k</code>, so applying a uniform scaling to non-<code class="sourceCode">local</code>-sized text
has no effect; it is also compositional, so applying <code class="sourceCode">t</code> and then
<code class="sourceCode">s</code> to some text has exactly the same effect as applying <code class="sourceCode">s <span class="fu"><></span> t</code>.
For more information, see the <code class="sourceCode">avgScale</code> function and the comments
associated with its source code.</p></li></ul></li></ul></div><div class="section" id="native-font-support"><h3>Native font support</h3><p>The <a class="reference external" href="http://hackage.haskell.org/package/SVGFonts">SVGFonts package</a> implements native text support for diagrams,
using fonts in the SVG format (note that it can be used with <em>any</em>
backend, not just the SVG backend). Among other things, it provides
its own <code class="sourceCode">svgText</code> function which can be used to convert text into a
<em>path</em> tracing the outline of the text.  Here is a simple example:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/35b59b9d1d997c8d.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import qualified</span> <span class="dt">Graphics.SVGFonts</span> <span class="kw">as</span> <span class="dt">SF</span>
<span class="ot">></span>
<span class="ot">></span> text' font h s
<span class="ot">></span>   <span class="fu">=</span> s
<span class="ot">></span>   <span class="fu">#</span> SF.svgText def { SF.textFont <span class="fu">=</span> font }
<span class="ot">></span>   <span class="fu">#</span> SF.fit_height h
<span class="ot">></span>   <span class="fu">#</span> SF.set_envelope
<span class="ot">></span>   <span class="fu">#</span> lw none
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">></span>   font <span class="ot"><-</span> lin2
<span class="ot">></span>   return <span class="fu">$</span> text' font <span class="dv">5</span> <span class="st">"Hello"</span> <span class="fu">#</span> fc blue <span class="fu">|||</span> text' font <span class="dv">3</span> <span class="st">"world"</span> <span class="fu">#</span> fc green</code></pre></div></div></div><p>For more details and examples, see the <a class="reference external" href="http://hackage.haskell.org/package/SVGFonts">Haddock documentation</a>.
Note that the API of the <code class="sourceCode"><span class="dt">SVGFonts</span></code> package changed quite a bit in
version 1.8.  For help porting your existing <code class="sourceCode"><span class="dt">SVGFonts</span></code> code to
version 1.8, see the <a class="reference external" href="https://github.com/diagrams/SVGFonts#porting-to-version-18">SVGFonts README</a>.</p></div></div><div class="section" id="images"><h2><generated classes="sectnum">3.8   </generated>Images</h2><p>The <code>Diagrams.TwoD.Image</code> module provides basic support for
including both external and embedded images in diagrams.
Support for images varies by backend.  Only the cairo
backend supports external images. The rasterific backend
supports embedded images of many formats and the SVG backend
supports embedded PNG images.</p><p>To create an embedded diagram from an image file call <code class="sourceCode">loadImageEmb</code>
to read the image from a file path using <span class="package"><a href="http://hackage.haskell.org/package/JuicyPixels"><code>JuicyPixels</code></a></span> and return
a <code class="sourceCode"><span class="dt">DImage</span> <span class="dt">Embedded</span></code>. Then use <code class="sourceCode">image</code> to convert the <code class="sourceCode"><span class="dt">DImage</span> <span class="dt">Embedded</span></code>
to a diagram. You can also create a diagram with an embedded image
by supplying a function that maps pixel coordinates to <code class="sourceCode"><span class="dt">AlphaColour</span></code>s
plus a width and a height to the <code class="sourceCode">rasterDia</code> function.  For example,
the below code uses <code class="sourceCode">rasterDia</code> to visualize the multiplication table
for the group \(U_7\) of natural numbers \(\{0, \dots, 6\}\)
under multiplication mod 7.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/9d81b55d856505a5.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Data.Colour.Palette.BrewerSet</span>
<span class="ot">></span>
<span class="ot">></span> no <span class="fu">=</span> (circle <span class="dv">1</span> <span class="fu"><></span> hrule <span class="dv">2</span> <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">8</span>))
<span class="ot">></span>    <span class="fu">#</span> lwO <span class="dv">40</span> <span class="fu">#</span> lc red <span class="fu">#</span> frame <span class="fl">0.2</span>
<span class="ot">></span> noPhoneIO <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">></span>   res <span class="ot"><-</span> loadImageEmb <span class="st">"doc/static/phone.png"</span>
<span class="ot">></span>   return <span class="fu">$</span> <span class="kw">case</span> res <span class="kw">of</span>
<span class="ot">></span>     <span class="dt">Left</span> err    <span class="ot">-></span> mempty
<span class="ot">></span>     <span class="dt">Right</span> phone <span class="ot">-></span> no <span class="fu"><></span> image phone <span class="fu">#</span> sized (dims2D <span class="fl">1.5</span> <span class="fl">1.5</span>)
<span class="ot">></span>
<span class="ot">></span> colors <span class="fu">=</span> brewerSet <span class="dt">YlGn</span> <span class="dv">7</span>
<span class="ot">></span> u7 <span class="fu">=</span> rasterDia
<span class="ot">></span>   (\x y <span class="ot">-></span> opaque (colors <span class="fu">!!</span> ((x <span class="ot">`div`</span> <span class="dv">100</span>) <span class="fu">*</span> (y <span class="ot">`div`</span> <span class="dv">100</span>) <span class="ot">`mod`</span> <span class="dv">7</span>)))
<span class="ot">></span>   <span class="dv">700</span> <span class="dv">700</span>
<span class="ot">></span>   <span class="fu">#</span> sized (dims2D <span class="dv">2</span> <span class="dv">2</span>)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">></span>   noPhone <span class="ot"><-</span> noPhoneIO
<span class="ot">></span>   return <span class="fu">$</span> noPhone <span class="fu">|||</span> strutX <span class="fl">1.5</span> <span class="fu">|||</span> u7</code></pre></div></div></div><p>The function <code class="sourceCode">loadImageExt</code> checks to make sure the file exists, uses
<span class="package"><a href="http://hackage.haskell.org/package/JuicyPixels"><code>JuicyPixels</code></a></span> to determine its size and returns a reference to
the image. On the other hand <code class="sourceCode">uncheckedImageRef</code> simply packages the
reference with a width and height to make a <code class="sourceCode"><span class="dt">DImage</span> <span class="dt">External</span></code>, without
checking to make sure the image exists.</p><p>When using <code class="sourceCode">loadImageEmb</code> and <code class="sourceCode">loadImageExt</code> you do not need to
provide the width and height of the image, as they will be calculated
by <span class="package"><a href="http://hackage.haskell.org/package/JuicyPixels"><code>JuicyPixels</code></a></span>. Otherwise you must specify both a width and
a height for each image.  In this case you might hope to be able to
specify just a width or just a height, and have the other dimension
computed so as to preserve the image's aspect ratio.  However, there
is no way for <code>diagrams</code> to query an image's aspect ratio until
rendering time, but (until such time as a constraint solver is added)
it needs to know the size of the image when composing it with other
subdiagrams.  Hence, both dimensions must be specified, and for the
purposes of positioning relative to other diagrams, the image will
be assumed to occupy a rectangle of the given dimensions.</p><p>However, note that the image's aspect ratio will be preserved: if you
specify dimensions that do not match the actual aspect ratio of the
image, blank space will be left in one of the two dimensions to
compensate.  If you wish to alter an image's aspect ratio, you can do
so by scaling nonuniformly with <code class="sourceCode">scaleX</code>, <code class="sourceCode">scaleY</code>, or something
similar.</p><p>Current backend support for images can be summarized as follows:</p><ul><li><p>Cairo: external <code>PNG</code></p></li><li><p>SVG: embedded <code>PNG</code>; also <code>PNG</code> and <code>JPG</code> via a "native"
extension (see below)</p></li><li><p>Rasterific: embedded <code>PNG</code>, <code>JPG</code>, <code>TIF</code>, <code>BMP</code> and <code>GIF</code>.</p></li><li><p>PGF: external <code>PDF</code>, <code>JPG</code> and <code>PNG</code>; embedded <code>ImageRGB8</code>.</p></li></ul><p>Besides <code class="sourceCode"><span class="dt">Embedded</span></code> and <code class="sourceCode"><span class="dt">External</span></code> images, there is a third <code class="sourceCode"><span class="dt">Native</span></code>
type which supports image formats particular to a specific backend.
For more information, see "Diagrams.TwoD.Image":mod: as well as the
documentation for individual backends.</p></div></div><div class="section" id="advanced-tools-for-diagram-creation"><h1><generated classes="sectnum">4   </generated>Advanced tools for diagram creation</h1><p>This section covers some of the more advanced tools provided by the
core and standard libraries for constructing diagrams.  Most of the
content in this section is applicable to diagrams in any vector space,
although 2D diagrams are used as illustrations.</p><div class="section" id="envelopes"><h2><generated classes="sectnum">4.1   </generated>Envelopes</h2><p>The <code class="sourceCode"><span class="dt">Envelope</span></code> type, defined in
<code>Diagrams.Core.Envelope</code>, encapsulates <em>envelopes</em>
(see <a class="reference internal" href="#envelopes-and-local-vector-spaces">envelopes and local vector spaces</a>).  Things which have an
associated envelope—including diagrams, segments, trails, and
paths—are instances of the <code class="sourceCode"><span class="dt">Enveloped</span></code> type class.</p><p>Envelopes are used implicitly when placing diagrams next to
each other (see <a class="reference internal" href="#juxtaposing-diagrams">Juxtaposing diagrams</a>) or when aligning diagrams
(see <a class="reference internal" href="#alignment">Alignment</a>).</p><div class="section" id="envelope-related-functions"><h3>Envelope-related functions</h3><ul><li><p><code class="sourceCode">strut</code> creates a diagram which produces no output but takes up the
same space as a line segment.  There are also versions specialized
to two dimensions, <code class="sourceCode">strutX</code> and <code class="sourceCode">strutY</code>.  These functions are
useful for putting space in between diagrams.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/a4d0e3670fbcaf16.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">|||</span> strutX <span class="dv">2</span> <span class="fu">|||</span> square <span class="dv">2</span></code></pre></div></div></div></li><li><p><code class="sourceCode">pad</code> increases the envelope of a diagram by a certain
factor in all directions.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/762f78a7f833e387.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> surround d <span class="fu">=</span> c <span class="fu">===</span> (c <span class="fu">|||</span> d <span class="fu">|||</span> c) <span class="fu">#</span> center <span class="fu">===</span> c
<span class="ot">></span>   <span class="kw">where</span> c <span class="fu">=</span> circle <span class="fl">0.5</span>
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> surround (square <span class="dv">1</span>) <span class="fu">|||</span> strutX <span class="dv">1</span>
<span class="ot">></span>       <span class="fu">|||</span> surround (square <span class="dv">1</span> <span class="fu">#</span> pad <span class="fl">1.2</span>)</code></pre></div></div></div><p>However, the behavior of <code class="sourceCode">pad</code> often trips up first-time users of
<code>diagrams</code>:</p><div class="warning bs-callout bs-callout-warning"><p><code class="sourceCode">pad</code> expands the envelope <em>relative to the local
origin</em>.  So if you want the padding to be equal on all sides, use
<code class="sourceCode">center</code> first or use <code class="sourceCode">frame</code> as described next.</p></div></li><li><p><code class="sourceCode">frame</code> increases the envelope in all directions by a given amount measued
in local coordinates.</p><p>For example,</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/2aa29b7ed922718d.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> surround d <span class="fu">=</span> c <span class="fu">===</span> d <span class="fu">===</span> c
<span class="ot">></span>   <span class="kw">where</span> c <span class="fu">=</span> circle <span class="fl">0.5</span>
<span class="ot">></span>
<span class="ot">></span> s <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> alignB
<span class="ot">></span>
<span class="ot">></span> p <span class="fu">=</span> s <span class="fu">#</span> pad <span class="fl">1.2</span> <span class="fu">#</span> showOrigin <span class="fu">#</span> center
<span class="ot">></span> q <span class="fu">=</span> s <span class="fu">#</span> frame <span class="fl">0.2</span> <span class="fu">#</span> showOrigin <span class="fu">#</span> center
<span class="ot">></span> r <span class="fu">=</span> s <span class="fu">#</span> center <span class="fu">#</span> showOrigin <span class="fu">#</span> pad <span class="fl">1.2</span>
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> surround p <span class="fu">|||</span> strutX <span class="fl">0.5</span>
<span class="ot">></span>       <span class="fu">|||</span> surround q <span class="fu">|||</span> strutX <span class="fl">0.5</span>
<span class="ot">></span>       <span class="fu">|||</span> surround r</code></pre></div></div></div></li><li><p>Envelopes can be "extruded"—like <code class="sourceCode">pad</code>, but only in a certain
direction—using <code class="sourceCode">extrudeEnvelope</code>.  Likewise, <code class="sourceCode">intrudeEnvelope</code>
does the same but pushes the envelope inwards.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/295f0143de72bf00.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="ot">{-# LANGUAGE ViewPatterns #-}</span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.TwoD.Vector</span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Data.Maybe</span> (fromJust)
<span class="ot">></span>
<span class="ot">> sampleEnvelope2D ::</span> <span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> sampleEnvelope2D n d <span class="fu">=</span> foldr (flip atop) (d <span class="fu">#</span> lc red) bs
<span class="ot">></span>   <span class="kw">where</span> b  <span class="fu">=</span> fromJust <span class="fu">$</span> appEnvelope (getEnvelope d)
<span class="ot">></span>         bs <span class="fu">=</span> [strokeP <span class="fu">$</span> mkLine (origin <span class="fu">.+^</span> (s <span class="fu">*^</span> v))
<span class="ot">></span>                               (<span class="dv">5</span> <span class="fu">*^</span> signorm (perp v))
<span class="ot">></span>              <span class="fu">|</span> v <span class="ot"><-</span> vs, <span class="kw">let</span> s <span class="fu">=</span> b v
<span class="ot">></span>              ]
<span class="ot">></span>         vs <span class="fu">=</span> map r2 [ (<span class="dv">2</span> <span class="fu">*</span> cos t, <span class="dv">2</span> <span class="fu">*</span> sin t)
<span class="ot">></span>                     <span class="fu">|</span> i <span class="ot"><-</span> [<span class="dv">0</span><span class="fu">..</span>n]
<span class="ot">></span>                     , <span class="kw">let</span> t <span class="fu">=</span> ((fromIntegral i) <span class="fu">*</span> <span class="fl">2.0</span> <span class="fu">*</span> pi)
<span class="ot">></span>                             <span class="fu">/</span> (fromIntegral n)
<span class="ot">></span>                     ]
<span class="ot">></span>         mkLine a v <span class="fu">=</span> moveTo a <span class="fu">$</span> fromOffsets [v] <span class="fu">#</span> center
<span class="ot">></span>
<span class="ot">></span> example
<span class="ot">></span>   <span class="fu">=</span> square <span class="dv">2</span>
<span class="ot">></span>   <span class="fu">#</span> extrudeEnvelope (<span class="dv">2</span> <span class="fu">^&</span> <span class="dv">1</span>)
<span class="ot">></span>   <span class="fu">#</span> sampleEnvelope2D <span class="dv">100</span>
<span class="ot">></span>   <span class="fu">#</span> center <span class="fu">#</span> pad <span class="fl">1.1</span></code></pre></div></div></div></li><li><p>Manually setting the envelope of a diagram can be
accomplished using <code class="sourceCode">withEnvelope</code>.  Additionally, <code class="sourceCode">phantom</code> can be
used to create a diagram which produces no output but takes up a
certain amount of space, for use in positioning other diagrams.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/cb4485e6eab52902.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> hcat [ square <span class="dv">2</span>
<span class="ot">></span>                , circle <span class="dv">1</span> <span class="fu">#</span> withEnvelope (square <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">D</span> <span class="dt">V2</span> <span class="dt">Double</span>)
<span class="ot">></span>                , square <span class="dv">2</span>
<span class="ot">></span>                , text <span class="st">"hi"</span> <span class="fu"><></span> phantom (circle <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">D</span> <span class="dt">V2</span> <span class="dt">Double</span>)
<span class="ot">></span>                ]</code></pre></div></div></div><p>In the above example, <code class="sourceCode">withEnvelope</code> is used to put more space
surrounding the circle, and <code class="sourceCode">phantom</code> is used to put space around
<code class="sourceCode">text <span class="st">"hi"</span></code> (which would otherwise take up no space).  Note that we
could equally well have written
<code class="sourceCode">text <span class="st">"hi"</span> <span class="fu">#</span> withEnvelope (circle <span class="dv">2</span> <span class="ot">::</span> <span class="dt">D</span> <span class="dt">V2</span> <span class="dt">Double</span>)</code>.  Notice that
the <code class="sourceCode"><span class="dt">D</span> <span class="dt">V2</span> <span class="dt">Double</span></code> annotations are necessary, since otherwise GHC
will not know what types to pick for <code class="sourceCode">square <span class="dv">3</span></code> and <code class="sourceCode">circle <span class="dv">2</span></code>.  See
<a class="reference internal" href="#could-not-deduce-n-a0-n-a">Could not deduce N a0 ~ N a ...</a> for more information.</p></li><li><p><code>Diagrams.TwoD.Size</code> provides functions for extracting
information from the envelopes of two-dimensional diagrams,
such as <code class="sourceCode">width</code>, <code class="sourceCode">height</code>, <code class="sourceCode">extentX</code>, <code class="sourceCode">extentY</code>, and <code class="sourceCode">center2D</code>.</p><p>It also provides functions <code class="sourceCode">sized</code> and <code class="sourceCode">sizedAs</code>, which can be used
for changing the size of an object.  For making <code class="sourceCode"><span class="dt">SizedSpec</span></code> values,
which are used as arguments to <code class="sourceCode">sized</code>, you can use functions like
<code class="sourceCode">mkWidth</code>, <code class="sourceCode">mkHeight</code>, and <code class="sourceCode">dims</code>.  For example:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/958b74f968232c46.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> shapes <span class="fu">=</span> circle <span class="dv">1</span>
<span class="ot">></span>      <span class="fu">|||</span> square <span class="dv">2</span>
<span class="ot">></span>      <span class="fu">|||</span> circle <span class="dv">1</span> <span class="fu">#</span> scaleY <span class="fl">0.3</span> <span class="fu">#</span> sizedAs (square <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">D</span> <span class="dt">V2</span> <span class="dt">Double</span>)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hrule <span class="dv">1</span> <span class="fu">#</span> sizedAs (shapes <span class="fu">#</span> scale <span class="fl">0.5</span><span class="ot"> ::</span> <span class="dt">D</span> <span class="dt">V2</span> <span class="dt">Double</span>)
<span class="ot">></span>        <span class="fu"><></span> shapes <span class="fu">#</span> centerX
<span class="ot">></span>        <span class="fu"><></span> shapes <span class="fu">#</span> sized (mkWidth <span class="dv">2</span>) <span class="fu">#</span> centerX</code></pre></div></div></div></li></ul></div><div class="section" id="the-enveloped-class"><h3>The <code>Enveloped</code> class</h3><p>All objects with an associated envelope are instances of the
<code class="sourceCode"><span class="dt">Enveloped</span></code> type class.  This includes diagrams, segments, trails, and
paths.  <code class="sourceCode"><span class="dt">Enveloped</span></code> provides a single method,</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> getEnvelope ::</span> <span class="dt">Enveloped</span> a <span class="ot">=></span> a <span class="ot">-></span> <span class="dt">Envelope</span> (<span class="dt">V</span> a) (<span class="dt">N</span> a)</code></pre></div></div><p>which returns the envelope of an object.</p><p>In addition, the list type <code class="sourceCode">[b]</code> is an instance of <code class="sourceCode"><span class="dt">Enveloped</span></code>
whenever <code class="sourceCode">b</code> is.  The envelope for a list is simply the
combination of all the individual envelopes of the list's
elements—that is, an envelope that contains all of the list
elements.  In conjunction with the <code class="sourceCode"><span class="dt">Transformable</span></code> instance for lists
(see <a class="reference internal" href="#the-transformable-class">The Transformable class</a>), this can be used to do things such
as apply an alignment to a list of diagrams <em>considered as a group</em>.
For some examples and an explanation of why this might be useful, see
<a class="reference internal" href="#delayed-composition">Delayed composition</a>.</p></div></div><div class="section" id="traces"><h2><generated classes="sectnum">4.2   </generated>Traces</h2><p>Envelopes are useful for placing diagrams relative to one another, but
they are not particularly useful for finding actual points on the
boundary of a diagram.  Finding points on the boundary of a diagram
can be useful for things like drawing lines or arrows between two
shapes, or deciding how to position another diagram relative to a
given one.</p><p>Every diagram (and, more generally, anything which is an instance of
the <code class="sourceCode"><span class="dt">Traced</span></code> type class) has a <em>trace</em>, a function which is like an
"embedded ray tracer" for finding points on the diagram boundary.  In
particular, the trace function takes a <em>ray</em> as input (represented by
a pair <code>(p,v)</code> of a base point and a vector) and returns a sorted
list of parameters <code>t</code> such that <code>p .+^ (t *^ v)</code> is a point of
intersection between the ray and the boundary of the diagram.</p><p>Normally, a trace is accessed using one of the four functions
<code class="sourceCode">rayTraceV</code>, <code class="sourceCode">rayTraceP</code>, <code class="sourceCode">maxRayTraceV</code>, and <code class="sourceCode">maxRayTraceP</code>.</p><ul><li><p><code class="sourceCode">rayTraceV</code> takes as inputs a base point <code>p</code>, a vector <code>v</code>, and
any instance of <code class="sourceCode"><span class="dt">Traced</span></code>.  It looks for intersection points with the
given object along the ray determined by <code>p</code> and <code>v</code>, and finds
the smallest <em>positive</em> scalar <code>t</code> such that <code>p .+^ (t *^ v)</code> is
a point of intersection between the ray and the boundary of the
<code class="sourceCode"><span class="dt">Traced</span></code> object.  If such a <code>t</code> exists, it returns the vector from
<code>p</code> to the intersection point, that is, <code>t *^ v</code>.  If there is
no such intersection, <code class="sourceCode">rayTraceV</code> returns <code>Nothing</code>.</p><p>Intuitively, restricting to <em>positive</em> <code>t</code>-values means that only
intersection points "in front of" the point <code>p</code> (that is, in the
direction of <code>v</code>) are considered.  This tends to be the most
intuitive behavior, and parallels the way raytracers work—think of
<code>p</code> as the location of the "camera" and <code>v</code> as the direction the
camera is pointing.  If you want to consider negative <code>t</code>-values,
see the <code class="sourceCode">traceV</code> family of functions, described below, or use
<code class="sourceCode">getTrace</code> to access the list of all intersection parameters
directly.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/6a141497d613223c.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Data.Maybe</span> (fromMaybe)
<span class="ot">></span>
<span class="ot">></span> drawV v <span class="fu">=</span> arrowAt origin v
<span class="ot">></span>
<span class="ot">></span> drawTraceV v d
<span class="ot">></span>   <span class="fu">=</span> lc green <span class="fu">$</span>
<span class="ot">></span>     fromMaybe mempty
<span class="ot">></span>       ((origin <span class="fu">~~</span>) <span class="fu"><$></span> rayTraceP origin v d)
<span class="ot">></span> illustrateTraceV v d <span class="fu">=</span> (d <span class="fu"><></span> drawV v <span class="fu"><></span> drawTraceV v d) <span class="fu">#</span> showOrigin
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="dv">1</span>
<span class="ot">></span>         <span class="fu">.</span> map (illustrateTraceV (<span class="fl">0.5</span> <span class="fu">*^</span> (r2 (<span class="dv">1</span>, <span class="dv">1</span>))))
<span class="ot">></span>         <span class="fu">$</span> [ circle <span class="dv">1</span> <span class="fu">#</span> translate (r2 (<span class="fu">-</span><span class="fl">1.5</span>, <span class="fu">-</span><span class="fl">1.5</span>))
<span class="ot">></span>           , circle <span class="dv">1</span>
<span class="ot">></span>           , circle <span class="dv">1</span> <span class="fu">#</span> translate (r2 (<span class="fl">1.5</span>, <span class="fl">1.5</span>))
<span class="ot">></span>           ]</code></pre></div></div></div></li><li><p><code class="sourceCode">rayTraceP</code> works similarly, except that it returns the point of
intersection itself, which lies on the boundary of the object, or
<code>Nothing</code> if there is no such point.</p><p>That is, <code>rayTraceP p v x == Just p'</code> if and only if <code>rayTraceV p
v x == Just (p' .-. p)</code>.</p><p>The below diagram illustrates the use of the <code class="sourceCode">rayTraceP</code> function to
identify points on the boundaries of several diagrams.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/00db2ad501a99ce1.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">></span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Data.Maybe</span> (mapMaybe)
<span class="ot">> illustrateTrace ::</span> (<span class="dt">TrailLike</span> a, <span class="dt">Traced</span> a, <span class="dt">Semigroup</span> a, <span class="dt">Monoid</span> a, <span class="dt">V</span> a <span class="fu">~</span> <span class="dt">V2</span>) <span class="ot">=></span> a <span class="ot">-></span> a
<span class="ot">></span> illustrateTrace d <span class="fu">=</span> d <span class="fu"><></span> traceLines
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     traceLines  <span class="fu">=</span> mconcat
<span class="ot">></span>                 <span class="fu">.</span> mapMaybe traceLine
<span class="ot">></span>                 <span class="fu">.</span> iterateN <span class="dv">30</span> (rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">60</span>))
<span class="ot">></span>                 <span class="fu">$</span> unitX
<span class="ot">></span>     traceLine v <span class="fu">=</span> (basePt <span class="fu">~~</span>) <span class="fu"><$></span> traceP basePt v d
<span class="ot">></span>     basePt <span class="fu">=</span> p2 (<span class="dv">0</span>, <span class="fu">-</span><span class="dv">2</span>)
<span class="ot">></span>
<span class="ot">></span> example
<span class="ot">></span>   <span class="fu">=</span> hsep <span class="dv">1</span>
<span class="ot">></span>   <span class="fu">.</span> map illustrateTrace
<span class="ot">></span>   <span class="fu">$</span> [ square <span class="dv">1</span>
<span class="ot">></span>     , circle <span class="dv">1</span>
<span class="ot">></span>     , triangle <span class="dv">1</span> <span class="fu">#</span> rotateBy (<span class="fu">-</span><span class="dv">1</span><span class="fu">/</span><span class="dv">4</span>) <span class="fu">|||</span> triangle <span class="dv">1</span> <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">4</span>)
<span class="ot">></span>     ]</code></pre></div></div></div></li><li><p><code class="sourceCode">maxRayTraceV</code> and <code class="sourceCode">maxRayTraceP</code> are similar to <code class="sourceCode">rayTraceV</code> and <code class="sourceCode">rayTraceP</code>,
respectively, except that they look for the <em>largest</em> positive
<code>t</code>-value, that is, the <em>furthest</em> intersection point in the
direction of <code>v</code>.  Again, intersection points in the opposite
direction from <code>v</code> are not considered.</p></li><li><p>The <code class="sourceCode">traceV</code>, <code class="sourceCode">traceP</code>, <code class="sourceCode">maxTraceV</code>, and <code class="sourceCode">maxTraceP</code> functions work
similarly, but are a bit more low-level: they look for the
intersection point with the <em>smallest</em> (respectively <em>largest</em>)
parameter, even if it is negative.</p></li></ul><p>For even more low-level access, the <code class="sourceCode"><span class="dt">Traced</span></code> class provides the
<code class="sourceCode">getTrace</code> method, which can be used to directly access the trace
function for an object.  Given inputs <code>p</code> and <code>v</code>, it returns a
sorted list of scalars <code>t</code> such that <code>p .+^ (t *^ v)</code> is a point
of intersection between the ray <code>(p,v)</code> and an edge of the
diagram.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/afdd64fa089c2914.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> circles ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> circles <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu"><></span> circle <span class="dv">1</span> <span class="fu">#</span> translate (<span class="dv">1</span> <span class="fu">^&</span> <span class="fl">0.6</span>)
<span class="ot">></span>
<span class="ot">> basePt ::</span> <span class="dt">P2</span> <span class="dt">Double</span>
<span class="ot">></span> basePt <span class="fu">=</span> (<span class="fu">-</span><span class="dv">3</span>) <span class="fu">^&</span> <span class="dv">0</span>
<span class="ot">></span>
<span class="ot">> tVals ::</span> [<span class="dt">Double</span>]
<span class="ot">></span> tVals <span class="fu">=</span> getSortedList <span class="fu">$</span> appTrace (getTrace circles) basePt unitX
<span class="ot">></span>
<span class="ot">> intPts ::</span> [<span class="dt">P2</span> <span class="dt">Double</span>]
<span class="ot">></span> intPts <span class="fu">=</span> map (\t <span class="ot">-></span> basePt <span class="fu">.+^</span> t <span class="fu">*^</span> unitX) tVals
<span class="ot">></span>
<span class="ot">></span> adot <span class="fu">=</span> circle <span class="fl">0.05</span> <span class="fu">#</span> fc blue <span class="fu">#</span> lw none
<span class="ot">></span> example <span class="fu">=</span> mconcat
<span class="ot">></span>   [ circles
<span class="ot">></span>   , mconcat [ adot <span class="fu">#</span> moveTo pt <span class="fu">|</span> pt <span class="ot"><-</span> intPts ]
<span class="ot">></span>   , arrowAt basePt (last intPts <span class="fu">.-.</span> basePt)
<span class="ot">></span>   ]</code></pre></div></div></div><p>Of course, diagrams are not the only instance of <code class="sourceCode"><span class="dt">Traced</span></code>.  Paths are
also <code class="sourceCode"><span class="dt">Traced</span></code>, as are trails, segments, and points.  Lists and tuples
are <code class="sourceCode"><span class="dt">Traced</span></code> as long as all of their components are—the trace for a
list or tuple is the combination of all the element traces.</p></div><div class="section" id="path-and-trail-intersections"><h2><generated classes="sectnum">4.3   </generated>Path and trail intersections</h2><p>Using the functions <code class="sourceCode">intersectPointsP</code> and <code class="sourceCode">intersectPointsT</code>, it is
possible to find the points of intersection between two paths or two
trails, respectively.  More generally, <code class="sourceCode">intersectPoints</code> can be called
on any two (potentially different) instances of <code class="sourceCode"><span class="dt">ToPath</span></code> (but this
means the arguments to <code class="sourceCode">intersectPoints</code> must have fixed types, lest
the application generate ambiguity errors).  A simple example is shown
below.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/c4f06f3cdda04dc2.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> example <span class="fu">=</span> mconcat
<span class="ot">></span>   [ mconcat cs <span class="fu">#</span> fc purple <span class="fu">#</span> lw none
<span class="ot">></span>   , strokeT    a <span class="fu">#</span> lc blue
<span class="ot">></span>   , strokeLocT b <span class="fu">#</span> lc red
<span class="ot">></span>   ]
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">>     a ::</span> <span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>
<span class="ot">></span>     a <span class="fu">=</span> fromSegments [bézier3 a1 a2 a3]
<span class="ot">>     b ::</span> <span class="dt">Located</span> (<span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>)
<span class="ot">></span>     b <span class="fu">=</span> fromSegments [bézier3 b1 b2 b3] <span class="ot">`at`</span> (<span class="dv">0</span> <span class="fu">^&</span> <span class="dv">2</span>)
<span class="ot">></span>
<span class="ot">></span>     [a1,a2,a3] <span class="fu">=</span> map r2 [(<span class="dv">2</span>, <span class="dv">4</span>), (<span class="dv">4</span>,<span class="fu">-</span><span class="dv">2</span>), (<span class="dv">6</span>, <span class="dv">2</span>)]
<span class="ot">></span>     [b1,b2,b3] <span class="fu">=</span> map r2 [(<span class="dv">2</span>,<span class="fu">-</span><span class="dv">4</span>), (<span class="dv">4</span>, <span class="dv">2</span>), (<span class="dv">6</span>,<span class="fu">-</span><span class="dv">2</span>)]
<span class="ot">></span>
<span class="ot">></span>     cs <span class="fu">=</span> map mkCircle <span class="fu">$</span> intersectPoints a b
<span class="ot">></span>
<span class="ot">></span>     mkCircle p <span class="fu">=</span> circle <span class="fl">0.05</span> <span class="fu">#</span> moveTo p
<span class="ot">></span></code></pre></div></div></div><p>Note that this feature is something of a "technology preview" in
diagrams 1.3: the API will probably change and grow in the next
release (for example, giving a way to find the <em>parameters</em> of
intersection points).</p><p>Here is a more complex example which uses <code class="sourceCode">splitAtParam</code> and <code class="sourceCode">adjust</code>
in order to leave some space around intersection points, creating an
"over/under" or "weaving" effect.  There will likely be easier ways to
accomplish this included in future versions of diagrams.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/bdfe4cd21f59ba5d.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.TwoD.Segment</span>
<span class="ot">></span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Data.List</span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Data.Function</span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Data.Ord</span>
<span class="ot">></span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Data.Foldable</span>
<span class="ot">></span>
<span class="ot">> example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> example <span class="fu">=</span> mconcat
<span class="ot">></span>   [ strokeP (foldMap toPath as) <span class="fu">#</span> lc blue
<span class="ot">></span>   , strokeP (foldMap toPath bs) <span class="fu">#</span> lc red
<span class="ot">></span>   ]
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     a <span class="fu">=</span> mkFixedSeg <span class="fu">$</span> bézier3 a1 a2 a3 <span class="ot">`at`</span> (<span class="dv">0</span> <span class="fu">^&</span> <span class="dv">0</span>)
<span class="ot">></span>     b <span class="fu">=</span> mkFixedSeg <span class="fu">$</span> bézier3 b1 b2 b3 <span class="ot">`at`</span> (<span class="dv">0</span> <span class="fu">^&</span> <span class="dv">2</span>)
<span class="ot">></span>
<span class="ot">></span>     (as,bs) <span class="fu">=</span> weave a b
<span class="ot">></span>
<span class="ot">></span>     [a1,a2,a3] <span class="fu">=</span> map r2 [(<span class="dv">2</span>, <span class="dv">4</span>), (<span class="dv">4</span>,<span class="fu">-</span><span class="dv">2</span>), (<span class="dv">6</span>, <span class="dv">2</span>)]
<span class="ot">></span>     [b1,b2,b3] <span class="fu">=</span> map r2 [(<span class="dv">2</span>,<span class="fu">-</span><span class="dv">4</span>), (<span class="dv">4</span>, <span class="dv">2</span>), (<span class="dv">6</span>,<span class="fu">-</span><span class="dv">2</span>)]
<span class="ot">></span>
<span class="ot">></span> weave a b <span class="fu">=</span> go a b [] []
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     go a b as bs <span class="fu">=</span>
<span class="ot">></span>         <span class="kw">case</span> sortBy (comparing (view _1)) <span class="fu">$</span> segmentSegment <span class="fl">0.01</span> a b <span class="kw">of</span>
<span class="ot">></span>             [] <span class="ot">-></span> (reverse (a<span class="fu">:</span>as), reverse (b<span class="fu">:</span>bs))
<span class="ot">></span>             ((ta,_,_)<span class="fu">:</span>_) <span class="ot">-></span> <span class="kw">let</span> (a',a'') <span class="fu">=</span> splitAround <span class="fl">0.1</span> ta a
<span class="ot">></span>                             <span class="kw">in</span>  go b a'' bs (a'<span class="fu">:</span>as)
<span class="ot">></span>
<span class="ot">></span> splitAround r t p <span class="fu">=</span> ( adjust a (opts <span class="fu">&</span> adjSide <span class="fu">.~</span> <span class="dt">End</span>)
<span class="ot">></span>                     , adjust b (opts <span class="fu">&</span> adjSide <span class="fu">.~</span> <span class="dt">Start</span>)
<span class="ot">></span>                     )
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     (a,b) <span class="fu">=</span> splitAtParam p t
<span class="ot">></span>     opts <span class="fu">=</span> def <span class="fu">&</span> adjMethod <span class="fu">.~</span> <span class="dt">ByAbsolute</span> (<span class="fu">-</span>r)</code></pre></div></div></div></div><div class="section" id="named-subdiagrams"><h2><generated classes="sectnum">4.4   </generated>Named subdiagrams</h2><p>Although the simple combinatorial approach to composing diagrams can
get you a long way, for many tasks it becomes necessary (or, at least,
much simpler) to have a way to refer to previously placed subdiagrams.
That is, we want a way to give a name to a particular diagram, combine
it with some others, and then later be able to refer back to the the
subdiagram by name.</p><div class="section" id="giving-names"><h3>Giving names</h3><p>Any diagram can be given a name with the <code class="sourceCode">named</code> function, as in
<code class="sourceCode">circle <span class="dv">1</span> <span class="fu">#</span> named <span class="st">"bob"</span></code>.  The name can later be used to access the
diagram it was attached to, which is useful especially when that
diagram has been incorporated as a subdiagram in a larger diagram.</p><div class="warning bs-callout bs-callout-warning"><p>The given name attaches to the local origin of the diagram
at the point that the <code class="sourceCode">named</code> function is applied.  This means that
<code class="sourceCode">named</code> does <em>not</em> commute with transformations.  Consider the
following example:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/7da0c19a9e978942.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> dia1 <span class="fu">=</span> (square <span class="dv">1</span> <span class="fu">#</span> translateY <span class="dv">4</span> <span class="fu">#</span> named <span class="st">"bob"</span> <span class="fu">|||</span> circle <span class="dv">1</span> <span class="fu">#</span> named <span class="st">"joe"</span>)
<span class="ot">></span>      <span class="fu">#</span> connect <span class="st">"bob"</span> <span class="st">"joe"</span>
<span class="ot">></span> dia2 <span class="fu">=</span> (square <span class="dv">1</span> <span class="fu">#</span> named <span class="st">"bob"</span> <span class="fu">#</span> translateY <span class="dv">4</span> <span class="fu">|||</span> circle <span class="dv">1</span> <span class="fu">#</span> named <span class="st">"joe"</span>)
<span class="ot">></span>      <span class="fu">#</span> connect <span class="st">"bob"</span> <span class="st">"joe"</span>
<span class="ot">></span>
<span class="ot">> example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> example <span class="fu">=</span> hsep <span class="dv">2</span> [dia1, dia2]</code></pre></div></div></div></div></div><div class="section" id="user-defined-names"><h3>User-defined names</h3><p>Anything can be used as a name, as long as its type is an instance of
the <code class="sourceCode"><span class="dt">IsName</span></code> type class; to be an instance of the <code class="sourceCode"><span class="dt">IsName</span></code> class, it
suffices for a type to be an instance of <code class="sourceCode"><span class="dt">Typeable</span></code>, <code class="sourceCode"><span class="dt">Eq</span></code>, <code class="sourceCode"><span class="dt">Ord</span></code>, and
<code class="sourceCode"><span class="dt">Show</span></code>.  Making a user-defined type an instance of <code class="sourceCode"><span class="dt">IsName</span></code> is as
simple as:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>
<span class="ot">></span>
<span class="ot">></span> <span class="kw">data</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Baz</span> <span class="fu">|</span> <span class="dt">Bar</span> <span class="fu">|</span> <span class="dt">Wibble</span>
<span class="ot">></span>   <span class="kw">deriving</span> (<span class="dt">Typeable</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)
<span class="ot">></span>
<span class="ot">></span> <span class="kw">instance</span> <span class="dt">IsName</span> <span class="dt">Foo</span></code></pre></div></div><p>That's it!  No method definitions are even needed for the <code class="sourceCode"><span class="dt">IsName</span></code>
instance, since <code class="sourceCode">toName</code> (the sole method of <code class="sourceCode"><span class="dt">IsName</span></code>) has a default
implementation which works just fine.</p><div class="warning bs-callout bs-callout-warning"><p>It is not recommended to use <code class="sourceCode"><span class="dt">GeneralizedNewtypeDeriving</span></code> in
conjunction with <code class="sourceCode"><span class="dt">IsName</span></code>, since in that case the underlying type
and the <code>newtype</code> will be considered equivalent when comparing
names.  For example:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">newtype</span> <span class="dt">WordN</span> <span class="fu">=</span> <span class="dt">WordN</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Eq</span>, <span class="dt">Typeable</span>, <span class="dt">IsName</span>)</code></pre></div></div><p>is unlikely to work as intended, since <code class="sourceCode">(<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</code> and <code class="sourceCode">(<span class="dt">WordN</span> <span class="dv">1</span>)</code>
will be considered equal as names.  Instead, use</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">newtype</span> <span class="dt">WordN</span> <span class="fu">=</span> <span class="dt">WordN</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Eq</span>, <span class="dt">Typeable</span>)
<span class="ot">></span> <span class="kw">instance</span> <span class="dt">IsName</span> <span class="dt">WordN</span></code></pre></div></div></div></div><div class="section" id="listing-names"><h3>Listing names</h3><p>Sometimes you may not be sure what names exist within a diagram—for
example, if you have obtained the diagram from some external module,
or are debugging your own code.  The <code class="sourceCode">names</code> function extracts a list
of all the names recorded within a diagram and the locations of any
associated subdiagrams.</p><p>When using <code class="sourceCode">names</code> you will often need to add a type annotation such
as <code class="sourceCode"><span class="dt">Diagram</span> <span class="dt">B</span></code> to its argument, as shown below—for an explanation and
more information, see <a class="reference internal" href="#could-not-deduce-n-a0-n-a">Could not deduce N a0 ~ N a ...</a>.</p><pre><code>ghci> names (circle 1 # named "joe" ||| circle 2 # named "bob" :: D V2 Double)
[("bob",[P (2.9999999999999996 ^&amp; 0.0)]),("joe",[P (0.0 ^&amp; 0.0)])]</code></pre><p>Of course, there is in fact an entire subdiagram (or subdiagrams)
associated with each name, not just a point; but subdiagrams do not
have a <code class="sourceCode"><span class="dt">Show</span></code> instance.</p></div><div class="section" id="accessing-names"><h3>Accessing names</h3><p>Once we have given names to one or more diagrams, what can we do with
them?  The simplest tool for working with names is <code class="sourceCode">lookupName</code>, which
has the type</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> lookupName ::</span> <span class="dt">IsName</span> name
<span class="ot">></span>            <span class="ot">=></span> name <span class="ot">-></span> <span class="dt">QDiagram</span> b v n m <span class="ot">-></span> <span class="dt">Maybe</span> (<span class="dt">Subdiagram</span> b v n m)</code></pre></div></div><p>This function takes a name and a diagram, and returns the first
subdiagram associated to that name if any are found, and <code class="sourceCode"><span class="dt">Nothing</span></code>
otherwise.  (Note that <code class="sourceCode">lookupName</code> is implemented in terms of the
lower-level lookup functions <code class="sourceCode">lookupSub</code> and <code class="sourceCode">subMap</code>; occasionally it
may be useful to directly access these lower-level functions, but the
hope is that you shouldn't need to.)</p><p>A more sophisticated tool is <code class="sourceCode">withName</code>, which has the (admittedly
scary-looking!) type</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> withName ::</span> (<span class="dt">IsName</span> nm, <span class="dt">Metric</span> v , <span class="dt">Semigroup</span> m, <span class="dt">OrderedField</span> n)
<span class="ot">></span>          <span class="ot">=></span> nm <span class="ot">-></span> (<span class="dt">Subdiagram</span> b v n m <span class="ot">-></span> <span class="dt">QDiagram</span> b v n m <span class="ot">-></span> <span class="dt">QDiagram</span> b v n m)
<span class="ot">></span>          <span class="ot">-></span> <span class="dt">QDiagram</span> b v n m <span class="ot">-></span> <span class="dt">QDiagram</span> b v n m</code></pre></div></div><p>Let's pick this apart a bit.  First, we see that the type <code class="sourceCode">nm</code> must be
a name type. So far so good.  The constraints on <code class="sourceCode">v</code> and <code class="sourceCode">n</code> just say
that <code class="sourceCode">v n</code> must be a metric space (a vector space with a notion of
distance), and that <code class="sourceCode">n</code> must behave sufficiently like the real
numbers.  Now, the first argument of <code class="sourceCode">withName</code> is a name. The second
argument is a function of type</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="dt">Subdiagram</span> b v n m <span class="ot">-></span> <span class="dt">QDiagram</span> b v n m <span class="ot">-></span> <span class="dt">QDiagram</span> b v n m</code></pre></div></div><p>We can see this function as a transformation on diagrams, except that
it also gets to use some extra information—namely, the <code class="sourceCode"><span class="dt">Subdiagram</span>
b v n m</code> associated with the name we pass as the first argument to
<code class="sourceCode">withName</code>.</p><p>Finally, the return type of <code class="sourceCode">withName</code> is itself a transformation of
diagrams.</p><p>So here's how <code class="sourceCode">withName</code> works.  Suppose we call it with the arguments
<code class="sourceCode">withName n f d</code>.  If some subdiagram of <code class="sourceCode">d</code> has the name <code class="sourceCode">n</code>, then
<code class="sourceCode">f</code> is called with that subdiagram as its first argument, and <code class="sourceCode">d</code>
itself as its second argument.  So we get to transform <code class="sourceCode">d</code> based on
information about the given subdiagram, and its context within the
parent diagram <code class="sourceCode">d</code> (for example, its location, attributes applied to
it, and so on).  And what if there is no subdiagram named <code class="sourceCode">n</code> in <code class="sourceCode">d</code>?
In that case <code class="sourceCode">f</code> is ignored, and <code class="sourceCode">d</code> is returned unmodified.</p><p>Here's a simple example making use of names to draw a line connecting
the centers of two subdiagrams (though for this particular task it is
probably more convenient to use the provided <code class="sourceCode">connect</code>
function):</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/3dbc3baa9901381a.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">data</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Baz</span> <span class="fu">|</span> <span class="dt">Bar</span> <span class="fu">|</span> <span class="dt">Wibble</span>
<span class="ot">></span>   <span class="kw">deriving</span> (<span class="dt">Typeable</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)
<span class="ot">></span>
<span class="ot">></span> <span class="kw">instance</span> <span class="dt">IsName</span> <span class="dt">Foo</span>
<span class="ot">></span>
<span class="ot">></span> attach n1 n2
<span class="ot">></span>   <span class="fu">=</span> withName n1 <span class="fu">$</span> \b1 <span class="ot">-></span>
<span class="ot">></span>     withName n2 <span class="fu">$</span> \b2 <span class="ot">-></span>
<span class="ot">></span>       atop ((location b1 <span class="fu">~~</span> location b2) <span class="fu">#</span> lc red)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> (square <span class="dv">3</span> <span class="fu">#</span> named <span class="dt">Baz</span> <span class="fu">|||</span> circle <span class="fl">2.3</span> <span class="fu">#</span> named <span class="dt">Bar</span>)
<span class="ot">></span>         <span class="fu">#</span> attach <span class="dt">Baz</span> <span class="dt">Bar</span></code></pre></div></div></div><p>The <code class="sourceCode">attach</code> function takes two names and returns a <em>function</em> from
diagrams to diagrams, which adds a red line connecting the locations
denoted by the two names.  Note how the two calls to <code class="sourceCode">withName</code> are
chained, and how we have written the second arguments to <code class="sourceCode">withName</code>
using lambda expressions (this is a common style).  Finally, we draw a
line between the two points (using the <code class="sourceCode">location</code> function to access
the locations of the subdiagrams within the parent diagram), give it a
style, and specify that it should be layered on top of the diagram
given as the third argument to <code class="sourceCode">attach</code>.</p><p>We then draw a square and a circle, give them names, and use <code class="sourceCode">attach</code>
to draw a line between their centers.  Of course, in this example, it
would not be too hard to manually compute the endpoints of the line
(this is left as an exercise for the reader); but in more complex
examples such manual calculation can be quite out of the question.</p><p><code class="sourceCode">withName</code> also has two other useful variants:</p><ul><li><p><code class="sourceCode">withNameAll</code> takes a single name and makes available a list of
<em>all</em> subdiagrams associated with that name.
(<code class="sourceCode">withName</code>, by contrast, returns only the most recent.)  This is
useful when you want to work with a collection of named subdiagrams all
at once.</p></li><li><p><code class="sourceCode">withNames</code> takes a list of names, and makes available a list of the
most recent subdiagrams associated with each.  Instead of the
two calls to <code class="sourceCode">withName</code> in the example above, we could have written</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> attach n1 n2
<span class="ot">></span>   <span class="fu">=</span> withNames [n1,n2] <span class="fu">$</span> \[b1,b2] <span class="ot">-></span>
<span class="ot">></span>       <span class="fu">...</span></code></pre></div></div></li></ul><p>There is also a function <code class="sourceCode">place</code>, which is simply a flipped version of
<code class="sourceCode">moveTo</code>, provided for convenience since it can be useful in
conjunction with <code class="sourceCode">withName</code>.  For example, to draw a square at the
location of a given name, one can write something like</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> withName n <span class="fu">$</span> atop <span class="fu">.</span> place (square <span class="dv">1</span>) <span class="fu">.</span> location</code></pre></div></div><p>This computes the location of the name <code class="sourceCode">n</code>, positions a square at that
location, and then superimposes the positioned square atop the diagram
containing <code class="sourceCode">n</code>.</p></div><div class="section" id="subdiagrams"><h3>Subdiagrams</h3><p>So far, the examples we have seen have only made use of the local
origin associated with each subdiagram, accessed using the <code class="sourceCode">location</code>
function.  However, subdiagrams are full-fledged diagrams, so there is
much more information to be taken advantage of.  For example, the
below code draws a tree of circles, using subdiagram traces (see
<a class="reference internal" href="#traces">Traces</a>) to connect the <em>bottom</em> edge of the parent circle to the
<em>top</em> edge of each child circle, instead of connecting their centers.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/0df64cad7e8f084d.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Data.Maybe</span> (fromMaybe)
<span class="ot">></span>
<span class="ot">></span> root   <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> named <span class="st">"root"</span>
<span class="ot">></span> leaves <span class="fu">=</span> center
<span class="ot">></span>        <span class="fu">.</span> hsep <span class="fl">0.5</span>
<span class="ot">></span>        <span class="fu">$</span> map (\c <span class="ot">-></span> circle <span class="dv">1</span> <span class="fu">#</span> named c) <span class="st">"abcde"</span>
<span class="ot">></span>
<span class="ot">></span> parentToChild child
<span class="ot">></span>   <span class="fu">=</span> withName <span class="st">"root"</span> <span class="fu">$</span> \rb <span class="ot">-></span>
<span class="ot">></span>     withName child  <span class="fu">$</span> \cb <span class="ot">-></span>
<span class="ot">></span>       atop (boundaryFrom rb unit_Y <span class="fu">~~</span> boundaryFrom cb unitY)
<span class="ot">></span>
<span class="ot">></span> nodes  <span class="fu">=</span> root <span class="fu">===</span> strutY <span class="dv">2</span> <span class="fu">===</span> leaves
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> nodes <span class="fu">#</span> applyAll (map parentToChild <span class="st">"abcde"</span>)</code></pre></div></div></div><p>Note the use of the <code class="sourceCode">boundaryFrom</code> function, which uses the traces of
the subdiagrams to compute suitable points on their boundary.</p></div><div class="section" id="qualifying-names"><h3>Qualifying names</h3><p>To avoid name clashes, sometimes it is useful to be able to <em>qualify</em>
existing names with one or more prefixes.  Names actually consist of a
<em>sequence</em> of atomic names, much like Haskell module names consist of
a sequence of identifiers like <code>Diagrams.TwoD.Shapes</code>.</p><p>To qualify an existing name, use the <code class="sourceCode">(<span class="fu">.>></span>)</code> operator, which can be
applied not only to individual names but also to an entire diagram
(resulting in all names in the diagram being qualified).  To construct
a qualified name explicitly, separate the components with <code class="sourceCode">(<span class="fu">.></span>)</code>.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/9c5a5e7690df49e3.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">data</span> <span class="dt">Corner</span> <span class="fu">=</span> <span class="dt">NW</span> <span class="fu">|</span> <span class="dt">NE</span> <span class="fu">|</span> <span class="dt">SW</span> <span class="fu">|</span> <span class="dt">SE</span>
<span class="ot">></span>   <span class="kw">deriving</span> (<span class="dt">Typeable</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)
<span class="ot">></span> <span class="kw">instance</span> <span class="dt">IsName</span> <span class="dt">Corner</span>
<span class="ot">></span>
<span class="ot">></span> attach n1 n2
<span class="ot">></span>   <span class="fu">=</span> withName n1 <span class="fu">$</span> \b1 <span class="ot">-></span>
<span class="ot">></span>     withName n2 <span class="fu">$</span> \b2 <span class="ot">-></span>
<span class="ot">></span>       atop ((location b1 <span class="fu">~~</span> location b2) <span class="fu">#</span> lc red <span class="fu">#</span> lw thick)
<span class="ot">></span>
<span class="ot">></span> squares <span class="fu">=</span>  (s <span class="fu">#</span> named <span class="dt">NW</span> <span class="fu">|||</span> s <span class="fu">#</span> named <span class="dt">NE</span>)
<span class="ot">></span>        <span class="fu">===</span> (s <span class="fu">#</span> named <span class="dt">SW</span> <span class="fu">|||</span> s <span class="fu">#</span> named <span class="dt">SE</span>)
<span class="ot">></span>   <span class="kw">where</span> s <span class="fu">=</span> square <span class="dv">1</span>
<span class="ot">></span>
<span class="ot">></span> d <span class="fu">=</span> hsep <span class="fl">0.5</span> (zipWith (<span class="fu">.>></span>) [<span class="dv">0</span><span class="ot">::</span><span class="dt">Int</span> <span class="fu">..</span>] (replicate <span class="dv">5</span> squares))
<span class="ot">></span>
<span class="ot">> pairs ::</span> [(<span class="dt">Name</span>, <span class="dt">Name</span>)]
<span class="ot">></span> pairs <span class="fu">=</span> [ ((<span class="dv">0</span><span class="ot">::</span><span class="dt">Int</span>) <span class="fu">.></span> <span class="dt">NE</span>, (<span class="dv">2</span><span class="ot">::</span><span class="dt">Int</span>) <span class="fu">.></span> <span class="dt">SW</span>)
<span class="ot">></span>         , ((<span class="dv">1</span><span class="ot">::</span><span class="dt">Int</span>) <span class="fu">.></span> <span class="dt">SE</span>, (<span class="dv">4</span><span class="ot">::</span><span class="dt">Int</span>) <span class="fu">.></span> <span class="dt">NE</span>)
<span class="ot">></span>         , ((<span class="dv">3</span><span class="ot">::</span><span class="dt">Int</span>) <span class="fu">.></span> <span class="dt">NW</span>, (<span class="dv">3</span><span class="ot">::</span><span class="dt">Int</span>) <span class="fu">.></span> <span class="dt">SE</span>)
<span class="ot">></span>         , ((<span class="dv">0</span><span class="ot">::</span><span class="dt">Int</span>) <span class="fu">.></span> <span class="dt">SE</span>, (<span class="dv">1</span><span class="ot">::</span><span class="dt">Int</span>) <span class="fu">.></span> <span class="dt">NW</span>)
<span class="ot">></span>         ]
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> d <span class="fu">#</span> applyAll (map (uncurry attach) pairs)</code></pre></div></div></div><p>We create a four-paned square with a name for each of its panes; we
then make five copies of it.  At this point, each of the copies has
the same names, so there would be no way to refer to any of them
individually.  The solution is to qualify each of the copies
differently; here we have used a numeric prefix.</p><p>(As an aside, note how we had to use a type annotation on the integers
that we used as names; numeric literals are polymorphic and <code class="sourceCode">(<span class="fu">.>></span>)</code>
needs to know what type of atomic name we are using. Without the type
annotations, we would get an <a class="reference internal" href="#could-not-deduce-isname-a0">error about an "ambiguous type variable"</a>.
It's a bit annoying to insert all these annotations, of course;
another option would be to use monomorphic constants like <code class="sourceCode"><span class="dt">String</span></code>s
or <code class="sourceCode"><span class="dt">Char</span></code>s instead, or to create our own data type with a short
constructor name that wraps an <code class="sourceCode"><span class="dt">Int</span></code>.)</p><p>Note how we also made use of <code class="sourceCode">applyAll</code>, which takes a list of
functions as an argument and composes them into one; that is,
<code class="sourceCode">applyAll [f, g, h] <span class="fu">===</span> f <span class="fu">.</span> g <span class="fu">.</span> h</code>.</p></div><div class="section" id="localizing-names"><h3>Localizing names</h3><p>In some situations, giving globally unique names to everything (even
with the qualification mechanism) is a big pain.  The <code class="sourceCode">localize</code>
function "localizes" the scope of names: any names within a call of
<code class="sourceCode">localize</code> are not visible outside the call.</p><div class="todo bs-callout bs-callout-info"><p>Needs an example.</p></div></div></div><div class="section" id="using-queries"><h2><generated classes="sectnum">4.5   </generated>Using queries</h2><p>Every diagram has an associated <em>query</em>, which assigns a value to
every point in the diagram.  These values must be taken from some
monoid (see <a class="reference internal" href="#semigroups-and-monoids">Semigroups and monoids</a>).  Combining two diagrams
results in their queries being combined pointwise.</p><div class="section" id="the-default-query"><h3>The default query</h3><p>The default query assigns a value of type <code class="sourceCode"><span class="dt">Any</span></code> to each point in a
diagram.  In fact, <code class="sourceCode"><span class="dt">Diagram</span> b v</code> is really a synonym for
<code class="sourceCode"><span class="dt">QDiagram</span> b v <span class="dt">Any</span></code>.  <code class="sourceCode"><span class="dt">Any</span></code> represents the monoid on the booleans
with logical or as the binary operation (and hence <code class="sourceCode"><span class="dt">False</span></code> as the
identity).  The default query simply indicates which points are
"inside" the diagram and which are "outside".</p><div class="warning bs-callout bs-callout-warning"><p>The default <code class="sourceCode"><span class="dt">Any</span></code> query and the envelope are quite
different, and may give unrelated results.  The envelope
is an approximation used to be able to place diagrams next to one
another; the <code class="sourceCode"><span class="dt">Any</span></code> query is a more accurate record of which points
are enclosed by the diagram.  (Using the query in order to position
diagrams next to each other more accurately/snugly would be,
generally speaking, computationally infeasible—though it may be
appropriate in some situations.)</p></div><p>The following example queries an ellipse (using the <code class="sourceCode">inquire</code> function
to test it at a set of particular points), coloring points inside
the ellipse red and points outside it blue.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/d6178d7a455d3af5.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">System.Random</span> (randomRIO)
<span class="ot">></span> <span class="kw">import </span><span class="dt">Control.Monad</span> (replicateM)
<span class="ot">></span>
<span class="ot">> c ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> c <span class="fu">=</span> circle <span class="dv">5</span> <span class="fu">#</span> scaleX <span class="dv">2</span> <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">14</span>)
<span class="ot">></span>
<span class="ot">></span> mkPoint p <span class="fu">=</span> (p, circle <span class="fl">0.3</span>
<span class="ot">></span>                 <span class="fu">#</span> lw none
<span class="ot">></span>                 <span class="fu">#</span> fc (<span class="kw">case</span> inquire c p <span class="kw">of</span>
<span class="ot">></span>                         <span class="dt">True</span>  <span class="ot">-></span> red
<span class="ot">></span>                         <span class="dt">False</span> <span class="ot">-></span> blue
<span class="ot">></span>                      )
<span class="ot">></span>             )
<span class="ot">></span>
<span class="ot">> rand10 ::</span> <span class="dt">IO</span> <span class="dt">Double</span>
<span class="ot">></span> rand10 <span class="fu">=</span> randomRIO (<span class="fu">-</span><span class="dv">10</span>,<span class="dv">10</span>)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">></span>   points <span class="ot"><-</span> replicateM <span class="dv">20</span> (mkP2 <span class="fu"><$></span> rand10 <span class="fu"><*></span> rand10)
<span class="ot">></span>   return <span class="fu">$</span> c <span class="fu"><></span> position (map mkPoint points)</code></pre></div></div></div></div><div class="section" id="using-other-monoids"><h3>Using other monoids</h3><p>You can use monoids besides <code class="sourceCode"><span class="dt">Any</span></code> to record other information about a
diagram.  For example, the diagram below uses the <code class="sourceCode"><span class="dt">Sum</span></code> monoid to draw
dots whose size is determined by the number of overlapping shapes at a
given point.  Note the use of the <code class="sourceCode">value</code> function to switch from the
default <code class="sourceCode"><span class="dt">Any</span></code> to a different monoid: <code class="sourceCode">value v</code> replaces <code class="sourceCode"><span class="dt">Any</span> <span class="dt">True</span></code> with <code class="sourceCode">v</code>
and <code class="sourceCode"><span class="dt">Any</span> <span class="dt">False</span></code> with <code class="sourceCode">mempty</code>.  Here we use the <code class="sourceCode">sample</code> function to
retrieve the monoidal value associated with a particular point. (The
<code class="sourceCode">inquire</code> function from the previous example is just <code class="sourceCode">sample</code>
specialized to the <code class="sourceCode"><span class="dt">Any</span></code> monoid.)</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/d0b13fb746a9dc00.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">System.Random</span> (randomRIO)
<span class="ot">></span> <span class="kw">import </span><span class="dt">Control.Monad</span> (replicateM)
<span class="ot">></span>
<span class="ot">></span> withCount <span class="fu">=</span> (<span class="fu">#</span> value (<span class="dt">Sum</span> <span class="dv">1</span>))
<span class="ot">></span>
<span class="ot">> c ::</span> <span class="dt">QDiagram</span> <span class="dt">B</span> <span class="dt">V2</span> <span class="dt">Double</span> (<span class="dt">Sum</span> <span class="dt">Int</span>)
<span class="ot">></span> c <span class="fu">=</span> (   circle <span class="dv">5</span> <span class="fu">#</span> scaleX <span class="dv">2</span> <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">14</span>) <span class="fu">#</span> withCount
<span class="ot">></span>      <span class="fu"><></span> circle <span class="dv">2</span> <span class="fu">#</span> scaleX <span class="dv">5</span> <span class="fu">#</span> rotateBy (<span class="fu">-</span><span class="dv">4</span><span class="fu">/</span><span class="dv">14</span>) <span class="fu">#</span> withCount
<span class="ot">></span>     )
<span class="ot">></span>
<span class="ot">></span> mkPoint p <span class="fu">=</span> (p, circle (<span class="kw">case</span> sample c p <span class="kw">of</span>
<span class="ot">></span>                           <span class="dt">Sum</span> n  <span class="ot">-></span> <span class="dv">2</span> <span class="fu">*</span> fromIntegral n <span class="fu">/</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">1</span><span class="fu">/</span><span class="dv">5</span>)
<span class="ot">></span>                 <span class="fu">#</span> fc black
<span class="ot">></span>             )
<span class="ot">></span>
<span class="ot">> rand10 ::</span> <span class="dt">IO</span> <span class="dt">Double</span>
<span class="ot">></span> rand10 <span class="fu">=</span> randomRIO (<span class="fu">-</span><span class="dv">10</span>,<span class="dv">10</span>)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">></span>   points <span class="ot"><-</span> replicateM <span class="dv">20</span> (mkP2 <span class="fu"><$></span> rand10 <span class="fu"><*></span> rand10)
<span class="ot">></span>   return <span class="fu">$</span> c <span class="fu">#</span> clearValue <span class="fu"><></span> position (map mkPoint points)</code></pre></div></div></div><p>Notice also the use of <code class="sourceCode">clearValue</code> to get rid of the custom query;
the program that builds this documentation requires <code class="sourceCode">example</code> to have
the type <code class="sourceCode"><span class="dt">QDiagram</span> <span class="dt">B</span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="dt">Any</span></code>.</p><p>As another interesting example, consider using a set monoid to keep
track of names or identifiers for the diagrams at a given point.  This
could be used, say, to identify which element(s) of a diagram have been
selected by the user after receiving the coordinates of a mouse click.</p></div><div class="section" id="queries-and-fill-rules"><h3>Queries and fill rules</h3><p>By default, queries use the winding rule (see <a class="reference internal" href="#fill-rules">Fill rules</a>).  You can
pass an extra option to the <code class="sourceCode">stroke'</code> function to specify the even-odd
fill rule if you wish.  Be aware that queries are unaffected by
applications of the <code class="sourceCode">fillRule</code> attribute, which only affects the way a
diagram is drawn.</p></div><div class="section" id="generalized-queries"><h3>Generalized queries</h3><p>In fact, diagrams are not the only objects with associated queries: an
instance of <code class="sourceCode"><span class="dt">HasQuery</span> t m</code> declares that objects of type <code class="sourceCode">t</code> have a
value of type <code class="sourceCode">m</code> associated with each point in space.  Other things
with <code class="sourceCode"><span class="dt">HasQuery</span></code> instances include various 3D primitives, images, the
<code class="sourceCode"><span class="dt">Query</span></code> type itself, as well as located trails and paths, which can be
queried for values of type <code class="sourceCode"><span class="dt">Crossings</span></code>. A <code class="sourceCode"><span class="dt">Crossings</span></code> value
essentially records how many times one must cross the trail or path
from the queried point to reach the outside.</p></div></div><div class="section" id="bounding-boxes"><h2><generated classes="sectnum">4.6   </generated>Bounding boxes</h2><p>Envelopes (see <a class="reference internal" href="#envelopes">Envelopes</a>) are more flexible and
compositional than bounding boxes for the purposes of combining
diagrams.  However, occasionally it is useful for certain applications
to be able to work with bounding boxes, which support fast tests for
inclusion as well as union and intersection operations (envelopes
support union but not inclusion testing or intersection).</p><p>To this end, a generic implementation of arbitrary-dimensional
bounding boxes is provided in <code>Diagrams.BoundingBox</code>.  Bounding
boxes can be created from sets of points or from any <code class="sourceCode"><span class="dt">Enveloped</span></code>
object, used for inclusion or exclusion testing, and combined via
union or intersection.</p><p>To obtain a rectangle corresponding to a diagram's bounding box, use
<code class="sourceCode">boundingRect</code>.</p></div><div class="section" id="scale-invariance"><h2><generated classes="sectnum">4.7   </generated>Scale-invariance</h2><p>The <code class="sourceCode"><span class="dt">ScaleInv</span></code> wrapper can be used to create "scale-invariant"
objects. (Note that <code class="sourceCode"><span class="dt">ScaleInv</span></code> is not exported from
<code>Diagrams.Prelude</code>; to use it, import
<code>Diagrams.Transform.ScaleInv</code>.)  In the diagram below, the same
transformation is applied to each pair of arrows.</p><div class="warning bs-callout bs-callout-warning"><p>Diagrams contains native support for drawing arrows (see <a class="reference internal" href="#arrows">Arrows</a>);
the arrows in the example below are constructed manually in order to
demonstrate scale-invariance.</p></div><p>The arrows on the right are wrapped in <code class="sourceCode"><span class="dt">ScaleInv</span></code> but the ones on the left are not.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/c15ebb61d1e7fb50.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="ot">{-# LANGUAGE TypeSynonymInstances, FlexibleInstances, TypeFamilies #-}</span>
<span class="ot">></span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.Transform.ScaleInv</span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Control.Lens</span> ((^.))
<span class="ot">></span>
<span class="ot">></span> <span class="kw">class</span> <span class="dt">Drawable</span> d <span class="kw">where</span>
<span class="ot">>   draw ::</span> d <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span>
<span class="ot">></span> <span class="kw">instance</span> (n <span class="fu">~</span> <span class="dt">Double</span>) <span class="ot">=></span> <span class="dt">Drawable</span> (<span class="dt">QDiagram</span> <span class="dt">B</span> <span class="dt">V2</span> n <span class="dt">Any</span>) <span class="kw">where</span>
<span class="ot">></span>   draw <span class="fu">=</span> id
<span class="ot">></span>
<span class="ot">></span> <span class="kw">instance</span> <span class="dt">Drawable</span> a <span class="ot">=></span> <span class="dt">Drawable</span> (<span class="dt">ScaleInv</span> a) <span class="kw">where</span>
<span class="ot">></span>   draw <span class="fu">=</span> draw <span class="fu">.</span> (<span class="fu">^.</span> scaleInvObj)
<span class="ot">></span>
<span class="ot">></span> <span class="kw">instance</span> (<span class="dt">Drawable</span> a, <span class="dt">Drawable</span> b) <span class="ot">=></span> <span class="dt">Drawable</span> (a,b) <span class="kw">where</span>
<span class="ot">></span>   draw (x,y) <span class="fu">=</span> draw x <span class="fu"><></span> draw y
<span class="ot">></span>
<span class="ot">></span> arrowhead,<span class="ot"> shaft ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> arrowhead <span class="fu">=</span> triangle <span class="fl">0.5</span> <span class="fu">#</span> fc black <span class="fu">#</span> rotateBy (<span class="fu">-</span><span class="dv">1</span><span class="fu">/</span><span class="dv">4</span>)
<span class="ot">></span> shaft <span class="fu">=</span> origin <span class="fu">~~</span> p2 (<span class="dv">3</span>, <span class="dv">0</span>)
<span class="ot">></span>
<span class="ot">></span> arrow1 <span class="fu">=</span> (shaft,          arrowhead       <span class="fu">#</span> translateX <span class="dv">3</span>)
<span class="ot">></span> arrow2 <span class="fu">=</span> (shaft, scaleInv arrowhead unitX <span class="fu">#</span> translateX <span class="dv">3</span>)
<span class="ot">></span>
<span class="ot">></span> showT tr <span class="fu">=</span> draw (arrow1 <span class="fu">#</span> transform tr)
<span class="ot">></span>        <span class="fu">|||</span> strutX <span class="dv">1</span>
<span class="ot">></span>        <span class="fu">|||</span> draw (arrow2 <span class="fu">#</span> transform tr)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> vcat' (with <span class="fu">&</span> sep <span class="fu">.~</span> <span class="fl">0.5</span>)
<span class="ot">></span>             (map (centerX <span class="fu">.</span> showT)
<span class="ot">></span>               [ scalingX (<span class="dv">1</span><span class="fu">/</span><span class="dv">2</span>)
<span class="ot">></span>               , scalingY <span class="dv">2</span>
<span class="ot">></span>               , scalingX (<span class="dv">1</span><span class="fu">/</span><span class="dv">2</span>) <span class="fu"><></span> rotation (<span class="fu">-</span><span class="dv">1</span><span class="fu">/</span><span class="dv">12</span> <span class="fu">@@</span> turn)
<span class="ot">></span>               ])</code></pre></div></div></div><p>In addition, the <code class="sourceCode">scaleInvPrim</code> function creates a scale-invariant
diagram from a primitive (such as a path).  At the moment it is not
possible to create a scale-invariant diagram from another <em>diagram</em>.</p></div><div class="section" id="measurement-expressions"><h2><generated classes="sectnum">4.8   </generated>Measurement expressions</h2><div class="todo bs-callout bs-callout-info"><p>Go through this section and update it if we merge physical units for
<code class="sourceCode">output</code>.</p></div><p>There is more to <code class="sourceCode"><span class="dt">Measure</span></code>s (see <a class="reference internal" href="#measurement-units">Measurement units</a>) than just the
four reference frames.  In fact, a small domain-specific language for
constructing measurements is provided, with the following features:</p><ul><li><p><code class="sourceCode"><span class="ot">atLeast ::</span> <span class="dt">Measure</span> n <span class="ot">-></span> <span class="dt">Measure</span> n <span class="ot">-></span> <span class="dt">Measure</span> n</code> finds the maximum
of two measurements.  For example, <code class="sourceCode">normalized <span class="fl">0.2</span> <span class="ot">`atLeast`</span>
local <span class="dv">1</span></code> evaluates to whichever measurement ends up being larger,
<code class="sourceCode">normalized <span class="fl">0.2</span></code> or <code class="sourceCode">local <span class="dv">1</span></code>.</p><p>In fact, the standard line widths like <code class="sourceCode">medium</code>, <code class="sourceCode">thick</code>, <em>etc.</em>
are defined as <code class="sourceCode">normalized w <span class="ot">`atLeast`</span> output <span class="fl">0.5</span></code>, each with a
different value of <code class="sourceCode">w</code> (for example, for <code class="sourceCode">medium</code>, <code class="sourceCode">w <span class="fu">=</span> <span class="fl">0.004</span></code>).</p></li><li><p>Similarly, <code class="sourceCode">atMost</code> takes the minimum of two <code class="sourceCode"><span class="dt">Measure</span></code>s.</p></li><li><p><code class="sourceCode"><span class="dt">Measure</span> v</code> is an instance of <code class="sourceCode"><span class="dt">Additive</span></code>, which provides <code class="sourceCode">zero
<span class="ot">::</span> <span class="dt">Measure</span> v</code>, <code class="sourceCode"><span class="ot">negated ::</span> <span class="dt">Measure</span> v <span class="ot">-></span> <span class="dt">Measure</span> v</code>, and <code class="sourceCode">(<span class="fu">^+^</span>)</code> for
adding measurements.  For example, <code class="sourceCode">normalized <span class="fl">0.1</span> <span class="fu">^+^</span> output <span class="dv">1</span></code>
represents 10% of the width or height of the diagram plus one output
unit.</p></li></ul><p>The semantics of these expressions is what you would expect:
everything is first converted to compatible units, and then the
operations are interpreted in the obvious way.</p></div></div><div class="section" id="tips-and-tricks"><h1><generated classes="sectnum">5   </generated>Tips and tricks</h1><div class="section" id="polymorphic-diagrams-and-partialtypesignatures"><h2><generated classes="sectnum">5.1   </generated>Polymorphic diagrams and <code>PartialTypeSignatures</code></h2><p>Since all diagrams backends export <code>B</code> as a type tag synonym, you
can always give your diagrams type signatures like <code>Diagrams B</code>, and
switch which backend you use for rendering without having to change
all your types.</p><p>However, this does not help if you want to create some sort of
<em>backend-independent library</em> which exports diagrams or functions for
creating diagrams.  In that case, you really need to make your
diagrams polymorphic, to allow the end user to use whatever backend
they want. (This is still true even if the end user is only you!)</p><p>If you ask GHC to display the most general inferred type of various
diagrams, however, you quickly realize that they have a horrendous
mess of constraints.  For example:</p><pre><code>circle 1
  :: (RealFloat (N t), Transformable t, TrailLike t, V t ~ V2) => t

circle 1 # fc red
  :: (RealFloat (N b), Typeable (N b),
      Transformable b, HasStyle b, TrailLike b, V b ~ V2) =>
     b

\n -> text "Hello world!" &lt;> circle n # fc red
  :: (RealFloat n, Typeable n,
      Renderable (Path V2 n) b,
      Renderable (Diagrams.TwoD.Text.Text n) b) =>
     n -> QDiagram b V2 n Any</code></pre><p>Including such type signatures in your code can be a pain, and they
aren't necessarily enlightening.  Fortunately, there is a better way:
using the <code>PartialTypeSignatures</code> extension (available since GHC
7.10), it is possible to leave holes in types that GHC will fill in.
In particular, we can let GHC fill in the necessary constraints
for a type.  Here is an example:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/018c335ff364b6c9.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="ot">{-# LANGUAGE PartialTypeSignatures #-}</span>
<span class="ot">></span> <span class="ot">{-# OPTIONS_GHC -fno-warn-partial-type-signatures #-}</span>
<span class="ot">></span>
<span class="ot">> f ::</span> _ <span class="ot">=></span> n <span class="ot">-></span> <span class="dt">QDiagram</span> b <span class="dt">V2</span> n <span class="dt">Any</span>
<span class="ot">></span> f n <span class="fu">=</span> text <span class="st">"Hello world!"</span> <span class="fu"><></span> circle n <span class="fu">#</span> fc red
<span class="ot">></span>
<span class="ot">> example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> example <span class="fu">=</span> f <span class="dv">5</span></code></pre></div></div></div><p>Notice how the declared type of <code>f</code> begins with <code>_ => ...</code>, where
a wildcard has been used in place of the constraints.  GHC will check
the part of the type we have specified, but infer the missing
constraints.</p><p>Notice how we also use the <code>-fno-warn-partial-type-signatures</code>
option to GHC; otherwise, the default is for GHC to issue a warning
with each type hole that is encountered.</p></div><div class="section" id="using-absolute-coordinates"><h2><generated classes="sectnum">5.2   </generated>Using absolute coordinates</h2><p>Diagrams tries to make it easy to construct many types of graphics
while thinking in only "relative" terms: put this to the right of
that; lay these out in a row; draw this wherever that other thing
ended up; and so on.  Sometimes, however, this is not enough, and one
really wants to just think in absolute coordinates: draw this here,
draw that there.  If you find yourself wanting this, here are some
tips:</p><ul><li><p>If you have a list of diagrams which are already correctly
positioned, you can combine them with <code class="sourceCode">mconcat</code>.</p></li><li><p>The <code class="sourceCode">position</code> function takes a list of diagrams associated with
positions and combines them while placing them at the indicated
absolute positions.  <code class="sourceCode">atPoints</code> is like <code class="sourceCode">position</code> but takes a
separate list of points and list of diagrams, instead of a list of
pairs.</p></li><li><p><code class="sourceCode">juxtapose</code> can be used to position a diagram relative to
something else without composing them; see <a class="reference internal" href="#juxtaposing-without-composing">Juxtaposing without
composing</a>.</p></li><li><p><code class="sourceCode">moveTo</code> can be used to position a single diagram absolutely.</p></li><li><p><code class="sourceCode">place</code> is a flipped version of <code class="sourceCode">moveTo</code> which is sometimes
convenient.</p></li></ul></div><div class="section" id="delayed-composition"><h2><generated classes="sectnum">5.3   </generated>Delayed composition</h2><p>Suppose we have four diagrams that we want to lay out relative to one
another.  For example:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/2f0d5b907c848146.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> t <span class="fu">=</span> triangle   <span class="dv">5</span>   <span class="fu">#</span> fc orange
<span class="ot">></span> s <span class="fu">=</span> square     <span class="dv">3</span>   <span class="fu">#</span> fc red
<span class="ot">></span> o <span class="fu">=</span> ellipseXY  <span class="dv">2</span> <span class="dv">3</span> <span class="fu">#</span> fc blue
<span class="ot">></span> c <span class="fu">=</span> circle     <span class="dv">2</span>   <span class="fu">#</span> fc green
<span class="ot">></span>
<span class="ot">></span> d <span class="fu">=</span> centerX (t <span class="fu">|||</span> s <span class="fu">|||</span> o <span class="fu">|||</span> c)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> d</code></pre></div></div></div><p>(Instead of <code class="sourceCode">(<span class="fu">|||</span>)</code> we could equivalently have used <code class="sourceCode">hcat</code>.)  Now
<code class="sourceCode">d</code> is the diagram consisting of these four shapes laid out in a
centered row.</p><p>But what if we want to do further processing on the individual shapes?
At this point, we are out of luck.  There is (currently) no way to
break apart a diagram into subdiagrams once it has been composed
together.  We could use <code class="sourceCode">juxtapose</code> (which positions one diagram
relative to another without actually doing any composition) but that
would get ugly and unintuitive.</p><p>Here is where the nifty trick comes in: simply enclose each shape in a
list, like so:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> ds <span class="fu">=</span> centerX ([t] <span class="fu">|||</span> [s] <span class="fu">|||</span> [o] <span class="fu">|||</span> [c])</code></pre></div></div><p>Now <code class="sourceCode">ds</code> is a <em>list</em> of four diagrams, which are the same as the
original <code class="sourceCode">t</code>, <code class="sourceCode">s</code>, <code class="sourceCode">o</code>, <code class="sourceCode">c</code> except that they have been positioned as
they would be in <code class="sourceCode">d</code>!  We can now go on to do other things with them
individually.  For example, we could alter their positions slightly
before composing them (<em>e.g.</em> this makes for an easy way to apply some
random "jitter" to a layout):</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/c7a8fa6d24e1d265.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> t <span class="fu">=</span> triangle   <span class="dv">5</span>   <span class="fu">#</span> fc orange
<span class="ot">></span> s <span class="fu">=</span> square     <span class="dv">3</span>   <span class="fu">#</span> fc red
<span class="ot">></span> o <span class="fu">=</span> ellipseXY  <span class="dv">2</span> <span class="dv">3</span> <span class="fu">#</span> fc blue
<span class="ot">></span> c <span class="fu">=</span> circle     <span class="dv">2</span>   <span class="fu">#</span> fc green
<span class="ot">></span>
<span class="ot">></span> ds <span class="fu">=</span> centerX ([t] <span class="fu">|||</span> [s] <span class="fu">|||</span> [o] <span class="fu">|||</span> [c])
<span class="ot">></span> d' <span class="fu">=</span> mconcat <span class="fu">$</span> zipWith translateY [<span class="fl">0.5</span>, <span class="fu">-</span><span class="fl">0.6</span>, <span class="dv">0</span>, <span class="fl">0.4</span>] ds
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> d'</code></pre></div></div></div><p>In other words, enclosing diagrams in a list allows them to be
positioned, aligned, <em>etc.</em> as they normally would, <em>except</em> that it
delays actually composing them!</p><p>Another example of this technique is when we want to lay out a list of
diagrams using, say, <code class="sourceCode">hcat'</code>, but want them to be stacked in a
different order than what <code class="sourceCode">hcat</code> produces:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/1668184d7299b8d9.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> t <span class="fu">=</span> triangle   <span class="dv">5</span>   <span class="fu">#</span> fc orange
<span class="ot">></span> s <span class="fu">=</span> square     <span class="dv">3</span>   <span class="fu">#</span> fc red
<span class="ot">></span> o <span class="fu">=</span> ellipseXY  <span class="dv">2</span> <span class="dv">3</span> <span class="fu">#</span> fc blue
<span class="ot">></span> c <span class="fu">=</span> circle     <span class="dv">2</span>   <span class="fu">#</span> fc green
<span class="ot">></span>
<span class="ot">></span> [t',s',o',c'] <span class="fu">=</span> hcat' (with <span class="fu">&</span> catMethod <span class="fu">.~</span> <span class="dt">Distrib</span> <span class="fu">&</span> sep <span class="fu">.~</span> <span class="dv">1</span>)
<span class="ot">></span>                       (map (<span class="fu">:</span>[]) [t,s,o,c])
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> mconcat [s',c',o',t']</code></pre></div></div></div><p>In this example we position the triangle, square, ellipse, and circle
in that order from left to right, but then place them with the square
on top, the circle next, and so on.</p><p>This works because lists are instances of <code class="sourceCode"><span class="dt">Juxtaposable</span></code>, <code class="sourceCode"><span class="dt">Alignable</span></code>,
<code class="sourceCode"><span class="dt">Enveloped</span></code>, <code class="sourceCode"><span class="dt">HasOrigin</span></code>, <code class="sourceCode"><span class="dt">HasStyle</span></code>, <code class="sourceCode"><span class="dt">Transformable</span></code>, and, of course,
<code class="sourceCode"><span class="dt">Monoid</span></code>.  All these instances work in the "obvious" way—for
example, the envelope for a list is the combination of the envelopes
of the elements—so applying an operation to a list of diagrams has
the same effect as applying the operation to the composition of those
diagrams.  In other words, operations such as <code class="sourceCode">centerX</code>, <code class="sourceCode">scale</code>,
<code class="sourceCode">juxtapose</code>, <em>etc.</em> all commute with <code class="sourceCode">mconcat</code>.</p></div><div class="section" id="naming-vertices"><h2><generated classes="sectnum">5.4   </generated>Naming vertices</h2><p>Most functions that create some sort of shape (<em>e.g.</em> <code class="sourceCode">square</code>,
<code class="sourceCode">pentagon</code>, <code class="sourceCode">polygon</code>...) can in fact create any instance of the
<code class="sourceCode"><span class="dt">TrailLike</span></code> class (see <a class="reference internal" href="#traillike">TrailLike</a>).  You can often
take advantage of this to do some custom processing of shapes by
creating a <em>trail</em> instead of a diagram, doing some processing, and
then turning the trail into a diagram.</p><p>In particular, assigning names to the vertices of a shape can be
accomplished as follows. Instead of writing just (say) <code class="sourceCode">pentagon</code>, write</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> stroke' ( with <span class="fu">&</span> vertexNames <span class="fu">.~</span> [[<span class="dv">0</span><span class="fu">..</span>]] ) pentagon</code></pre></div></div><p>which assigns consecutive numbers to the vertices of the pentagon.</p></div><div class="section" id="deciphering-error-messages"><h2><generated classes="sectnum">5.5   </generated>Deciphering error messages</h2><p>Although making <code>diagrams</code> an <em>embedded</em> domain specific language
has many benefits, it also has (at least) one major downside:
difficult-to-understand error messages.  Interpreting error messages
often requires understanding particular details about the internals of
the <code>diagrams</code> framework as well as the particular behavior of GHC.
This section attempts to make the situation a bit more palatable by
explaining a few common types of error message you might get while
using <code>diagrams</code>, along with some suggestions as to their likely
causes and solutions.</p><p>This section is certainly incomplete; please send examples of other
error messages to the <a class="reference external" href="http://groups.google.com/group/diagrams-discuss?pli=1">diagrams mailing list</a> for help interpreting
them and/or so they can be added to this section.</p><div class="section" id="couldn-t-match-type-v-p2-double-with-v2-double"><h3>Couldn't match type <code class="sourceCode"><span class="dt">V</span> (<span class="dt">P2</span> <span class="dt">Double</span>)</code> with <code class="sourceCode"><span class="dt">V2</span> <span class="dt">Double</span></code></h3><p>This error is due to what appears to be a bug in 7.6.* versions of
GHC.  For some reason the definition of the <code class="sourceCode"><span class="dt">V</span></code> type family for points
is not exported.  To solve this you can add an explicit import of the
form <code class="sourceCode"><span class="kw">import </span><span class="dt">Diagrams.Core.Points</span></code> to the top of your
file.</p></div><div class="section" id="could-not-deduce-n-a0-n-a"><h3>Could not deduce N a0 ~ N a ...</h3><p>There will probably come a time when you get an error message such as</p><pre><code>Could not deduce (N a0 ~ N a)
from the context ...

... (lots more detail here)

Probable cause: the inferred type is ambiguous</code></pre><p>The last line is actually the most informative: the problem is that
the types <code class="sourceCode">a</code> and <code class="sourceCode">a0</code> are ambiguous.  Such errors arise, for example,
when you pass a diagram to a function which is polymorphic in its
input but monomorphic in its output, such as <code class="sourceCode">width</code>, <code class="sourceCode">height</code>,
<code class="sourceCode">phantom</code>, or <code class="sourceCode">names</code>.  Such functions compute some property of the
diagram, or use it to accomplish some other purpose, but do not result
in the diagram being rendered.  If the diagram does not have a
monomorphic type, GHC complains that it cannot determine the diagram's
type.</p><p>For example, here is the error we get if we try to compute the
width of a radius-1 circle:</p><pre><code>ghci> width (circle 1)

&lt;interactive>:4:1:
    Could not deduce (N a0 ~ N a)
    from the context (Enveloped a,
                      Transformable a,
                      TrailLike a,
                      RealFloat (N a),
                      V a ~ V2)
      bound by the inferred type for ‘it’:
                 (Enveloped a, Transformable a, TrailLike a, RealFloat (N a),
                  V a ~ V2) =>
                 N a
      at &lt;interactive>:4:1-16
    NB: ‘N’ is a type function, and may not be injective
    The type variable ‘a0’ is ambiguous
    When checking that ‘it’
      has the inferred type ‘forall a.
                             (Enveloped a, Transformable a, TrailLike a, RealFloat (N a),
                              V a ~ V2) =>
                             N a’
    Probable cause: the inferred type is ambiguous</code></pre><p>GHC complains that it cannot deduce that <code class="sourceCode"><span class="dt">N</span> a0</code> is the same as <code class="sourceCode"><span class="dt">N</span> a</code>;
what is really going on is that it does not have enough information to
decide the type of <code class="sourceCode">circle <span class="dv">1</span></code> (for example, is it a <code class="sourceCode"><span class="dt">Trail</span></code>? A <code class="sourceCode"><span class="dt">Path</span></code>?
A <code class="sourceCode"><span class="dt">Diagram</span></code> of some sort?).  This is annoying because <em>we</em> know that
the choice of type cannot affect the width of the circle; but there is
no way for GHC to know that.</p><p>The special type <code class="sourceCode"><span class="dt">D</span></code> is provided for exactly this situation, defined as</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">type</span> <span class="dt">D</span> v n <span class="fu">=</span> <span class="dt">Diagram</span> <span class="dt">NullBackend</span> v n</code></pre></div></div><p><code class="sourceCode"><span class="dt">NullBackend</span></code> is a "backend" which simply does nothing: perfect
for use in cases where GHC insists on knowing what backend to use but
the backend really does not matter.</p><p>For example, one solution to the problem with <code class="sourceCode">width</code> is to annotate
<code class="sourceCode">circle <span class="dv">1</span></code> with the type <code class="sourceCode"><span class="dt">D</span> <span class="dt">V2</span> <span class="dt">Double</span></code>, like so:</p><pre><code>ghci> width (circle 1 :: D V2 Double)
1.9999999999999998</code></pre><p>Well... close enough.</p><p>Another common cause of "Could not deduce <code>N a0 ~ N a</code> ..." is
calling the <code class="sourceCode">stroke</code> function on a polymorphic value.  For example,</p><pre><code>ghci> stroke $ circle 1

interactive>:9:1:
    Could not deduce (N s0 ~ N s)
    from the context (Transformable s,
                      Renderable (Path V2 (N s)) b,
                      ToPath s,
                      TrailLike s,
                      Data.Typeable.Internal.Typeable (N s),
                      RealFloat (N s),
                      V s ~ V2)
      bound by the inferred type for ‘it’:
                 (Transformable s, Renderable (Path V2 (N s)) b, ToPath s,
                  TrailLike s, Data.Typeable.Internal.Typeable (N s),
                  RealFloat (N s), V s ~ V2) =>
                 QDiagram b V2 (N s) Any
      at &lt;interactive>:9:1-17
    NB: ‘N’ is a type function, and may not be injective
    The type variable ‘s0’ is ambiguous
    Expected type: QDiagram b V2 (N s) Any
      Actual type: QDiagram b V2 (N s0) Any
    When checking that ‘it’
      has the inferred type ‘forall b s.
                             (Transformable s, Renderable (Path V2 (N s)) b, ToPath s,
                              TrailLike s, Data.Typeable.Internal.Typeable (N s),
                              RealFloat (N s), V s ~ V2) =>
                             QDiagram b V2 (N s) Any’
    Probable cause: the inferred type is ambiguous</code></pre><p>The problem, again, is ambiguity: <code class="sourceCode">circle <span class="dv">1</span></code> has a type like <code class="sourceCode">(<span class="fu">...</span>) <span class="ot">=></span>
t</code>, but <code class="sourceCode">stroke</code> has a type like <code class="sourceCode">(<span class="fu">...</span>) <span class="ot">=></span> t <span class="ot">-></span> <span class="dt">QDiagram</span> b <span class="dt">V2</span> (<span class="dt">N</span> t)
<span class="dt">Any</span></code>, so GHC does not know which type to pick for <code class="sourceCode">t</code>.  You can solve
this by explicitly fixing a type for <code class="sourceCode">t</code>, <em>e.g.</em> by giving a type
signature:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> stroke <span class="fu">$</span> (circle <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Trail</span> <span class="dt">V2</span> <span class="dt">Double</span>)</code></pre></div></div><p>or by using a version of <code class="sourceCode">stroke</code> with a more specific type,</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> strokeTrail <span class="fu">$</span> circle <span class="dv">1</span></code></pre></div></div></div><div class="section" id="could-not-deduce-isname-a0"><h3>Could not deduce (IsName a0)</h3><p>Another common source of ambiguity comes from the use of <code class="sourceCode"><span class="dt">Name</span></code>s.
For example, the code below is taken from the example in the section
on <a class="reference internal" href="#qualifying-names">Qualifying names</a>:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> hsep <span class="fl">0.5</span> (zipWith (<span class="fu">.>></span>) [<span class="dv">0</span> <span class="fu">..</span> ] (replicate <span class="dv">5</span> squares))</code></pre></div></div><p>It is an attempt to qualify the names in five copies of <code class="sourceCode">squares</code> with
the numbers <code class="sourceCode"><span class="dv">0</span></code>, <code class="sourceCode"><span class="dv">1</span></code>, <code class="sourceCode"><span class="dv">2</span></code>, ...  However, depending on your version of
GHC, it may generate the terifying error shown below:</p><pre><code>interactive>:8:19:
    Could not deduce (IsName a0) arising from a use of ‘.>>’
    from the context (Monoid a,
                      HasOrigin a,
                      Juxtaposable a,
                      Qualifiable a,
                      TrailLike a,
                      Semigroup a,
                      V a ~ V2)
      bound by the inferred type of
               it :: (Monoid a, HasOrigin a, Juxtaposable a, Qualifiable a,
                      TrailLike a, Semigroup a, V a ~ V2) =>
                     a
      at &lt;interactive>:8:1-54
    The type variable ‘a0’ is ambiguous
    Note: there are several potential instances:
      instance IsName () -- Defined in ‘Diagrams.Core.Names’
      instance (IsName a, IsName b) => IsName (a, b)
        -- Defined in ‘Diagrams.Core.Names’
      instance (IsName a, IsName b, IsName c) => IsName (a, b, c)
        -- Defined in ‘Diagrams.Core.Names’
      ...plus 10 others
    In the first argument of ‘zipWith’, namely ‘(.>>)’
    In the second argument of ‘hsep’, namely
      ‘(zipWith (.>>) [0 .. ] (replicate 5 squares))’
    In the expression:
      hsep 0.5 (zipWith (.>>) [0 .. ] (replicate 5 squares))</code></pre><p>Actually, this is just one of <em>three</em> terrifying errors it generates,
but the other two are similar (one complaining about <code class="sourceCode"><span class="dt">Enum</span></code> and one
about <code class="sourceCode"><span class="dt">Num</span></code>).</p><p>The problem, again, is that GHC does not know what type to choose for
some polymorphic value.  Here, the polymorphic values in question are
the numbers <code class="sourceCode"><span class="dv">0</span></code>, <code class="sourceCode"><span class="dv">1</span></code>, ... Numeric literals are polymorphic in Haskell,
so GHC does not know whether they should be <code class="sourceCode"><span class="dt">Int</span></code>s or <code class="sourceCode"><span class="dt">Integer</span></code>s or
<code class="sourceCode"><span class="dt">Double</span></code>s or... The solution is to annotate the <code class="sourceCode"><span class="dv">0</span></code> with the desired
type.</p></div></div></div><div class="section" id="creating-3d-diagrams"><h1><generated classes="sectnum">6   </generated>Creating 3D diagrams</h1><p><code>diagrams</code>' support for three dimensions is growing: currently,
modules <code>Diagrams.ThreeD.Align</code>, <code>Diagrams.ThreeD.Camera</code>,
<code>Diagrams.ThreeD.Light</code>, <code>Diagrams.ThreeD.Shapes</code>,
<code>Diagrams.ThreeD.Transform</code>, <code>Diagrams.ThreeD.Types</code>, and
<code>Diagrams.ThreeD.Vector</code> are all included in <span class="package"><a href="http://hackage.haskell.org/package/diagrams-lib"><code>diagrams-lib</code></a></span>.
This should still be considered a "feature preview"—in particular,
appropriate 3D backends are still under construction (see
<span class="repo"><a href="http://github.com/diagrams/diagrams-povray"><code>diagrams-povray</code></a></span>).  Look for fuller (and more fully documented)
support for 3D diagrams in an upcoming release!  In the meantime,
consult the <a class="reference external" href="3D.html">3D tutorial</a> for a more detailed feature preview.</p></div><div class="section" id="animation"><h1><generated classes="sectnum">7   </generated>Animation</h1><p>Diagrams has experimental support for the creation of <em>animations</em>.
Animations are created with the help of a generic <code class="sourceCode"><span class="dt">Active</span></code>
abstraction, defined in the <span class="package"><a href="http://hackage.haskell.org/package/active"><code>active</code></a></span> package. Additionally,
animated GIFs can be created using the cairo or rasterific backend.</p><div class="warning bs-callout bs-callout-warning"><p>The <span class="package"><a href="http://hackage.haskell.org/package/active"><code>active</code></a></span> package is being completely rewritten based on a
much improved semantics.  The rewritten version is slated for
integration with an upcoming version of diagrams, Real Soon Now
(tm).</p></div><div class="section" id="active"><h2><generated classes="sectnum">7.1   </generated>Active</h2><p>The <span class="package"><a href="http://hackage.haskell.org/package/active"><code>active</code></a></span> package defines a simple abstraction for working
with <em>time-varying values</em>. A value of type <code class="sourceCode"><span class="dt">Active</span> a</code> is either a
constant value of type <code class="sourceCode">a</code>, or a time-varying value of type <code class="sourceCode">a</code>
(<em>i.e.</em> a function from time to <code class="sourceCode">a</code>) with specific start and end
times. Since active values have start and end times, they can be
aligned, sequenced, stretched, or reversed. In a sense, this is sort
of like a stripped-down version of functional reactive programming
(FRP), without the reactivity.</p><p>There are two basic ways to create an <code class="sourceCode"><span class="dt">Active</span></code> value. The first is to
use <code class="sourceCode">mkActive</code> to create one directly, by specifying a start and end
time and a function of time. More indirectly, one can use the
<code class="sourceCode"><span class="dt">Applicative</span></code> instance for <code class="sourceCode"><span class="dt">Active</span></code> together with the "unit interval"
<code class="sourceCode">ui</code>, which takes on values from the unit interval from time 0 to time
1, or <code class="sourceCode">interval</code>, which is like <code class="sourceCode">ui</code> but over an arbitrary interval.</p><p>For example, to create a value of type <code class="sourceCode"><span class="dt">Active</span> <span class="dt">Double</span></code> which represents
one period of a sine wave starting at time 0 and ending at time 1, we
could write</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> mkActive <span class="dv">0</span> <span class="dv">1</span> (\t <span class="ot">-></span> sin (fromTime t <span class="fu">*</span> tau))</code></pre></div></div><p>or</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> (sin <span class="fu">.</span> (<span class="fu">*</span>tau)) <span class="fu"><$></span> ui</code></pre></div></div><p><code class="sourceCode">pure</code> can also be used to create <code class="sourceCode"><span class="dt">Active</span></code> values which are constant
and have no start or end time. For example,</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> mod <span class="fu"><$></span> (floor <span class="fu"><$></span> interval <span class="dv">0</span> <span class="dv">100</span>) <span class="fu"><*></span> pure <span class="dv">7</span></code></pre></div></div><p>cycles repeatedly through the numbers 0-6.</p><p>To take a "snapshot" of an active value at a particular point in time,
the <code class="sourceCode">runActive</code> function can be used to turn one into a function of
time.  For example,</p><pre><code>> runActive ((sin . (*tau)) &lt;$> ui) $ 0.2
0.9510565162951535</code></pre><div class="todo bs-callout bs-callout-info"><p>Write more about using the active library.  For now, you can read
the <a class="reference external" href="http://hackage.haskell.org/packages/archive/active/latest/doc/html/Data-Active.html">package documentation</a> for more information.</p><ul><li><p>Transforming active values</p></li><li><p>Combining active values</p></li></ul></div></div><div class="section" id="using-active-with-diagrams"><h2><generated classes="sectnum">7.2   </generated>Using Active with diagrams</h2><p>An animation is defined, simply, as something of type
<code class="sourceCode"><span class="dt">Active</span> (<span class="dt">Diagram</span> b v)</code> for an appropriate backend type <code class="sourceCode">b</code> and vector
space <code class="sourceCode">v</code>.  Hence it is possible to make an animation by using the
<code class="sourceCode">mkActive</code> function and specifying a function from time to diagrams.</p><p>However, most often, animations are constructed using the
<code class="sourceCode"><span class="dt">Applicative</span></code> interface.  For example, to create a moving circle we
can write</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> translateX <span class="fu"><$></span> ui <span class="fu"><*></span> circle <span class="dv">2</span></code></pre></div></div><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams-cairo"><code>diagrams-cairo</code></a></span> includes a very primitive animation rendering
function, <code class="sourceCode">animMain</code>, which takes an animation and spits out a bunch
of image files, one for each frame.  You can then assemble the
generated frames into an animation using, <em>e.g.</em>, <code>ffmpeg</code>. (More
sophisticated animation rendering will be added in future releases.)
If you use <code class="sourceCode">animMain</code> to visualize the above animation, however, you
will find that all the generated frames look the same—the circle is
not moving!</p><p>Actually, it <em>is</em> moving, it's just that it gets centered in the
output at each instant. It's as if the viewport is panning along at
the same rate as the circle, with the result that it appears
stationary.  The way to fix this is by placing the moving circle on
top of something larger and stationary in order to "fix" the
viewpoint.  Let's use an invisible square:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> (translateX <span class="fu"><$></span> ui <span class="fu"><*></span> circle <span class="dv">2</span>) <span class="fu"><></span> (pure (square <span class="dv">6</span> <span class="fu">#</span> lw none))</code></pre></div></div><p>Notice that we composed two animations using <code class="sourceCode">(<span class="fu"><></span>)</code>, which does
exactly what you would think: superimposes them at every instant in time.</p><p>Since this is such a common thing to want, the
<code>Diagrams.Animation</code> module provides a function <code class="sourceCode">animEnvelope</code>
for expanding the envelope of an animation to the union of all the
envelopes over time (determined by sampling at a number of points).  That
is, the animation will now use a constant envelope that encloses the
entirety of the animation at all points in time.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> animEnvelope (translateX <span class="fu"><$></span> ui <span class="fu"><*></span> circle <span class="dv">2</span>)</code></pre></div></div><p>Since <code class="sourceCode"><span class="dt">Active</span></code> is generic, it is also easy (and useful) to
create active <code class="sourceCode"><span class="dt">Point</span></code>s, <code class="sourceCode"><span class="dt">Path</span></code>s, colors, or values of any other type.</p><div class="todo bs-callout bs-callout-info"><ul><li><p>Examples of animating things other than diagrams</p></li></ul></div></div><div class="section" id="animated-gifs"><h2><generated classes="sectnum">7.3   </generated>Animated GIFs</h2><p>Animated GIFs can be created directly using the cairo backend.  This
is done by calling <code class="sourceCode">mainWith</code> with an argument of type <code class="sourceCode">[(<span class="dt">Diagram</span>
<span class="dt">Cairo</span> <span class="dt">V2</span> <span class="dt">Double</span>, <span class="dt">GifDelay</span>)]</code> where <code class="sourceCode"><span class="dt">GifDelay</span></code> is a synonym for <code class="sourceCode"><span class="dt">Int</span></code>. Each
tuple is a diagram frame of the animation and a time in hundredths of
a second until the next frame.  This creates an executable which takes
an output file with the extension gif. The other command line options
which can be used are <code>--dither</code> (to turn on dithering), <code>--looping-off</code>,
and <code>--loop-repeat</code> (to specify the number of times to repeat the loop
after the first time).</p></div></div><div class="section" id="rendering-backends"><h1><generated classes="sectnum">8   </generated>Rendering backends</h1><p>Diagrams has a system for "pluggable" rendering backends, so new
backends can be added by implementing instances of some type classes.
Some "official" backends are listed below; there are also several
other unofficial or experimental backends.  See also the <a class="reference external" href="https://wiki.haskell.org/Diagrams/Projects#Officially_supported_backends">list of
backends on the wiki</a>. New backends are welcome!  To get started,
take a look at the existing backends for examples, read the section
below on <a class="reference internal" href="#tools-for-backends">Tools for backends</a>, and consult the <a class="reference external" href="core.html">core library
reference</a>.</p><div class="section" id="calling-backends"><h2><generated classes="sectnum">8.1   </generated>Calling backends</h2><p>The simplest way to render a diagram is using either the <code class="sourceCode">defaultMain</code>
or <code class="sourceCode">mainWith</code> functions to generate a default executable that renders
the diagram.  However, there are other, more flexible ways as well.
The precise set of methods available will vary with the particular
backend being used, but there are some things that can be said in
general.</p><p>Many backends provide backend-specific rendering functions.  For
example, the Cairo backend provides</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> renderCairo ::</span> FilePath <span class="ot">-></span> <span class="dt">SizeSpec</span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">QDiagram</span> <span class="dt">Cairo</span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="dt">Any</span> <span class="ot">-></span> <span class="dt">IO</span> ()</code></pre></div></div><p>This still causes a rendered diagram to be output to a file, just as
in the case of <code class="sourceCode">mainWith</code>.  The difference is that this is <em>all</em> it
does—it is not wrapped inside an executable that expects
command-line arguments, and so on.  This can be useful if you want a
program that does more than just render a single diagram—perhaps it
renders multiple diagrams, or perhaps it does things other than just
render a diagram, for example, fetch some data over a network and then
use the data to generate a diagram which is rendered, and so on.</p><p>The most general way to call a backend is to use <code class="sourceCode">renderDia</code>, which is
a method of the <code class="sourceCode"><span class="dt">Backend</span></code> class.  Its type (omitting a bunch of type
class constraints) is</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> renderDia ::</span> (<span class="fu">...</span>) <span class="ot">=></span> b <span class="ot">-></span> <span class="dt">Options</span> b v n <span class="ot">-></span> <span class="dt">QDiagram</span> b v n m <span class="ot">-></span> <span class="dt">Result</span> b v n</code></pre></div></div><p>It takes a backend token, an options record, and a diagram, and
renders it to some sort of result.  Both <code class="sourceCode"><span class="dt">Options</span></code> and <code class="sourceCode"><span class="dt">Result</span></code> are
associated types defined by the <code class="sourceCode"><span class="dt">Backend</span></code> class, so what types they
actually resolve to depends on the particular backend.</p><p><code class="sourceCode">renderDiaT</code> is a variant of <code class="sourceCode">renderDia</code> with type</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> renderDiaT ::</span> (<span class="fu">...</span>) <span class="ot">=></span> b <span class="ot">-></span> <span class="dt">Options</span> b v n <span class="ot">-></span> <span class="dt">QDiagram</span> b v n m <span class="ot">-></span> (<span class="dt">Transformation</span> v n, <span class="dt">Result</span> b v n)</code></pre></div></div><p>The only difference is that in addition to a <code class="sourceCode"><span class="dt">Result</span></code>, it also returns
the <code class="sourceCode"><span class="dt">Transformation</span></code> which was generated to transform the given
diagram into the coordinates required by the backend (for example,
flipping it vertically if the backend's y coordinates increase
downwards, resizing and centering to fit the requested dimensions, and
so on).  The inverse of this transformation can be used to transform
output coordinates back into diagram coordinates (for example, in
order to <a class="reference external" href="http://projects.haskell.org/diagrams/blog/2015-04-30-GTK-coordinates.html">map mouse clicks in a GTK window onto a diagram</a>).</p></div><div class="section" id="the-svg-backend"><h2><generated classes="sectnum">8.2   </generated>The SVG backend</h2><p>The SVG backend, <span class="package"><a href="http://hackage.haskell.org/package/diagrams-svg"><code>diagrams-svg</code></a></span>, outputs SVG files.  It is the
default "out-of-the-box" backend, i.e. what one gets by typing just
<code>cabal install diagrams</code>.  It is implemented purely in Haskell, with
no dependencies on external libraries via the FFI.  This means that it
should be easy to install on all platforms.</p><p>For information on making use of the SVG backend, see
<code>Diagrams.Backend.SVG</code>.  Gradient support is complete in this
backend; however, most browsers do not handle the SVG spec correctly
when it comes to reflect and repeat.  Apparently only Chrome and IE
follow the spec correctly at this point, while Safari does not handle
reflect and repeat at all and Firefox gets it wrong.</p><p>The SVG backend includes an additional module <code>Diagrams.Backend.SVG.Attributes</code>
for SVG specific attributes. Currently the module adds two attributes, <code class="sourceCode"><span class="dt">SvgId</span></code> and <code class="sourceCode"><span class="dt">SvgClass</span></code>
that are used to add class and id to SVG elements. This allows parts of a diagram
to be referenced for additional javascript processing when the SVG output is embedded in
an HTML file.</p><p>The source code for the SVG backend can be found in the
<span class="repo"><a href="http://github.com/diagrams/diagrams-svg"><code>diagrams-svg</code></a></span> repository. Note the functions <code class="sourceCode">renderDia</code> and
<code class="sourceCode">renderSVG</code> for rendering diagrams directly.</p></div><div class="section" id="the-rasterific-backend"><h2><generated classes="sectnum">8.3   </generated>The Rasterific backend</h2><p>The Rasterific backend is built on top of the <span class="package"><a href="http://hackage.haskell.org/package/Rasterific"><code>Rasterific</code></a></span>
package, which is a pure haskell rasterizer that uses
<span class="package"><a href="http://hackage.haskell.org/package/JuicyPixels"><code>JuicyPixels</code></a></span> and <span class="package"><a href="http://hackage.haskell.org/package/FontyFruity"><code>FontyFruity</code></a></span>.  This is a fully featured
backend that supports the full APi of the diagrams library.  It can
produce PNG, JPG, BMP, TIF, PDF and animated GIF images. It also
supports embedded images (see <code class="sourceCode"><span class="dt">DImage</span></code>) and although it does not yet
have the text handling capabilities of cairo, it does use the exact
text bounding box for alignment. Gradients are fully supported
including repetition and reflection. In addition, the Rasterific
backend can be used to generate in-memory images that can be
manipulated with <code class="sourceCode"><span class="dt">JuicyPixels</span></code>. Finally, the Rasterific backend
suppports grouped opacity.</p><p>The Rasterific backend can be invoked via
<code>Diagrams.Backend.Rasterific.CmdLine</code> module, or via the
<code class="sourceCode">renderDia</code> and <code class="sourceCode">renderRasterific</code> functions.</p></div><div class="section" id="the-cairo-backend"><h2><generated classes="sectnum">8.4   </generated>The cairo backend</h2><p>The cairo backend, <span class="package"><a href="http://hackage.haskell.org/package/diagrams-cairo"><code>diagrams-cairo</code></a></span>, is built on top of the
<span class="package"><a href="http://hackage.haskell.org/package/cairo"><code>cairo</code></a></span> package, which contains bindings to the <a class="reference external" href="http://www.cairographics.org/">cairo 2D
graphics library</a>.  Although it is quite full-featured, the cairo
library itself can be unfortunately difficult to install on some
platforms, particularly OS X.</p><p>The cairo backend can produce PNG, SVG, PDF, postscript,
and animated GIF output. The cairo backend does support gradients
however, due to a bug in the cairo package it does not handle reflect
and repeat correctly for radial gradients,</p><comment xml:space="preserve">_ `Extend`:http://hackage.haskell.org/package/cairo-0.12.5.3/docs/Graphics-Rendering-Cairo.html#t:Extend</comment><p>For specific information on how to make use of it, see the
documentation for the <code>Diagrams.Backend.Cairo</code> module.</p><definition_list><definition_list_item><term><code>diagrams-cairo</code> was the first officially supported backend, and has</term><definition><p>a few advanced features:</p></definition></definition_list_item></definition_list><ul><li><p><code>Diagrams.Backend.Cairo.List</code> exports the <code class="sourceCode">renderToList</code>
function, which can convert a 2D diagram to a matrix of pixel color
values.</p></li><li><p><code>Diagrams.Backend.Cairo.Ptr</code> exports functions for rendering
diagrams directly to buffers in memory.</p></li></ul><p>The source code for the cairo backend can be found in the
<span class="repo"><a href="http://github.com/diagrams/diagrams-cairo"><code>diagrams-cairo</code></a></span> repository.  The functions <code class="sourceCode">renderDia</code> and
<code class="sourceCode">renderCairo</code> provide an alternative to the
<code class="sourceCode"><span class="dt">Diagrams.Backend.Cairo.CmdLine</span></code> interface for more programmatic
control of the output.</p></div><div class="section" id="the-postscript-backend"><h2><generated classes="sectnum">8.5   </generated>The postscript backend</h2><p>The postscript backend, <span class="package"><a href="http://hackage.haskell.org/package/diagrams-postscript"><code>diagrams-postscript</code></a></span>, like the SVG
backend, is written purely in Haskell.  It outputs encapsulated
PostScript (EPS) files.  Note that by nature, EPS does not support
transparency.  The postscript backend also does not support embedded
images or gradients.  However, it is fairly complete in its support for other
features and includes experimental support for multi-page output and
CMYK colors.</p><p>The source code for the postscript backend can be found in the
<span class="repo"><a href="http://github.com/diagrams/diagrams-postscript"><code>diagrams-postscript</code></a></span> repository.</p></div><div class="section" id="the-canvas-backend"><h2><generated classes="sectnum">8.6   </generated>The Canvas backend</h2><p>The Canvas backend is one of the two backends that target the browser.
Running a diagram's program that has been compiled using the Canvas backend
will create a possibly interactive session accessed at <code class="sourceCode">http<span class="fu">://</span>localhost<span class="fu">:</span><span class="dv">3000</span><span class="fu">/</span></code>.
The Canvas backend is native and uses the <span class="package"><a href="http://hackage.haskell.org/package/blank-canvas"><code>blank-canvas</code></a></span> package. It is a full
featured backend supporting gradients and external images. Diagrams generated
with the Canvas backend cannot be saved as graphics files, only as programs to
be run locally.</p><p>The Canvas backend can be invoked via
<code>Diagrams.Backend.Canvas.CmdLine</code> module, or via the
<code class="sourceCode">renderDia</code>/<code class="sourceCode">renderCanvas</code> functions.</p></div><div class="section" id="the-html5-backend"><h2><generated classes="sectnum">8.7   </generated>The HTML5 backend</h2><p>Like the Canvas backend, the HTML5 backend targets the browser. The difference is
that the HTML5 backend creates a file of stand alone Javascript and optionally
HTML that can be used as a (or part of a) web page. It is based on the
<span class="package"><a href="http://hackage.haskell.org/package/static-canvas"><code>static-canvas</code></a></span> package.  It is a full featured backend supporting
gradients and external images.</p><p>The HTML5 backend can be invoked via
<code>Diagrams.Backend.Html5.CmdLine</code> module, or via the
<code class="sourceCode">renderDia</code>/<code class="sourceCode">renderHtml5</code> functions.</p></div><div class="section" id="the-pgf-backend"><h2><generated classes="sectnum">8.8   </generated>The PGF backend</h2><p>The PGF backend, <span class="package"><a href="http://hackage.haskell.org/package/diagrams-pgf"><code>diagrams-pgf</code></a></span>, uses the \(\TeX\) macro package <a class="reference external" href="https://www.ctan.org/pkg/pgf">PGF</a>
to render diagrams. It supports most
features of diagrams including external and (non-transparent) embedded
images. Gradients don't support alpha colours and radial gradients'
spread methods and positions aren't quite right. These issues will
hopefully be fixed in the future.</p><p>Since it uses \(\TeX\), it has excellent typographic capabilities,
although these require knowledge of \(\TeX\). Simply use the <code class="sourceCode">text</code>
function to produce text that will be typeset by \(\TeX\).  You can
also use the <code class="sourceCode">text</code> function with a string surrounded by dollar signs
(<code class="sourceCode"><span class="fu">$</span></code>) to typeset mathematics.  The backend also includes experimental
functions for querying \(\TeX\) for the size of hboxes, which can
be used as a bounding box for a diagram. There are some usage examples
in the <a class="reference external" href="https://github.com/diagrams/diagrams-pgf/tree/master/examples">examples folder</a> of
the <a class="reference external" href="https://github.com/diagrams/diagrams-pgf">github page</a>.</p><p>The backend can output LaTeX, ConTeXt or plain TeX files (PGF picture
code only or standalone TeX files) and can call <code class="sourceCode">pdflatex</code>, <code class="sourceCode">context</code>
or <code class="sourceCode">pdftex</code> to make PDF files using <span class="package"><a href="http://hackage.haskell.org/package/texrunner"><code>texrunner</code></a></span>.</p></div><div class="section" id="the-gtk-backend"><h2><generated classes="sectnum">8.9   </generated>The GTK backend</h2><p>The GTK backend, <span class="package"><a href="http://hackage.haskell.org/package/diagrams-gtk"><code>diagrams-gtk</code></a></span>, used to be part of the cairo
backend (and is still built on top of it), but has been split out into
a separate package in order to reduce the dependencies of the cairo
backend, hence making it easier to install for those who don't need
GTK support.  You can install it at the same time as the rest of the
diagrams framework by passing the <code class="sourceCode"><span class="fu">-</span>fgtk</code> flag: <code>cabal install -fgtk
diagrams</code>, or it can be installed separately later with <code>cabal
install diagrams-gtk</code>.</p><p>The GTK backend allows rendering diagrams directly to GTK windows
instead of to a file (<code class="sourceCode">defaultRender</code> and <code class="sourceCode">renderToGtk</code>).  Note that
it is possible to receive mouse clicks and then query the
corresponding location in a diagram to find out which part the user
clicked on (see <a class="reference internal" href="#using-queries">Using queries</a>).</p><p>The source code for the GTK backend can be found in the
<span class="repo"><a href="http://github.com/diagrams/diagrams-gtk"><code>diagrams-gtk</code></a></span> repository.</p></div><div class="section" id="other-backends"><h2><generated classes="sectnum">8.10   </generated>Other backends</h2><p>For a list of other backends and their status, see <a class="reference external" href="http://www.haskell.org/haskellwiki/Diagrams/Projects#Backends">the diagrams
wiki</a>.</p></div><div class="section" id="tools-for-backends"><h2><generated classes="sectnum">8.11   </generated>Tools for backends</h2><ul><li><p><code>Diagrams.Segment</code> exports a <code class="sourceCode"><span class="dt">FixedSegment</span></code> type, representing
segments which <em>do</em> have an inherent starting location. Trails and
paths can be "compiled" into lists of <code class="sourceCode"><span class="dt">FixedSegment</span></code>s with absolute
locations using <code class="sourceCode">fixTrail</code> and <code class="sourceCode">fixPath</code>.  This is of interest to
authors of rendering backends that do not support relative drawing
commands.</p></li><li><p>A test harness for comparing the outputs of different backends can be
found in the <span class="repo"><a href="http://github.com/diagrams/diagrams-backend-tests"><code>diagrams-backend-tests</code></a></span> repo; the output of the
test harness for all officially supported backends is <a class="reference external" href="http://projects.haskell.org/diagrams/backend-tests/all-index.html">kept up-to-date
here</a>.</p></li></ul></div></div><div class="section" id="other-tools"><h1><generated classes="sectnum">9   </generated>Other tools</h1><p>There are several "extra" packages which are officially maintained but
do not automatically come bundled with the <code class="sourceCode">diagrams</code> package.</p><div class="section" id="diagrams-builder"><h2><generated classes="sectnum">9.1   </generated>diagrams-builder</h2><p>The <span class="package"><a href="http://hackage.haskell.org/package/diagrams-builder"><code>diagrams-builder</code></a></span> package provides a service for <em>dynamic</em>
rendering of diagrams—that is, you hand it a <code class="sourceCode"><span class="dt">String</span></code> at runtime
representing some diagrams code, and you get back the result of
rendering the code using whatever backend you like.  This could be
useful, for example, as part of a preprocessor tool for interpreting
diagrams code embedded in some other document.  Currently it is used
by the <span class="package"><a href="http://hackage.haskell.org/package/BlogLiterately-diagrams"><code>BlogLiterately-diagrams</code></a></span> package (for rendering diagrams
embedded in blog posts) as well as <span class="package"><a href="http://hackage.haskell.org/package/diagrams-haddock"><code>diagrams-haddock</code></a></span> (for
rendering diagrams embedded in Haddock comments).</p></div><div class="section" id="diagrams-haddock"><h2><generated classes="sectnum">9.2   </generated>diagrams-haddock</h2><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams-haddock"><code>diagrams-haddock</code></a></span> is a tool for embedding diagrams in Haddock
documentation.  The idea is that you can add images (worth 1000+
words, of course) to your documentation simply by embedding diagrams
code in a special format, and then running <span class="package"><a href="http://hackage.haskell.org/package/diagrams-haddock"><code>diagrams-haddock</code></a></span>.
See the <a class="reference external" href="https://github.com/diagrams/diagrams-haddock/blob/master/README.md">README</a> for instructions on using it.</p></div><div class="section" id="svgfonts"><h2><generated classes="sectnum">9.3   </generated>SVGFonts</h2><p>The <span class="package"><a href="http://hackage.haskell.org/package/SVGFonts"><code>SVGFonts</code></a></span> provides support for reading fonts in SVG format
and rendering text to diagrams paths.  For more, see <a class="reference internal" href="#native-font-support">Native font support</a>.</p></div></div><div class="section" id="type-reference"><h1><generated classes="sectnum">10   </generated>Type reference</h1><p>This section serves as a reference in understanding the types used in
the diagrams framework.</p><div class="section" id="understanding-diagrams-types"><h2><generated classes="sectnum">10.1   </generated>Understanding diagrams types</h2><p>Let's look again at the type of <code class="sourceCode">hcat</code>, mentioned in <a class="reference internal" href="#types-and-type-classes">Types and type
classes</a>:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> hcat ::</span> (<span class="dt">Juxtaposable</span> a, <span class="dt">HasOrigin</span> a, <span class="dt">Monoid'</span> a, <span class="dt">V</span> a <span class="fu">~</span> <span class="dt">V2</span>, <span class="dt">N</span> a <span class="fu">~</span> n, <span class="dt">TypeableFloat</span> n)
<span class="ot">></span>      <span class="ot">=></span> [a] <span class="ot">-></span> a</code></pre></div></div><p>This is fairly typical of the types you will encounter when using
diagrams.  They can be intimidating at first, but with a little
practice they are not hard to read.  Let's look at the components of
this particular type from right to left:</p><ul><li><p><code class="sourceCode">[a] <span class="ot">-></span> a</code>.  This part is simple enough: it denotes a function from
a list of <code class="sourceCode">a</code>'s to a single <code class="sourceCode">a</code>.  Typically, the type to the right
of <code class="sourceCode"><span class="ot">=></span></code> will be some simple polymorphic type.</p></li><li><p><code class="sourceCode"><span class="dt">TypeableFloat</span> n</code>.  This says that the numeric type <code class="sourceCode">n</code> must behave
like a real number.  <code class="sourceCode"><span class="dt">TypeableFloat</span></code> is a type alias for the type
families <code class="sourceCode"><span class="dt">Typeable</span></code> and <code class="sourceCode"><span class="dt">RealFloat</span></code>, which imply <code class="sourceCode"><span class="dt">Real</span></code>, <code class="sourceCode"><span class="dt">Floating</span></code>,
<code class="sourceCode"><span class="dt">Fractional</span></code>,  <code class="sourceCode"><span class="dt">Num</span></code>, and <code class="sourceCode"><span class="dt">Ord</span></code>.</p></li><li><p><code class="sourceCode"><span class="dt">V</span> a <span class="fu">~</span> <span class="dt">V2</span>, <span class="dt">N</span> a <span class="fu">~</span> n</code>.  These are <a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/equality-constraints.html">type equality constraints</a>,
which say that the types <code class="sourceCode"><span class="dt">V</span> a</code> and <code class="sourceCode"><span class="dt">V2</span></code> must be equal, and that we
will refer to <code class="sourceCode"><span class="dt">N</span> a</code> with the type variable <code class="sourceCode">n</code>.  In this case <code class="sourceCode"><span class="dt">V2</span></code>
is the <a class="reference internal" href="#basic-2d-types">type of two-dimensional vectors</a>, and <code class="sourceCode"><span class="dt">V</span></code> is a <a class="reference external" href="http://www.haskell.org/haskellwiki/GHC/Type_families">type
family</a> which tells us the vector space that corresponds to a
particular type.  So <code class="sourceCode"><span class="dt">V</span> a <span class="fu">~</span> <span class="dt">V2</span></code> means "the vector space
corresponding to <code class="sourceCode">a</code> must be two-dimensional", or more informally, "<code class="sourceCode">a</code>
must be a type representing two-dimensional things".</p></li><li><p><code class="sourceCode"><span class="dt">Juxtaposable</span> a, <span class="fu">...</span></code> These are type class constraints on <code class="sourceCode">a</code>,
specifying what primitive operations <code class="sourceCode">a</code> must support in order to be
meaningfully used with <code class="sourceCode">hcat</code>.  For a complete reference on all the
type classes used by diagrams, see the next section, <a class="reference internal" href="#type-class-reference">Type class
reference</a>.</p></li></ul></div><div class="section" id="type-class-reference"><h2><generated classes="sectnum">10.2   </generated>Type class reference</h2><p>This section serves as a reference for all the type classes defined or
used by diagrams; there are quite a lot. (Some might even say too
many!)  Most, if not all, of these are also covered elsewhere, but it
is useful to have them collected all in one place.  The declaration of
each type class is shown along with a short explanation, a list of
instances, and links to further reading.</p><div class="section" id="classes-for-transforming-and-combining"><h3>Classes for transforming and combining</h3><div class="section" id="hasorigin"><h4>HasOrigin</h4><p><code class="sourceCode"><span class="dt">HasOrigin</span></code> is defined in <code>Diagrams.Core.HasOrigin</code>.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">HasOrigin</span> t <span class="kw">where</span>
<span class="ot">>   moveOriginTo ::</span> <span class="dt">Point</span> (<span class="dt">V</span> t) (<span class="dt">N</span> t) <span class="ot">-></span> t <span class="ot">-></span> t</code></pre></div></div><p><code class="sourceCode"><span class="dt">HasOrigin</span></code> classifies types with a notion of a fixed "location"
relative to some "local origin", and provides a means of moving the
local origin.  This is provided as a separate class from
<code class="sourceCode"><span class="dt">Transformable</span></code> since some things with a local origin do not support
other sorts of transformations; and contrariwise some things that
support transformations are translation-invariant (like trails and
vectors) and hence do not have a <code class="sourceCode"><span class="dt">HasOrigin</span></code> instance.</p><p>The <code class="sourceCode">moveOriginTo</code> method moves the <em>local origin</em> to the given
point.</p><p>Instances:</p><ul><li><p>The instances for <code class="sourceCode"><span class="dt">Point</span></code>, <code class="sourceCode"><span class="dt">SubMap</span></code>, <code class="sourceCode"><span class="dt">Subdiagram</span></code>, and <code class="sourceCode"><span class="dt">QDiagram</span></code>
all have the meaning you would expect.</p></li><li><p>The instances for <code class="sourceCode"><span class="dt">Trace</span></code>, <code class="sourceCode"><span class="dt">Envelope</span></code>, and <code class="sourceCode"><span class="dt">Query</span></code> all obey the
invariant that, <em>e.g.</em>, <code>getEnvelope . moveOriginTo p t ==
moveOriginTo p t . getEnvelope</code>. That is, if <code>e</code> is the
envelope/trace/query for diagram <code>d</code>, moving the origin of <code>e</code>
to <code>p</code> yields the envelope/trace/query for <code>d</code> with its origin
moved to <code>p</code>.</p></li><li><p>Container types can be translated by translating each
element (<code>(a,b)</code>, <code>[a]</code>, <code class="sourceCode"><span class="dt">Set</span></code>, <code class="sourceCode"><span class="dt">Map</span></code>).</p></li><li><p>Things wrapped in <code class="sourceCode"><span class="dt">TransInv</span></code> are not supposed to be affected by
translation, so the <code class="sourceCode"><span class="dt">TransInv</span></code> instance has <code class="sourceCode">moveOriginTo <span class="fu">=</span> const
id</code>.</p></li><li><p>The instance for <code class="sourceCode"><span class="dt">Transformation</span></code> constructs a translation and
composes it appropriately.</p></li></ul><p>Further reading: <a class="reference internal" href="#alignment">Alignment</a>.</p></div><div class="section" id="transformable"><h4>Transformable</h4><p><code class="sourceCode"><span class="dt">Transformable</span></code> is defined in <code>Diagrams.Core.Transform</code>.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">Transformable</span> t <span class="kw">where</span>
<span class="ot">>   transform ::</span> <span class="dt">Transformation</span> (<span class="dt">V</span> t) (<span class="dt">N</span> t) <span class="ot">-></span> t <span class="ot">-></span> t</code></pre></div></div><p>It represents types which support arbitrary affine transformations (or
linear transformations, in the case of translationally invariant
things).</p><p>Instances:</p><ul><li><p><code class="sourceCode"><span class="dt">Prim</span></code>, <code class="sourceCode"><span class="dt">SubMap</span></code>, <code class="sourceCode"><span class="dt">Subdiagram</span></code>, <code class="sourceCode"><span class="dt">QDiagram</span></code>: these have the meaning
you would expect.</p></li><li><p>Of course, <code class="sourceCode"><span class="dt">Transformation</span></code> is itself transformable, by composition.</p></li><li><p>Container types can be transformed by transforming each
element (<code>(t,t)</code>, <code>(t,t,t)</code>, <code>[t]</code>, <code class="sourceCode"><span class="dt">Set</span></code>, <code class="sourceCode"><span class="dt">Map</span></code>).</p></li><li><p><code>Point v n</code> is transformable whenever <code>v n</code> is; translations
actually affect points (whereas they might not have an effect on
the underlying type <code>v n</code>).</p></li><li><p>Anything wrapped in <code class="sourceCode"><span class="dt">TransInv</span></code> will not be affected by
translation.</p></li><li><p>Anything wrapped in <code class="sourceCode"><span class="dt">ScaleInv</span></code> will not be affected by scaling.
See <a class="reference internal" href="#scale-invariance">Scale-invariance</a> for more information.</p></li><li><p>Applying a transformation to a <code class="sourceCode"><span class="dt">Style</span></code>
simply applies it to every attribute.</p></li><li><p>The meaning of transforming an <code class="sourceCode"><span class="dt">Attribute</span></code> depends on the
particular attribute.</p></li><li><p>The instances for <code class="sourceCode"><span class="dt">Trace</span></code>, <code class="sourceCode"><span class="dt">Envelope</span></code>, and <code class="sourceCode"><span class="dt">Query</span></code> all obey the
invariant that, <em>e.g.</em>, <code>getEnvelope . transform t == transform t
. getEnvelope</code>. That is, if <code>e</code> is the envelope/trace/query for
diagram <code>d</code>, transforming <code>e</code> with <code>t</code> yields the
envelope/trace/query for <code>d</code> transformed by <code>t</code>.</p></li><li><p>The instance for <code class="sourceCode"><span class="dt">Deletable</span></code> simply lifts transformations on the
underlying type.</p></li><li><p>The instance for <code class="sourceCode"><span class="dt">NullPrim</span></code> does nothing, since there is nothing
to transform.</p></li><li><p>Uniform scales can be applied to <code class="sourceCode"><span class="dt">Double</span></code> and <code class="sourceCode"><span class="dt">Rational</span></code> values;
translations can also be applied but have no effect.</p></li></ul><p>Further reading: <a class="reference internal" href="#euclidean-2-space">Euclidean 2-space</a>; <a class="reference internal" href="#d-transformations">2D Transformations</a>.</p></div><div class="section" id="juxtaposable"><h4>Juxtaposable</h4><p><code class="sourceCode"><span class="dt">Juxtaposable</span></code> is defined in <code>Diagrams.Core.Juxtapose</code>.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">Juxtaposable</span> a <span class="kw">where</span>
<span class="ot">>   juxtapose ::</span> <span class="dt">Vn</span> a <span class="ot">-></span> a <span class="ot">-></span> a <span class="ot">-></span> a</code></pre></div></div><p><code class="sourceCode"><span class="dt">Juxtaposable</span></code> represents types of things which can be positioned
"next to" one another.  Note that this is more general than "having an
envelope" (though certainly any instance of <code class="sourceCode"><span class="dt">Enveloped</span></code> can be made an
instance of <code class="sourceCode"><span class="dt">Juxtaposable</span></code>, using <code class="sourceCode">juxtaposeDefault</code>).  For example,
animations are an instance of <code class="sourceCode"><span class="dt">Juxtaposable</span></code> (which corresponds to
juxtaposing them at every point in time), but not of <code class="sourceCode"><span class="dt">Enveloped</span></code>.</p><p><code class="sourceCode">juxtapose v a1 a2</code> positions <code class="sourceCode">a2</code> next to <code class="sourceCode">a1</code> in the
direction of <code class="sourceCode">v</code>.  In particular, it places <code class="sourceCode">a2</code> so that <code class="sourceCode">v</code> points
from the local origin of <code class="sourceCode">a1</code> towards the old local origin of
<code class="sourceCode">a2</code>; <code class="sourceCode">a1</code>'s local origin becomes <code class="sourceCode">a2</code>'s new local origin.  The
result is just a translated version of <code class="sourceCode">a2</code>.  (In particular,
<code class="sourceCode">juxtapose</code> does not <em>combine</em> <code class="sourceCode">a1</code> and <code class="sourceCode">a2</code> in any way.)</p><definition_list><definition_list_item><term>Instances:</term><definition><ul><li><p><code class="sourceCode"><span class="dt">QDiagram</span></code> and <code class="sourceCode"><span class="dt">Envelope</span></code> are of course instances.</p></li><li><p>Many container types are also instances, since container types
have <code class="sourceCode"><span class="dt">Enveloped</span></code> instances that work by superimposing all the
envelopes of the individual elements: <code class="sourceCode">[a]</code>, <code class="sourceCode">(a,b)</code>, <code class="sourceCode"><span class="dt">Set</span></code>, <code class="sourceCode"><span class="dt">Map</span></code></p></li></ul></definition></definition_list_item></definition_list><p>Further reading: <a class="reference internal" href="#juxtaposing-diagrams">Juxtaposing diagrams</a>; <a class="reference internal" href="#juxtaposing-without-composing">Juxtaposing without composing</a>.</p></div><div class="section" id="enveloped"><h4>Enveloped</h4><p><code class="sourceCode"><span class="dt">Enveloped</span></code> is defined in <code>Diagrams.Core.Envelope</code>.  It
classifies types which have an associated <code class="sourceCode"><span class="dt">Envelope</span></code>.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> (<span class="dt">InnerSpace</span> (<span class="dt">V</span> a), <span class="dt">OrderedField</span> (<span class="dt">N</span> a)) <span class="ot">=></span> <span class="dt">Enveloped</span> a <span class="kw">where</span>
<span class="ot">>   getEnvelope ::</span> a <span class="ot">-></span> <span class="dt">Envelope</span> (<span class="dt">V</span> a) (<span class="dt">N</span> a)</code></pre></div></div><p>The <code class="sourceCode">getEnvelope</code> method simply computes or projects out its
argument's associated <code class="sourceCode"><span class="dt">Envelope</span></code>.  <code class="sourceCode"><span class="dt">InnerSpace</span></code>, defined in
<code>Data.VectorSpace</code>, classifies vector spaces with an inner (dot)
product.  Computing envelopes almost always involves projection of one
vector onto another, which requires an inner product.  The
<code class="sourceCode"><span class="dt">OrderedField</span></code> class is simply a synonym for a collection of classes,
requiring that the scalar type have multiplicative inverses and be
linearly ordered.  See <a class="reference internal" href="#orderedfield">OrderedField</a>.</p><definition_list><definition_list_item><term>Instances:</term><definition><ul><li><p>The instance for <code class="sourceCode"><span class="dt">QDiagram</span></code> does what you would expect.</p></li><li><p>The instance for <code class="sourceCode"><span class="dt">Subdiagram</span></code> yields an envelope positioned
relative to the parent diagram.</p></li><li><p>Every <code class="sourceCode"><span class="dt">Point</span></code> has a "point envelope" consisting of the constantly
zero envelope translated to the given point.  Note this is not the
same as the empty envelope.</p></li><li><p>Many container types have instances which work by combining all
the envelopes of the individual elements: <code class="sourceCode">[a]</code>, <code class="sourceCode">(a,b)</code>, <code class="sourceCode"><span class="dt">Set</span></code>,
<code class="sourceCode"><span class="dt">Map</span></code>.</p></li></ul></definition></definition_list_item></definition_list><p>Further reading: <a class="reference internal" href="#envelopes-and-local-vector-spaces">Envelopes and local vector spaces</a>; <a class="reference internal" href="#envelopes">Envelopes</a>.</p></div><div class="section" id="traced"><h4>Traced</h4><p><code class="sourceCode"><span class="dt">Traced</span></code> is defined in <code>Diagrams.Core.Trace</code>, and plays a similar
role as <code class="sourceCode"><span class="dt">Enveloped</span></code>.  <code class="sourceCode"><span class="dt">Traced</span></code> types have an associated <code class="sourceCode"><span class="dt">Trace</span></code>, which
is like an embedded ray tracer that can be used to find points on
edges of an object.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> (<span class="dt">Ord</span> (<span class="dt">N</span> a), <span class="dt">Additive</span> (<span class="dt">V</span> a)) <span class="ot">=></span> <span class="dt">Traced</span> a <span class="kw">where</span>
<span class="ot">>   getTrace ::</span> a <span class="ot">-></span> <span class="dt">Trace</span> (<span class="dt">V</span> a) (<span class="dt">N</span> a)</code></pre></div></div><p>Instances:</p><ul><li><p>The instance for <code class="sourceCode"><span class="dt">QDiagram</span></code> does what you would expect.</p></li><li><p>The instance for <code class="sourceCode"><span class="dt">Subdiagram</span></code> yields a trace positioned
relative to the parent diagram.</p></li><li><p>The trace of a <code class="sourceCode"><span class="dt">Point</span></code> is the empty trace.</p></li><li><p>Many container types have instances which work by combining all
the envelopes of the individual elements: <code class="sourceCode">[a]</code>, <code class="sourceCode">(a,b)</code>, <code class="sourceCode"><span class="dt">Set</span></code>,
<code class="sourceCode"><span class="dt">Map</span></code>.</p></li></ul><p>Further reading: <a class="reference internal" href="#traces">Traces</a>.</p></div><div class="section" id="hasquery"><h4>HasQuery</h4><p><code class="sourceCode"><span class="dt">HasQuery</span></code> is defined in <code>Diagrams.Query</code>, and governs types with
an associated <code class="sourceCode"><span class="dt">Query</span></code>.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">HasQuery</span> t m <span class="fu">|</span> t <span class="ot">-></span> m <span class="kw">where</span>
<span class="ot">></span>   <span class="co">-- | Extract the query of an object.</span>
<span class="ot">>   getQuery ::</span> t <span class="ot">-></span> <span class="dt">Query</span> (<span class="dt">V</span> t) (<span class="dt">N</span> t) m</code></pre></div></div><p>Further reading: <a class="reference internal" href="#generalized-queries">Generalized queries</a>.</p></div></div><div class="section" id="classes-for-attributes-and-styles"><h3>Classes for attributes and styles</h3><div class="section" id="attributeclass"><h4>AttributeClass</h4><p><code class="sourceCode"><span class="dt">AttributeClass</span></code>, defined in <code>Diagrams.Core.Style</code>, is simply a
proxy for <code class="sourceCode"><span class="dt">Typeable</span></code> and <code class="sourceCode"><span class="dt">Semigroup</span></code>; it has no methods.  Any type
used as an attribute must be made a member of this class.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> (<span class="dt">Typeable</span> a, <span class="dt">Semigroup</span> a) <span class="ot">=></span> <span class="dt">AttributeClass</span> a</code></pre></div></div><p>Instances: many; see <code>Diagrams.Attributes</code> and
<code>Diagrams.TwoD.Path</code>.</p><p>Further reading: <a class="reference internal" href="#attributes-and-styles">Attributes and styles</a>; <a class="reference internal" href="#text">Text</a>.</p></div><div class="section" id="hasstyle"><h4>HasStyle</h4><p><code class="sourceCode"><span class="dt">HasStyle</span></code>, also defined in <code>Diagrams.Core.Style</code>, classifies
things to which a <code class="sourceCode"><span class="dt">Style</span></code> can be applied.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">HasStyle</span> a <span class="kw">where</span>
<span class="ot">>   applyStyle ::</span> <span class="dt">Style</span> (<span class="dt">V</span> a) (<span class="dt">N</span> a) <span class="ot">-></span> a <span class="ot">-></span> a</code></pre></div></div><p><code class="sourceCode">applyStyle</code> applies the given <code class="sourceCode"><span class="dt">Style</span></code> to an object, combining it on
the left with the existing <code class="sourceCode"><span class="dt">Style</span></code> (according to the <code class="sourceCode"><span class="dt">Monoid</span></code> instance
of <code class="sourceCode"><span class="dt">Style</span></code>).</p><p>Instances:</p><ul><li><p><code class="sourceCode"><span class="dt">Style</span></code> itself is an instance.</p></li><li><p>Many container types are instances as long as their elements are;
applying a style to a container simply applies the style uniformly
to every element: <code class="sourceCode">(a,b)</code>, <code class="sourceCode"><span class="dt">Map</span> k a</code>, <code class="sourceCode"><span class="dt">Set</span></code>, <code class="sourceCode">[a]</code>.</p></li><li><p>Functions <code class="sourceCode">(b <span class="ot">-></span> a)</code> are an instance as long as <code class="sourceCode">a</code> is.  (This can
also be thought of as a "container type".)</p></li><li><p>Of course, <code class="sourceCode"><span class="dt">QDiagram</span> b v m</code> is an instance, given a few
restrictions on <code class="sourceCode">v</code> and <code class="sourceCode">m</code>.</p></li></ul><p>Further reading: <a class="reference internal" href="#attributes-and-styles">Attributes and styles</a>; <a class="reference internal" href="#text">Text</a>.</p></div></div><div class="section" id="classes-for-names"><h3>Classes for names</h3><div class="section" id="isname"><h4>IsName</h4><p><code class="sourceCode"><span class="dt">IsName</span></code> is defined in <code>Diagrams.Core.Names</code>. It simply provides
the <code class="sourceCode">toName</code> method for converting to <code class="sourceCode"><span class="dt">Name</span></code>, with a default
implementation that wraps up a value as an atomic name.  It allows
values of arbitrary types to be used as names for subdiagrams.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> (<span class="dt">Typeable</span> a, <span class="dt">Ord</span> a, <span class="dt">Show</span> a) <span class="ot">=></span> <span class="dt">IsName</span> a <span class="kw">where</span>
<span class="ot">>   toName ::</span> a <span class="ot">-></span> <span class="dt">Name</span>
<span class="ot">></span>   toName <span class="fu">=</span> <span class="dt">Name</span> <span class="fu">.</span> (<span class="fu">:</span>[]) <span class="fu">.</span> <span class="dt">AName</span></code></pre></div></div><p>Instances:</p><ul><li><p>Many primitive types such as <code class="sourceCode">()</code>, <code class="sourceCode"><span class="dt">Bool</span></code>, <code class="sourceCode"><span class="dt">Char</span></code>, <code class="sourceCode"><span class="dt">Int</span></code>, <code class="sourceCode"><span class="dt">Float</span></code>,
<code class="sourceCode"><span class="dt">Double</span></code>, <code class="sourceCode"><span class="dt">Integer</span></code>, <code class="sourceCode"><span class="dt">String</span></code>, <code class="sourceCode">[a]</code>, <code class="sourceCode">(a,b)</code>, <code class="sourceCode">(a,b,c)</code> have a
default <code class="sourceCode"><span class="dt">IsName</span></code> instance.</p></li><li><p><code class="sourceCode"><span class="dt">AName</span></code> is an instance; converting an atomic name to <code class="sourceCode"><span class="dt">Name</span></code> works
by creating a singleton list.</p></li><li><p><code class="sourceCode"><span class="dt">Name</span></code> is an instance, with <code class="sourceCode">toName</code> as the identity function.</p></li></ul><p>Further reading: <a class="reference internal" href="#stroking-trails-and-paths">Stroking trails and paths</a>; <a class="reference internal" href="#named-subdiagrams">Named subdiagrams</a>;
<a class="reference internal" href="#user-defined-names">User-defined names</a>.</p></div><div class="section" id="qualifiable"><h4>Qualifiable</h4><p><code class="sourceCode"><span class="dt">Qualifiable</span></code> is also defined in <code>Diagrams.Core.Names</code>. Instances
of <code class="sourceCode"><span class="dt">Qualifiable</span></code> are things which can be "qualified" by prefixing them
with a name.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">Qualifiable</span> q <span class="kw">where</span>
<span class="ot">></span>   <span class="co">-- | Qualify with the given name.</span>
<span class="ot">>   (.>>) ::</span> <span class="dt">IsName</span> a <span class="ot">=></span> a <span class="ot">-></span> q <span class="ot">-></span> q</code></pre></div></div><p>Instances:</p><ul><li><p><code class="sourceCode"><span class="dt">Name</span></code>: qualifying one name with another is just concatenation.</p></li><li><p><code class="sourceCode"><span class="dt">SubMap</span></code> and <code class="sourceCode"><span class="dt">QDiagram</span></code>: qualifying prefixes a name on all the
existing names.</p></li></ul><p>Further reading: <a class="reference internal" href="#named-subdiagrams">Named subdiagrams</a>; <a class="reference internal" href="#subdiagrams">Subdiagrams</a>; <a class="reference internal" href="#qualifying-names">Qualifying
names</a>.</p></div></div><div class="section" id="classes-for-trails-and-paths"><h3>Classes for trails and paths</h3><div class="section" id="id22"><h4>TrailLike</h4><p>The <code class="sourceCode"><span class="dt">TrailLike</span></code> class, defined in <code>Diagrams.TrailLike</code>, abstracts
over things that are "trail-like", so that functions such as <code class="sourceCode">square</code>
can be used to construct a diagram, a path, a trail, <em>etc.</em>.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> (<span class="dt">Metric</span> (<span class="dt">V</span> t), <span class="dt">OrderedField</span> (<span class="dt">N</span> t)) <span class="ot">=></span> <span class="dt">TrailLike</span> t <span class="kw">where</span>
<span class="ot">></span>
<span class="ot">></span>   trailLike
<span class="ot">>     ::</span> <span class="dt">Located</span> (<span class="dt">Trail</span> (<span class="dt">V</span> t) (<span class="dt">N</span> t))  <span class="co">-- ^ The concretely located trail.  Note</span>
<span class="ot">></span>                                     <span class="co">--   that some trail-like things</span>
<span class="ot">></span>                                     <span class="co">--   (e.g. 'Trail's) may ignore the</span>
<span class="ot">></span>                                     <span class="co">--   location.</span>
<span class="ot">></span>     <span class="ot">-></span> t</code></pre></div></div><p>The <code class="sourceCode">trailLike</code> method provides a generic way to build a "trail-like"
thing by specifying the low-level trail data.  Note that there should
usually not be any need for end users to call <code class="sourceCode">trailLike</code> directly
(though there certainly may be some use cases).</p><p>Instances:</p><ul><li><p><code class="sourceCode"><span class="dt">Trail</span></code>: this instance simply throws away the location.</p></li><li><p><code class="sourceCode"><span class="dt">Trail'</span> <span class="dt">Line</span></code>: throw away the location, and perform <code class="sourceCode">cutLoop</code> if
necessary.  For example, <code class="sourceCode">circle <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Trail'</span> <span class="dt">Line</span> <span class="dt">V2</span> <span class="dt">Double</span></code> is an open \(360^\circ\)
circular arc.</p></li><li><p><code class="sourceCode"><span class="dt">Trail'</span> <span class="dt">Loop</span></code>: throw away the location, and perform <code class="sourceCode">glueLine</code> if
necessary.</p></li><li><p><code class="sourceCode"><span class="dt">Path</span></code>: construct a path with a single component.</p></li><li><p><code class="sourceCode"><span class="dt">Diagram</span> b <span class="dt">V2</span> <span class="dt">Double</span></code>: as long as the backend <code class="sourceCode">b</code> knows how to render 2D
paths, <code class="sourceCode">trailLike</code> can construct a diagram by stroking the generated
single-component path.</p></li><li><p><code class="sourceCode">[<span class="dt">Point</span> v]</code>: this instance generates the vertices of the trail.</p></li><li><p><code class="sourceCode"><span class="dt">Located</span> (<span class="dt">Trail</span> v)</code>, of course, has an instance which amounts to the
identity function.  More generally, however, <code class="sourceCode"><span class="dt">Located</span> a</code> is an
instance of <code class="sourceCode"><span class="dt">TrailLike</span></code> for <em>any</em> type <code class="sourceCode">a</code> which is also an
instance.  In particular, the resulting <code class="sourceCode"><span class="dt">Located</span> a</code> has the location
of the input <code class="sourceCode"><span class="dt">Located</span> <span class="dt">Trail</span></code>, and a value of type <code class="sourceCode">a</code> generated by
another call to <code class="sourceCode">trailLike</code>.  This is most useful for generating
values of type <code class="sourceCode"><span class="dt">Located</span> (<span class="dt">Trail'</span> <span class="dt">Line</span> v <span class="dt">Doubl</span>)</code> and <code class="sourceCode"><span class="dt">Located</span> (<span class="dt">Trail'</span> <span class="dt">Loop</span>
v)</code>.  For example, <code class="sourceCode">circle <span class="dv">3</span> <span class="fu">#</span> translateX <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Located</span> (<span class="dt">Trail'</span> <span class="dt">Line</span>
<span class="dt">V2</span> <span class="dt">Double</span>)</code> is an open \(360^\circ\) circular arc centered at
\((2,0)\).</p></li><li><p><code class="sourceCode"><span class="dt">Active</span> t</code> (for any <code class="sourceCode"><span class="dt">TrailLike</span> p</code>): creates a constant <code class="sourceCode"><span class="dt">Active</span></code>
value.</p></li></ul><p>Further reading: <a class="reference internal" href="#trails-and-paths">Trails and paths</a>; <a class="reference internal" href="#trails">Trails</a>;
<a class="reference internal" href="#paths">Paths</a>; <a class="reference internal" href="#traillike">TrailLike</a>.</p></div><div class="section" id="topath"><h4>ToPath</h4><p>The <code class="sourceCode"><span class="dt">ToPath</span></code> class, defined in <code>Diagrams.Path</code>, abstracts
over things that can be converted to a <code class="sourceCode"><span class="dt">Path</span></code>.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">ToPath</span> t <span class="kw">where</span>
<span class="ot">>   toPath ::</span> (<span class="dt">Metric</span> (<span class="dt">V</span> t), <span class="dt">OrderedField</span> (<span class="dt">N</span> t))
<span class="ot">></span>          <span class="ot">=></span> t <span class="ot">-></span> <span class="dt">Path</span> (<span class="dt">V</span> t) (<span class="dt">N</span> t)</code></pre></div></div><p>If you have a path, trail, line, loop, <em>etc.</em> with a definite type,
you can apply <code class="sourceCode">toPath</code> to convert it into a path.  A function</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> stroke
<span class="ot">>   ::</span> ( <span class="dt">Renderable</span> (<span class="dt">Path</span> <span class="dt">V2</span> (<span class="dt">N</span> t)) b, <span class="dt">ToPath</span> t
<span class="ot">></span>      , <span class="dt">Data.Typeable.Internal.Typeable</span> (<span class="dt">N</span> t), <span class="dt">RealFloat</span> (<span class="dt">N</span> t)
<span class="ot">></span>      , <span class="dt">V</span> t <span class="fu">~</span> <span class="dt">V2</span>
<span class="ot">></span>      )
<span class="ot">></span>   <span class="ot">=></span> t <span class="ot">-></span> <span class="dt">QDiagram</span> b <span class="dt">V2</span> (<span class="dt">N</span> t) <span class="dt">Any</span></code></pre></div></div><p>is also provided, which works by first converting its argument to a
<code class="sourceCode"><span class="dt">Path</span></code> using <code class="sourceCode">toPath</code>, and then calling <code class="sourceCode">strokePath</code> on the result.
This can be convenient if you have something of a definite type which
you want to turn into a diagram; on the other hand, if you have
something polymorphic it may be more convenient to use a
type-specialized function like <code class="sourceCode">strokeLine</code> to fix its type.</p><p>Instances:</p><ul><li><p><code class="sourceCode"><span class="dt">ToPath</span> a <span class="ot">=></span> <span class="dt">ToPath</span> [a]</code></p></li><li><p><code class="sourceCode"><span class="dt">Trail</span> v n</code></p></li><li><p><code class="sourceCode"><span class="dt">Path</span> v n</code></p></li><li><p><code class="sourceCode"><span class="dt">Located</span> (<span class="dt">Trail</span> v n)</code></p></li><li><p><code class="sourceCode"><span class="dt">Located</span> (<span class="dt">Trail'</span> l v n)</code></p></li><li><p><code class="sourceCode"><span class="dt">Located</span> (<span class="dt">Segment</span> <span class="dt">Closed</span> v n)</code></p></li><li><p><code class="sourceCode"><span class="dt">Located</span> [<span class="dt">Segment</span> <span class="dt">Closed</span> v n]</code></p></li><li><p><code class="sourceCode"><span class="dt">FixedSegment</span> v n</code></p></li></ul></div></div><div class="section" id="classes-for-parametric-objects"><h3>Classes for parametric objects</h3><p><code>Diagrams.Parametric</code> provides a set of classes for working with
objects which can be viewed as parametric functions, such as segments
and trails: <code class="sourceCode"><span class="dt">Parametric</span></code>, <code class="sourceCode"><span class="dt">DomainBounds</span></code>, <code class="sourceCode"><span class="dt">EndValues</span></code>, <code class="sourceCode"><span class="dt">Sectionable</span></code>,
and <code class="sourceCode"><span class="dt">HasArcLength</span></code>.  These classes are fairly specialized and do not
really show up anywhere else; see the section on <a class="reference internal" href="#segments-and-trails-as-parametric-objects">Segments and trails
as parametric objects</a> for more information.</p></div><div class="section" id="classes-for-backends"><h3>Classes for backends</h3><div class="section" id="backend"><h4>Backend</h4><p>The <code class="sourceCode"><span class="dt">Backend</span></code> class, defined in <code>Diagrams.Core.Types</code>, defines
the primary interface for any diagrams rendering backend.  Unlike many
of the other type classes in diagrams, it is quite large.  For a full
discussion, see the <a class="reference external" href="core.html">core library reference</a>.</p></div><div class="section" id="multibackend"><h4>MultiBackend</h4><p><code class="sourceCode"><span class="dt">MultiBackend</span></code>, also defined in <code>Diagrams.Core.Types</code>, is for
backends which support rendering multiple diagrams, for example to a
multi-page pdf or something similar.  It simply provides the
<code class="sourceCode">renderDias</code> function for rendering multiple diagrams at once; the
meaning of this function depends on the backend.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">Backend</span> b v n <span class="ot">=></span> <span class="dt">MultiBackend</span> b v n <span class="kw">where</span>
<span class="ot">>   renderDias ::</span> (<span class="dt">Metric</span> v, <span class="dt">OrderedField</span> n, <span class="dt">Monoid'</span> m)
<span class="ot">></span>              <span class="ot">=></span> b <span class="ot">-></span> <span class="dt">Options</span> b v n <span class="ot">-></span> [<span class="dt">QDiagram</span> b v n m] <span class="ot">-></span> <span class="dt">Result</span> b v n</code></pre></div></div><p>So far, the only backend which supports multi-diagram rendering is
the <a class="reference external" href="http://hackage.haskell.org/package/diagrams-postscript/">postscript backend</a>.</p><p>Further reading: <a class="reference internal" href="#rendering-backends">Rendering backends</a>.</p></div><div class="section" id="renderable"><h4>Renderable</h4><p>The <code class="sourceCode"><span class="dt">Renderable</span></code> type class (from <code>Diagrams.Core.Types</code>) is a
two-parameter type class connecting backends to primitives which they
know how to render.  Backend <code class="sourceCode"><span class="dt">B</span></code> declares that it knows how to draw
primitive <code class="sourceCode"><span class="dt">P</span></code> by giving a <code class="sourceCode"><span class="dt">Renderable</span> <span class="dt">P</span> <span class="dt">B</span></code> instance, which requires
implementing the <code class="sourceCode">render</code> function which takes a primitive and renders
it.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">Transformable</span> t <span class="ot">=></span> <span class="dt">Renderable</span> t b <span class="kw">where</span>
<span class="ot">>   render ::</span> b <span class="ot">-></span> t <span class="ot">-></span> <span class="dt">Render</span> b (<span class="dt">V</span> t) (<span class="dt">N</span> t)</code></pre></div></div><p>Instances: There are many instances defined by each backend.</p><p>Further reading: <a class="reference internal" href="#rendering-backends">Rendering backends</a>.</p></div><div class="section" id="toresult"><h4>ToResult</h4><p>The <code class="sourceCode"><span class="dt">ToResult</span></code> class (from <code>Diagrams.Backend.CmdLine</code>)
essentially defines a very generic form of uncurrying.  It is used to
implement the general interface for building command-line-driven
diagram generation programs, and in particular to enable building
executables out of (curried) functions, which requires collecting up
all their arguments at once.  See the <a class="reference external" href="cmdline.html">command-line tutorial</a> for more.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">ToResult</span> d <span class="kw">where</span>
<span class="ot">></span>     <span class="kw">type</span> <span class="dt">Args</span><span class="ot"> d ::</span> <span class="fu">*</span>
<span class="ot">></span>     <span class="kw">type</span> <span class="dt">ResultOf</span><span class="ot"> d ::</span> <span class="fu">*</span>
<span class="ot">></span>
<span class="ot">>     toResult ::</span> d <span class="ot">-></span> <span class="dt">Args</span> d <span class="ot">-></span> <span class="dt">ResultOf</span> d</code></pre></div></div><p>The most interesting instance is the one for functions:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">instance</span> <span class="dt">ToResult</span> d <span class="ot">=></span> <span class="dt">ToResult</span> (a <span class="ot">-></span> d) <span class="kw">where</span>
<span class="ot">></span>     <span class="kw">type</span> <span class="dt">Args</span> (a <span class="ot">-></span> d) <span class="fu">=</span> (a, <span class="dt">Args</span> d)
<span class="ot">></span>     <span class="kw">type</span> <span class="dt">ResultOf</span> (a <span class="ot">-></span> d) <span class="fu">=</span> <span class="dt">ResultOf</span> d
<span class="ot">></span>
<span class="ot">></span>     toResult f (a,args) <span class="fu">=</span> toResult (f a) args</code></pre></div></div></div><div class="section" id="parseable"><h4>Parseable</h4><p>The <code class="sourceCode"><span class="dt">Parseable</span></code> class (<code>Diagrams.Backend.CmdLine</code>) contains just
one method, <code class="sourceCode"><span class="ot">parser ::</span> <span class="dt">Parser</span> a</code>, which defines a command-line parser
for a given type.  Things with <code class="sourceCode"><span class="dt">Parseable</span></code> instances can be used in
conjunction with the command-line creation framework.  See the
<a class="reference external" href="cmdline.html">command-line tutorial</a> for more.</p></div><div class="section" id="mainable"><h4>Mainable</h4><p>The <code class="sourceCode"><span class="dt">Mainable</span></code> class (<code>Diagrams.Backend.CmdLine</code>) governs types
which can be used to build a command-line-driven diagram-generation
program.  For example, a diagram; but also animations, lists of
diagrams, association lists of strings and diagrams, and functions
from parseable things to any of the above.  See the <a class="reference external" href="cmdline.html">command-line
tutorial</a> for more.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> <span class="dt">Mainable</span> d <span class="kw">where</span>
<span class="ot">></span>     <span class="kw">type</span> <span class="dt">MainOpts</span><span class="ot"> d ::</span> <span class="fu">*</span>
<span class="ot">></span>
<span class="ot">>     mainArgs   ::</span> <span class="dt">Parseable</span> (<span class="dt">MainOpts</span> d) <span class="ot">=></span> d <span class="ot">-></span> <span class="dt">IO</span> (<span class="dt">MainOpts</span> d)
<span class="ot">>     mainRender ::</span> <span class="dt">MainOpts</span> d <span class="ot">-></span> d <span class="ot">-></span> <span class="dt">IO</span> ()
<span class="ot">>     mainWith   ::</span> <span class="dt">Parseable</span> (<span class="dt">MainOpts</span> d) <span class="ot">=></span> d <span class="ot">-></span> <span class="dt">IO</span> ()</code></pre></div></div></div></div><div class="section" id="poor-man-s-type-synonyms"><h3>Poor man's type synonyms</h3><p>There are several cases where a certain set of type class constraints
are used together so often that it is convenient to define a synonym
to stand in for the entire set of constraints.  In more recent
versions of GHC that support the <code>ConstraintKinds</code> extension, this
could be accomplished with a simple type synonym.  However, since
diagrams still supports older versions of GHC, these are declared as a
new type class with no methods and a single universal instance.  For
example,</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">class</span> (<span class="dt">Class1</span> a, <span class="dt">Class2</span> a, <span class="dt">Class3</span> a) <span class="ot">=></span> <span class="dt">Synonym</span> a
<span class="ot">></span> <span class="kw">instance</span> (<span class="dt">Class1</span> a, <span class="dt">Class2</span> a, <span class="dt">Class3</span> a) <span class="ot">=></span> <span class="dt">Synonym</span> a</code></pre></div></div><p>Ideally, at some point in the future diagrams will drop support for
versions of GHC without <code>ConstraintKinds</code> and switch to the more
sensible way of defining constraint synonyms.</p><div class="section" id="id27"><h4>Monoid'</h4><p><code class="sourceCode"><span class="dt">Monoid'</span> m</code> is a synonym for</p><blockquote><p><code class="sourceCode">(<span class="dt">Semigroup</span> m, <span class="dt">Monoid</span> m)</code>,</p></blockquote><p>defined in <code>Diagrams.Core</code>. This is something of an unfortunate
hack: although every monoid is a semigroup mathematically speaking,
<code class="sourceCode"><span class="dt">Semigroup</span></code> is not actually a superclass of <code class="sourceCode"><span class="dt">Monoid</span></code>, so if we want to
use both we have to actually declare both.</p></div><div class="section" id="hasbasis"><h4>HasBasis</h4><p><code class="sourceCode"><span class="dt">HasBasis</span> v</code> is a synonym for</p><blockquote><p><code class="sourceCode">(<span class="dt">Representable</span> v, <span class="dt">Rep</span> v <span class="fu">~</span> <span class="dt">E</span> v)</code>,</p></blockquote><p>which is used to get access to the basis elements of a vector.</p></div><div class="section" id="haslinearmap"><h4>HasLinearMap</h4><p><code class="sourceCode"><span class="dt">HasLinearMap</span> v</code> is a synonym for</p><blockquote><p><code class="sourceCode">(<span class="dt">Additive</span> v, <span class="dt">Applicative</span> v, <span class="dt">Traversable</span> v)</code>,</p></blockquote><p>which is used for many of the functions related to transforms.</p></div><div class="section" id="orderedfield"><h4>OrderedField</h4><p><code class="sourceCode"><span class="dt">OrderedField</span> s</code>, defined in <code>Diagrams.Core.Envelope</code>, is a
synonym for</p><blockquote><p><code class="sourceCode">(<span class="dt">Floating</span> s, <span class="dt">Ord</span> s)</code>,</p></blockquote><p><em>i.e.</em> a floating-point type which is totally ordered.  When dealing
with <code class="sourceCode"><span class="dt">Envelopes</span></code> it's often necessary to have scalars which support
all four arithmetic operations as well as square root, and can be
compared for ordering.</p></div><div class="section" id="typeablefloat"><h4>TypeableFloat</h4><p><code class="sourceCode"><span class="dt">TypeableFloat</span> n</code>, defined in <code>Diagrams.Core.Types</code>, is a synonym for</p><blockquote><p><code class="sourceCode">(<span class="dt">Typeable</span> n, <span class="dt">RealFloat</span> n)</code></p></blockquote><p>which implies <code class="sourceCode">(<span class="dt">Real</span> n, <span class="dt">Floating</span> n, <span class="dt">Fractional</span> n, <span class="dt">Num</span> n, <span class="dt">Ord</span> n)</code>.
These constraints are needed on many functions that produce diagrams,
due to constraints on transformations and attributes.</p></div><div class="section" id="datafloat"><h4>DataFloat</h4><p><code class="sourceCode"><span class="dt">DataFloat</span> n</code> is the same as <code class="sourceCode"><span class="dt">TypeableFloat</span> n</code>, but strengthens the
<code class="sourceCode"><span class="dt">Typeable</span></code> constraint to <code class="sourceCode"><span class="dt">Data</span></code>.</p></div><div class="section" id="inspace"><h4>InSpace</h4><p><code class="sourceCode"><span class="dt">InSpace</span> v n a</code> is a synonym for <code class="sourceCode">(<span class="dt">V</span> a <span class="fu">~</span> v, <span class="dt">N</span> a <span class="fu">~</span> n, <span class="dt">Additive</span> v, <span class="dt">Num</span> n)</code>.
That is, the type <code class="sourceCode">a</code> belongs to the vector space <code class="sourceCode">v n</code>, where <code class="sourceCode">v</code> is
<code class="sourceCode"><span class="dt">Additive</span></code> and <code class="sourceCode">n</code> is a <code class="sourceCode"><span class="dt">Num</span></code>.</p></div><div class="section" id="samespace"><h4>SameSpace</h4><p><code class="sourceCode"><span class="dt">SameSpace</span> a b</code> is a synonym for <code class="sourceCode">(<span class="dt">V</span> a <span class="fu">~</span> <span class="dt">V</span> b, <span class="dt">N</span> a <span class="fu">~</span> <span class="dt">N</span> b)</code>, that is,
the types <code class="sourceCode">a</code> and <code class="sourceCode">b</code> belong to the same vector space <code class="sourceCode">v n</code>.</p></div></div></div><div class="section" id="type-family-reference"><h2><generated classes="sectnum">10.3   </generated>Type family reference</h2><p><em>Type families</em> are a GHC extension to Haskell enabling "type-level
functions".  You can <a class="reference external" href="http://www.haskell.org/haskellwiki/GHC/Type_families">read about them in detail here</a>, but
understanding them enough to use them as they arise in diagrams is not
anywhere near as complicated as that page might suggest.  Simply put,
type families are functions which can take types as input and produce
other types as output.  Of course, in one sense any polymorphic type
constructor already does this: for example, <code class="sourceCode"><span class="dt">Maybe</span></code> takes types as
input (say, <code class="sourceCode"><span class="dt">Int</span></code>) and produces types as output (say, <code class="sourceCode"><span class="dt">Maybe</span> <span class="dt">Int</span></code>).
The difference is that <code class="sourceCode"><span class="dt">Maybe</span></code> works <em>uniformly</em> for all input types
(it does not, indeed cannot, do anything "different" for <code class="sourceCode"><span class="dt">Char</span></code> than
it does for <code class="sourceCode"><span class="dt">Int</span></code>).  Type families, on the other hand, can have a
specific definition for each input type (much as type class methods
can have a different implementation for each instance type).  For
example, the following (admittedly contrived) example declares a type
family named <code class="sourceCode"><span class="dt">Foo</span></code>, with two definition clauses.</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">type</span> family <span class="dt">Foo</span><span class="ot"> a ::</span> <span class="fu">*</span>
<span class="ot">></span> <span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Foo</span> <span class="dt">Int</span>  <span class="fu">=</span> <span class="dt">Int</span>
<span class="ot">></span> <span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Foo</span> <span class="dt">Char</span> <span class="fu">=</span> [<span class="dt">String</span>]</code></pre></div></div><p>Diagrams only makes use of a few type families, though two of them
(<code class="sourceCode"><span class="dt">V</span></code> and <code class="sourceCode"><span class="dt">N</span></code>) are used quite extensively.  The following sections
list each of the type families employed by diagrams.</p><div class="section" id="v"><h3>V</h3><p>The <code class="sourceCode"><span class="dt">V</span></code> type family is defined in <code class="sourceCode"><span class="dt">Diagrams.Core.V</span></code>.  The idea is that
many types have an "associated" vector space, <em>i.e.</em> the vector space
in which they "live".  The vector space is described by its dimension
and its numeric type.  <code class="sourceCode"><span class="dt">V</span></code> simply maps from types to a type
representing the vector space dimension.  For example, <code class="sourceCode"><span class="dt">V</span> (<span class="dt">Path</span> <span class="dt">V2</span>
<span class="dt">Double</span>) <span class="fu">=</span> <span class="dt">V2</span></code> (ordinary two-dimensional paths live in <code class="sourceCode"><span class="dt">V2</span> <span class="dt">Double</span></code>),
and <code class="sourceCode"><span class="dt">V</span> [a] <span class="fu">=</span> <span class="dt">V</span> a</code> (lists of <code class="sourceCode">a</code>'s live in whatever vector space
<code class="sourceCode">a</code>'s themselves live in).</p><p>Often, <code class="sourceCode"><span class="dt">V</span></code> shows up in a constraint on the left hand side of <code class="sourceCode"><span class="ot">=></span></code>, as
in</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> alignT ::</span> (<span class="dt">Alignable</span> a, <span class="dt">HasOrigin</span> a, <span class="dt">V</span> a <span class="fu">~</span> <span class="dt">V2</span>, <span class="dt">N</span> a <span class="fu">~</span> n, <span class="dt">Floating</span> n) <span class="ot">=></span> a <span class="ot">-></span> a</code></pre></div></div><p>This type says that <code class="sourceCode">alignT</code> can be applied to values of any type <code class="sourceCode">a</code>,
<em>as long as</em> <code class="sourceCode">a</code> is an instance of <code class="sourceCode"><span class="dt">Alignable</span></code>, and <code class="sourceCode">a</code> lives in the
vector space <code class="sourceCode"><span class="dt">V2</span></code>, that is, <code class="sourceCode"><span class="dt">V</span> a <span class="fu">~</span> <span class="dt">V2</span></code> (the tilde expresses a <em>type
equality constraint</em>).</p><p>Other times, <code class="sourceCode"><span class="dt">V</span></code> can show up on the right-hand side of <code class="sourceCode"><span class="ot">=></span></code>, as in</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> deform ::</span> <span class="dt">Deformation</span> (<span class="dt">V</span> a) (<span class="dt">N</span> a) <span class="ot">-></span> a <span class="ot">-></span> a</code></pre></div></div><p>This says that <code class="sourceCode">deform</code> takes two arguments: a <code class="sourceCode"><span class="dt">Deformation</span></code> and a
value of some type <code class="sourceCode">a</code>.  However, <code class="sourceCode"><span class="dt">Deformations</span></code>s are parameterized
by a vector space; <code class="sourceCode"><span class="dt">Deformation</span> (<span class="dt">V</span> a) (<span class="dt">N</span> a)</code> means that the vector
space of the deformation is the vector space associated to <code class="sourceCode">a</code>.  Many
types in diagrams are parameterized this way, by <code class="sourceCode">v</code> and <code class="sourceCode">n</code>
parameters which together define a vector space.</p></div><div class="section" id="n"><h3>N</h3><p>The <code class="sourceCode"><span class="dt">N</span></code> type family is defined in <code>Diagrams.Core.V</code>.  Whereas <code class="sourceCode"><span class="dt">V</span></code>
describes the <em>dimension</em> of a vector space, <code class="sourceCode"><span class="dt">N</span></code> describes the scalar
value used to represent coördinates or distances in the space.  A
"scalar" can be thought of as a distance, or scaling factor.  For
example, you can scale a vector by a scalar (using <code class="sourceCode">(<span class="fu">*^</span>)</code>), and the
<code class="sourceCode">norm</code> function takes a vector and returns a scalar.</p></div><div class="section" id="vn"><h3>Vn</h3><p><code class="sourceCode"><span class="dt">Vn</span></code> is a type synonym yielding a common combination of <code class="sourceCode"><span class="dt">V</span></code> and <code class="sourceCode"><span class="dt">N</span></code>:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">type</span> <span class="dt">Vn</span> a <span class="fu">=</span> <span class="dt">V</span> a (<span class="dt">N</span> a)</code></pre></div></div><p>That is, <code class="sourceCode"><span class="dt">Vn</span> a</code> is the type of a concrete vector space associated to
<code class="sourceCode">a</code>, obtained by extracting the vector space dimension <code class="sourceCode"><span class="dt">V</span> a</code> and
applying it to the type of scalars <code class="sourceCode"><span class="dt">N</span> a</code>.</p></div><div class="section" id="render"><h3>Render</h3><p><code class="sourceCode"><span class="dt">Render</span></code> is an associated data family of the <code class="sourceCode"><span class="dt">Backend</span></code> class.  It
determines the type of rendering operations for a given backend.  For
more information, see the <a class="reference external" href="core.html">core library reference</a>.</p></div><div class="section" id="result"><h3>Result</h3><p><code class="sourceCode"><span class="dt">Result</span></code> is an associated type family of the <code class="sourceCode"><span class="dt">Backend</span></code> class.  It
determines the type of the final result obtained from the backend
after rendering a complete diagram.  For more information, see
the <a class="reference external" href="core.html">core library reference</a>.</p></div><div class="section" id="options"><h3>Options</h3><p><code class="sourceCode"><span class="dt">Options</span></code> is an associated data family of the <code class="sourceCode"><span class="dt">Backend</span></code> class.  It
determines the type of options which can be passed to the backend when
initiating a rendering operation.  For more information, see the <a class="reference external" href="core.html">core
library reference</a>.</p></div><div class="section" id="codomain"><h3>Codomain</h3><p><code class="sourceCode"><span class="dt">Codomain</span></code> is a type family defined in <code>Diagrams.Parametric</code>.
Parametric objects of type <code class="sourceCode">a</code> can be viewed as functions of type
<code class="sourceCode"><span class="dt">N</span> a <span class="ot">-></span> <span class="dt">Codomain</span> a</code>.  For more information, see <a class="reference internal" href="#segments-and-trails-as-parametric-objects">Segments and
trails as parametric objects</a>.</p></div></div></div></div></div></div>

    </div>

    </div> <!-- #wrap -->

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/bootstrap-docs-application.js"></script>
    <script src="../js/hoogle-search.js"></script>
  </body>
</html>
