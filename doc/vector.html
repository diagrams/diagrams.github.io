<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Diagrams - Vectors and points</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <!-- Bootstrap -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="../css/bootstrap.min.css" rel="stylesheet" />
    <link href="../css/sticky-footer-navbar.css" rel="stylesheet" />
    <link href="../css/callout.css" rel="stylesheet" />
    <link href="../css/doc.css" rel="stylesheet" />
    <link href="../css/bootstrap-docs.css" rel="stylesheet" />
    <link href="../css/home.css" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <link rel="shortcut icon" href="../diagrams.ico" />

    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>

    <div id="wrap">

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">diagrams</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav pull-right">
            <li><a href="../">Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
              <ul class="dropdown-menu">
		<li><a href="../download.html">Installation</a></li>
		<li class="divider"></li>
 		<li><a href="../tutorials.html">Tutorials</a></li>
		<li><a href="../doc/manual.html">User manual</a></li>
                <li><a href="../haddock/index.html">API reference (Haddocks)</a></li>
                <li><a href="../doc/core.html">Core library reference</a></li>
		<li class="divider"></li>
		<li><a href="http://haskell.org/haskellwiki/Diagrams">Wiki</a></li>
		<li><a href="../releases.html">Releases / changelogs</a></li>
              </ul>
            </li>
	    <li><a href="../gallery.html">Gallery</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <b class="caret"></b></a>
	      <ul class="dropdown-menu">
		<li><a href="http://webchat.freenode.net?channels=diagrams">IRC channel</a></li>
		<li><a href="http://groups.google.com/group/diagrams-discuss">Mailing
		    list</a></li>
                <li><a href="https://github.com/diagrams">Github</a></li>
		<li><a href="../sightings.html">Sightings</a></li>
		<li><a href="../community.html">Get involved</a></li>
              </ul>
	    </li>
            <li><a href="../blog/index.html">Blog</a></li>
	    <li>
	        <form id="search" class="navbar-form navbar-left" role="search" method="get" action="http://haskell.org/hoogle">
	            <div class="form-group">
	                <input id="hoogle" name="hoogle" type="text" class="form-control" placeholder="API Search">
	            </div>
	        </form>
	    </li>
	   </ul>
        </div>
      </div>
    </div>
    
    <div class="container" style="padding-top: 60px;">
      <?xml version="1.0" encoding="UTF-8" ?>
<div class="container bs-docs-container"><div class="row"><div class="col-md-3"><div class="bs-sidebar hidden-print" role="complementary" data-spy="affix"><ul class="nav"><li><a class="reference internal" href="#introduction">Introduction</a></li><li><a class="reference internal" href="#vectors">Vectors</a><ul class="nav"><li><a class="reference internal" href="#constructing-vectors">Constructing vectors</a></li><li><a class="reference internal" href="#destructing-vectors">Destructing vectors</a></li><li><a class="reference internal" href="#vector-operations">Vector operations</a></li><li><a class="reference internal" href="#using-vectors">Using vectors</a></li></ul></li><li><a class="reference internal" href="#points">Points</a><ul class="nav"><li><a class="reference internal" href="#constructing-points">Constructing points</a></li><li><a class="reference internal" href="#destructing-points">Destructing points</a></li><li><a class="reference internal" href="#polar-coordinates">Polar coordinates</a></li><li><a class="reference internal" href="#point-operations">Point operations</a></li><li><a class="reference internal" href="#using-points">Using points</a></li></ul></li></ul></div></div><div class="col-md-9"><div class="section" id="introduction"><h1>Introduction</h1><p>After working with <code>diagrams</code> for a while, you very quickly end up
needing to manipulate points and vectors in order to position and
describe your diagrams.  For example, <code class="sourceCode">fromOffsets</code> and <code class="sourceCode">fromVertices</code>
take lists of vectors and lists of points, respectively; <code class="sourceCode">beside</code> and
<code class="sourceCode">translate</code> each take a vector as an argument; <code class="sourceCode">position</code> expects
objects paired with points; and so on.</p><p>This tutorial will walk you through everything you need to know about
creating and working with vectors and points, with examples and
exercises to deepen your understanding.  If you notice any typos or
bugs, are confused, or have an idea for extending or enhancing this
tutorial, please <a class="reference external" href="https://github.com/diagrams/diagrams-doc/issues">open a ticket</a>!</p><p>Solutions to the exercises can be found in the source code for this
tutorial, in the <span class="repo"><a href="http://github.com/diagrams/diagrams-doc"><code>diagrams-doc</code></a></span> repository.  Note, however, that
many of the exercises have multiple good solutions.</p></div><div class="section" id="vectors"><h1>Vectors</h1><p>Vectors in <code>diagrams</code> are based on the <span class="package"><a href="http://hackage.haskell.org/package/linear"><code>linear</code></a></span> package.
In two dimensions, you can think of a vector as a pair of coordinates,
representing <em>displacements</em> in the \(x\) and \(y\)
directions. Alternatively, you can think of a vector as consisting of
a <em>magnitude</em> (length) and a <em>direction</em> (angle).</p><div class="exampleimg"><div style="text-align: center"><img src="images/cb8f035e56f3cc4a.png" width="500" height="200" /></div></div><p>One of the most
important things to understand about vectors is that they are
<em>translation-invariant</em>: that is, they have no specific location in
space, and are unaffected by translations (though they are affected by
other sorts of transformation such as scaling and rotation).  You can
see this for yourself at a <code>ghci</code> prompt:</p><pre><code>>>> (3 ^&amp; 6) :: V2 Double
V2 3.0 6.0
>>> translateX 19 (3 ^&amp; 6) :: V2 Double
V2 3.0 6.0
>>> rotateBy (1/4) (3 ^&amp; 6) :: V2 Double
V2 (-6.0) 3.0000000000000004</code></pre><div class="section" id="constructing-vectors"><h2>Constructing vectors</h2><p>Vectors in two dimensions have a type like <code class="sourceCode"><span class="dt">V2</span> n</code>, where <code class="sourceCode">n</code> is some
numeric type of scalar values (often <code class="sourceCode"><span class="dt">Double</span></code>).  (One can also work
with other vector spaces with any number of dimensions; in this
tutorial we'll stick to the 2D case.)</p><p>The first thing to learn is how to <em>create</em> values of type <code class="sourceCode"><span class="dt">V2</span> n</code>.
There are many options:</p><ul><li><p><code class="sourceCode">zero</code> is the zero vector, that is, the vector with zero magnitude
(and no direction, or perhaps every direction).  <code class="sourceCode">zero</code> is rarely
useful on its own, but can come in handy <em>e.g.</em> as an argument to a
function expecting a vector input.</p></li><li><p><code class="sourceCode">unitX</code> and <code class="sourceCode">unitY</code> are the length-one vectors in the positive
\(x\) and \(y\) directions, respectively.  To create a
length-\(l\) vector you can apply scaling to <code class="sourceCode">unitX</code> or <code class="sourceCode">unitY</code>,
like <code class="sourceCode">unitX <span class="fu">#</span> scale <span class="dv">3</span></code> or <code class="sourceCode"><span class="dv">3</span> <span class="fu">*^</span> unitX</code> (see <a class="reference internal" href="#vector-operations">Vector operations</a>).</p><p>Also, <code class="sourceCode">unit_X</code> and <code class="sourceCode">unit_Y</code> are like <code class="sourceCode">unitX</code> and <code class="sourceCode">unitY</code> but point
in the corresponding negative directions.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/7cc65d2dd20856cd.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> fromOffsets [unitX, unitY, <span class="dv">2</span> <span class="fu">*^</span> unit_X, unit_Y] <span class="fu">#</span> centerXY</code></pre></div></div></div></li><li><p>To create a vector with given \(x\)- and \(y\)- components,
you can use the function <code class="sourceCode"><span class="ot">r2 ::</span> (n, n) <span class="ot">-></span> <span class="dt">V2</span> n</code>:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/ba0dc6912265c336.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> fromOffsets <span class="fu">.</span> map r2 <span class="fu">$</span> [(<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">3</span>), (<span class="fu">-</span><span class="dv">2</span>,<span class="dv">1</span>), (<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">4</span>)]</code></pre></div></div></div><p>As you can see, <code class="sourceCode">r2</code> is especially useful if you already have pairs
representing vector components (which is not uncommon if the
components are coming from some other data source).</p></li><li><p>You can also use the data constructor <code class="sourceCode"><span class="dt">V2</span></code>:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/3bda268cb4dff7f0.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> fromOffsets [<span class="dt">V2</span> <span class="dv">1</span> <span class="dv">1</span>, <span class="dt">V2</span> <span class="dv">0</span> <span class="dv">3</span>, <span class="dt">V2</span> (<span class="fu">-</span><span class="dv">2</span>) <span class="dv">1</span>, <span class="dt">V2</span> (<span class="fu">-</span><span class="dv">1</span>) (<span class="fu">-</span><span class="dv">4</span>)]</code></pre></div></div></div></li><li><p>You can also use <code class="sourceCode">(<span class="fu">^&</span>)</code> to construct vector literals, like so:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/92f3337f0b025108.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> fromOffsets [<span class="dv">1</span> <span class="fu">^&</span> <span class="dv">1</span>, <span class="dv">0</span> <span class="fu">^&</span> <span class="dv">3</span>, (<span class="fu">-</span><span class="dv">2</span>) <span class="fu">^&</span> <span class="dv">1</span>, (<span class="fu">-</span><span class="dv">1</span>) <span class="fu">^&</span> (<span class="fu">-</span><span class="dv">4</span>)]</code></pre></div></div></div><p>This can make for convenient and pleasant notation. However, it does
have some drawbacks, namely:</p><ul><li><p><code class="sourceCode">(<span class="fu">^&</span>)</code> is extremely general so its type is unhelpful.</p></li><li><p>Related to the above, literal vector expressions like <code class="sourceCode"><span class="dv">1</span> <span class="fu">^&</span> <span class="dv">2</span></code> must
be used in a context where the type can be inferred (or else a
type annotation must be added).  This is because (as we will see
later) <code class="sourceCode">(<span class="fu">^&</span>)</code> can also be used to construct points as well as
higher-dimensional vectors.</p></li></ul><p>Only you can decide whether the tradeoffs are worth it in a given
situation.</p></li><li><p>You can construct vectors from <code class="sourceCode"><span class="dt">Direction</span></code>s using the
<code class="sourceCode">fromDirection</code> function.  <code class="sourceCode">fromDirection</code> takes a <code class="sourceCode"><span class="dt">Direction</span></code> and
constructs a unit (<em>i.e.</em> magnitude 1) vector pointing in the given
direction.</p></li><li><p>One final way to construct vectors is using the function <code class="sourceCode">e</code>.  By
definition, <code class="sourceCode">e a <span class="fu">==</span> unitX <span class="fu">#</span> rotate a</code>, but sometimes calling <code class="sourceCode">e</code>
can be more convenient.  The name <code class="sourceCode">e</code> is a sort of pun: in the same
way that a complex number with magnitude \(r\) and angle
\(\theta\) can be constructed as \(r e^{i\theta}\), a vector
with given magnitude and direction can be constructed as <code class="sourceCode">r <span class="fu">*^</span> e
theta</code>. (Note that <code class="sourceCode">e</code> is not exported from <code>Diagrams.Prelude</code>;
if you wish to use it you must import it from
<code>Diagrams.TwoD.Vector</code>.)</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/7c160ba595bba87b.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.TwoD.Vector</span>
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> lwG <span class="fl">0.05</span> <span class="fu">.</span> mconcat <span class="fu">.</span> map fromOffsets
<span class="ot">></span>         <span class="fu">$</span> [ [r <span class="fu">*^</span> e (r <span class="fu">@@</span> rad)]
<span class="ot">></span>           <span class="fu">|</span> r <span class="ot"><-</span> [<span class="dv">33</span> <span class="fu">*</span> tau<span class="fu">/</span><span class="dv">32</span>, <span class="dv">34</span> <span class="fu">*</span> tau<span class="fu">/</span><span class="dv">32</span> <span class="fu">..</span> <span class="dv">2</span> <span class="fu">*</span> tau]
<span class="ot">></span>           ]</code></pre></div></div></div></li></ul><div class="exercises panel panel-success"><div class="panel-body"><p>Construct each of the following images.</p><ol><li><div class="exampleimg"><div style="text-align: center"><img src="images/1dd6bbc3a9d03b7c.png" width="500" height="200" /></div></div></li><li><p>The circles have radius 1, and are arranged in the shape of a
radius-5 semicircle.</p><div class="exampleimg"><div style="text-align: center"><img src="images/c11b4b7320b95609.png" width="500" height="200" /></div></div></li><li><p>30 spokes with lengths 1, 2, and 3.</p><div class="exampleimg"><div style="text-align: center"><img src="images/805672efa2a8eaa9.png" width="500" height="200" /></div></div></li></ol></div></div></div><div class="section" id="destructing-vectors"><h2>Destructing vectors</h2><p>To take apart a vector into its \(x\) and \(y\) components,
use <code class="sourceCode"><span class="ot">unr2 ::</span> <span class="dt">V2</span> n <span class="ot">-></span> (n, n)</code>, or more generally you can use
<code class="sourceCode">coords</code> (from <code>Diagrams.Coordinates</code>) and pattern-match on
<code class="sourceCode">(<span class="fu">:&</span>)</code>.  Both these methods work well in conjunction with the
<code>ViewPatterns</code> <a class="reference external" href="http://ghc.haskell.org/trac/ghc/wiki/ViewPatterns">GHC extension</a>, as in</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> foo ::</span> <span class="dt">V2</span> n <span class="ot">-></span> <span class="fu">...</span>
<span class="ot">></span> foo (unr2 <span class="ot">-></span> (x,y)) <span class="fu">=</span> <span class="fu">...</span> x <span class="fu">...</span> y <span class="fu">...</span></code></pre></div></div><p>Note, however, that you will probably need this less often than you
think.  Using the vector operations presented in the next section, you
should strive to work on the level of vectors, and only "stoop" to the
level of working with explicit coordinates when absolutely necessary.</p><p>To get the magnitude and direction of a vector, you can use the
<code class="sourceCode">norm</code> and <code class="sourceCode">direction</code> functions.  To get the angle between two
given vectors, use <code class="sourceCode">angleBetween</code>.  Additionally, <code class="sourceCode">quadrance</code> gives
the <em>squared</em> magnitude of a vector, and is more efficient than
squaring the result of <code class="sourceCode">norm</code>, since it avoids a call to <code class="sourceCode">sqrt</code>.
For example, if you want to test which of two vectors is longer, you
can compare the results of <code class="sourceCode">quadrance</code> instead of <code class="sourceCode">norm</code> (since
\(a &lt; b \iff a^2 &lt; b^2\) as long as \(a\) and \(b\) are
nonnegative).</p></div><div class="section" id="vector-operations"><h2>Vector operations</h2><p>There is a rich set of combinators for operating on vectors (and we
are open to adding more!).</p><ul><li><p>Vectors can be transformed with all the usual transformation
functions like <code class="sourceCode">rotate</code>, <code class="sourceCode">scale</code>, and so on.  However, recall that
although it is possible to apply <code class="sourceCode">translate</code> to a vector, it has no
effect.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/8ebcd246e5e2d62e.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> mconcat <span class="fu">$</span> map fromOffsets (map (<span class="fu">:</span>[]) vs)
<span class="ot">></span>   <span class="kw">where</span>
<span class="ot">></span>     vs <span class="fu">=</span> take <span class="dv">33</span> <span class="fu">.</span> iterate (scale (<span class="dv">2</span><span class="fu">**</span>(<span class="dv">1</span><span class="fu">/</span><span class="dv">32</span>)) <span class="fu">.</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">32</span>))
<span class="ot">></span>        <span class="fu">$</span> unitX</code></pre></div></div></div></li><li><p><code class="sourceCode"><span class="dt">V2</span></code> is an instance of the <code class="sourceCode"><span class="dt">Additive</span></code> class (see
<code>Linear.Additive</code> from the <span class="package"><a href="http://hackage.haskell.org/package/linear"><code>linear</code></a></span> package). This means:</p><ul><li><p>Vectors can be added with <code class="sourceCode">(<span class="fu">^+^</span>)</code>.  To add two vectors, think of
placing them head-to-tail; the result of the addition is the
vector from the tail of the first vector to the head of the
second.</p></li><li><p>There is a zero vector <code class="sourceCode">zero</code> (mentioned previously), which is
the identity for <code class="sourceCode">(<span class="fu">^+^</span>)</code>.</p></li><li><p>Vectors can be negated with <code class="sourceCode">negated</code>.  The negation of a vector
<code>v</code> is the vector with the same magnitude which points in the
opposite direction, and is the additive inverse of <code>v</code>: that is,
<code class="sourceCode">v <span class="fu">^+^</span> negated v <span class="fu">==</span> zero</code>.</p></li></ul><p><code>Linear.Additive</code> also defines a few other methods which can
be used on vectors, including <code class="sourceCode">(<span class="fu">^-^</span>)</code> (vector subtraction) and
<code class="sourceCode">sumV</code> (summing an entire list or other <code class="sourceCode"><span class="dt">Foldable</span></code> container of
vectors).</p></li><li><p><code class="sourceCode"><span class="dt">V2</span></code> is also an instance of the <code class="sourceCode"><span class="dt">Functor</span></code> class (see
<code>Data.Functor</code> from the <span class="package"><a href="http://hackage.haskell.org/package/base"><code>base</code></a></span>). The <code class="sourceCode">(<span class="fu">*^</span>)</code> operator uses
this class to multiply all components of a vector by a scalar. In
particular for <code class="sourceCode"><span class="dt">Num</span> n <span class="ot">=></span> <span class="dt">V2</span> n</code> we have <code class="sourceCode"><span class="ot">(*^) ::</span> n <span class="ot">-></span> <span class="dt">V2</span> n <span class="ot">-></span> <span class="dt">V2</span> n</code>.
(Note that <span class="package"><a href="http://hackage.haskell.org/package/linear"><code>linear</code></a></span> operators always use <code>^</code> in their
names to indicate a vector argument, as in <code class="sourceCode">(<span class="fu">*^</span>)</code> (scalar times
vector) and <code class="sourceCode">(<span class="fu">^+^</span>)</code> (vector plus vector) and <code class="sourceCode">(<span class="fu">.+^</span>)</code> (point plus
vector, as we will see later.)</p><p>Using <code class="sourceCode">(<span class="fu">*^</span>)</code> is equivalent to using <code class="sourceCode">scale</code>; that is, <code class="sourceCode">s <span class="fu">*^</span> v <span class="fu">==</span> v <span class="fu">#</span>
scale s</code>.  There is also a <code class="sourceCode">(<span class="fu">^/</span>)</code> operator provided for convenience
which divides a vector by a scalar; of course <code class="sourceCode">v <span class="fu">^/</span> s <span class="fu">==</span> v <span class="fu">^*</span>
(<span class="dv">1</span><span class="fu">/</span>s)</code>.</p></li><li><p>Finally, <code class="sourceCode"><span class="dt">R2</span></code> is an instance of the <code class="sourceCode"><span class="dt">Metric</span></code> class (also in
<code>linear</code>), which provides the <em>inner product</em> (also
called <em>dot product</em>) function, <code class="sourceCode">dot</code>.  The definition and
properties of the dot product are beyond the scope of this tutorial;
you can <a class="reference external" href="http://en.wikipedia.org/wiki/Dot_product">read about it on Wikipedia</a>.  However, note that several
common uses of the dot product are already encapsulated in other
functions, such as <code class="sourceCode">project</code> and <code class="sourceCode">leftTurn</code>.</p></li></ul><ul><li><p>The <code class="sourceCode">signorm</code> function changes the magnitude of a vector to
\(1\), while keeping the direction fixed.</p></li><li><p><code class="sourceCode">perp</code> yields a vector perpendicular to (and of the same magnitude
as) its input.</p></li><li><p><code class="sourceCode">lerp</code> linearly interpolates between two vectors as the given
parameter varies from \(0\) to \(1\).</p></li><li><p><code class="sourceCode">leftTurn v1 v2</code> tests whether the direction of <code class="sourceCode">v2</code> is a "left
turn" from <code class="sourceCode">v1</code> (that is, if the direction of <code class="sourceCode">v2</code> can be obtained
from that of <code class="sourceCode">v1</code> by rotating up to one-half turn in the positive
direction).</p></li><li><p><code class="sourceCode">project u v</code> computes the <em>projection</em> of <code class="sourceCode">v</code> onto <code class="sourceCode">u</code>.  In the
illustration below, the green line shows the projection of the red
vector onto the blue vector.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/979424ae6cc2caec.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> u <span class="fu">=</span> r2 (<span class="dv">1</span>,<span class="dv">2</span>)
<span class="ot">></span> v <span class="fu">=</span> <span class="dv">2</span> <span class="fu">*^</span> (unitY <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">19</span>))
<span class="ot">></span> p <span class="fu">=</span> project u v
<span class="ot">></span>
<span class="ot">></span> drawV v <span class="fu">=</span> fromOffsets [v]
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> mconcat
<span class="ot">></span>   [ drawV p <span class="fu">#</span> lc green <span class="fu">#</span> lwG <span class="fl">0.03</span>
<span class="ot">></span>   , drawV u <span class="fu">#</span> lc blue
<span class="ot">></span>   , drawV v <span class="fu">#</span> lc red
<span class="ot">></span>   , drawV (p <span class="fu">^-^</span> v) <span class="fu">#</span> translate v <span class="fu">#</span> dashingG [<span class="fl">0.1</span>,<span class="fl">0.1</span>] <span class="dv">0</span>
<span class="ot">></span>   ]</code></pre></div></div></div></li></ul><div class="exercises panel panel-success"><div class="panel-body"><ol><li><p>Write a function <code class="sourceCode"><span class="ot">vTriangle ::</span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">V2</span> <span class="dt">Double</span> <span class="ot">-></span> <span class="dt">Diagram</span>
<span class="dt">B</span></code> which takes as arguments two vectors representing two sides of
a triangle and draws the corresponding triangle.  For example,
<code class="sourceCode">vTriangle unitX (unitX <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">8</span>))</code> should produce</p><div class="exampleimg"><div style="text-align: center"><img src="images/374d7e3be5bb5555.png" width="500" height="200" /></div></div></li><li><p>Write a function which takes two vectors as input and constructs
a classic illustration of vector addition using a parallelogram,
as in the following example:</p><div class="exampleimg"><div style="text-align: center"><img src="images/f8912b15b2ad67d7.png" width="500" height="200" /></div></div></li></ol></div></div></div><div class="section" id="using-vectors"><h2>Using vectors</h2><p>Once you have a vector, what can you do with it?  A few of the things
have already been seen in the examples above, but it's worth
collecting a list here in one place.</p><ul><li><p>You can create a trail, path, or diagram (in fact, any <code class="sourceCode"><span class="dt">TrailLike</span></code>
thing—see the <a class="reference external" href="paths.html">trails and paths tutorial</a>) from a list of
vectors using <code class="sourceCode">fromOffsets</code>.</p></li><li><p>You can translate things by a vector using <code class="sourceCode">translate</code> or
<code class="sourceCode">moveOriginBy</code>.</p></li><li><p>As explained in the next section, you can add a vector to a point to
yield another point.</p></li></ul></div></div><div class="section" id="points"><h1>Points</h1><p>A <em>point</em> is a location in space.  In <code>diagrams</code>, points are based
on the <code class="sourceCode"><span class="dt">Point</span></code> wrapper from the <span class="package"><a href="http://hackage.haskell.org/package/linear"><code>linear</code></a></span> package, and in the case
of 2D are represented by the type alias <code class="sourceCode"><span class="dt">P2</span> <span class="fu">=</span> <span class="dt">Point</span> <span class="dt">V2</span></code>. In 2D, points
are usually thought of as a pair of \(x\) and \(y\)
coordinates (though other coordinate systems could be used as well,
<em>e.g.</em> polar coordinates).</p><p>Points and vectors are closely related, and are sometimes conflated
since both can be concretely represented by tuples of coordinates.
However, they are distinct concepts which support different sets of
operations. For example, points are affected by translation whereas
vectors are not; two vectors can be added but two points cannot; and
so on.  Hence, they are represented by distinct types in <code>diagrams</code>.</p><div class="section" id="constructing-points"><h2>Constructing points</h2><p>There are several ways to construct points.</p><ul><li><p><code class="sourceCode">origin</code> is the name of the distinguished point at the origin of
the vector space (note this works in any dimension).</p></li><li><p>To create a point with given \(x\)- and \(y\)- components,
you can use the function <code class="sourceCode"><span class="ot">p2 ::</span> (n,n) <span class="ot">-></span> <span class="dt">Point</span> <span class="dt">V2</span> n</code>:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/8633feed5a6399d1.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example
<span class="ot">></span>   <span class="fu">=</span> flip atPoints (repeat (circle <span class="fl">0.2</span> <span class="fu">#</span> fc green))
<span class="ot">></span>     <span class="fu">$</span> map p2 <span class="fu">$</span> [(<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">3</span>), (<span class="fu">-</span><span class="dv">2</span>,<span class="dv">1</span>), (<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">4</span>), (<span class="dv">2</span>,<span class="dv">0</span>)]</code></pre></div></div></div><p>As with <code class="sourceCode">r2</code>, <code class="sourceCode">p2</code> is especially useful if you already have pairs
representing point coordinates.</p></li><li><p>The <code class="sourceCode"><span class="fu">^&</span></code> operator can be used to construct literal points (<code class="sourceCode"><span class="dt">P2</span> n</code>
values) as well as vectors (<code class="sourceCode"><span class="dt">V2</span> n</code> values).  The proper type is chosen
via type inference: if the expression <code class="sourceCode">(<span class="dv">3</span> <span class="fu">^&</span> <span class="dv">5</span>)</code> is used in a context
where its type is inferred to be <code class="sourceCode"><span class="dt">P2</span> n</code>, it is the point at
\((3,5)\); if its type is inferred to be <code class="sourceCode"><span class="dt">V2</span> n</code>, it is the vector
with \(x\)-component \(3\) and \(y\)-component
\(5\).</p></li><li><p>There is no way to directly convert a vector into a point (unless
you use the <code class="sourceCode"><span class="dt">P</span></code> type constructor from <code class="sourceCode"><span class="dt">Linear.Affine</span></code>)—this is
intentional!  If you have a vector <code class="sourceCode">v</code> and you want to refer to the
point located at the vector's head (when the vector tail is placed
at, say, the origin) you can write <code class="sourceCode">origin <span class="fu">.+^</span> v</code> (see below for a
discussion of <code class="sourceCode"><span class="fu">.+^</span></code>).</p></li><li><p>An advanced method of generating points is to use any function
returning a <code class="sourceCode"><span class="dt">TrailLike</span></code> result, since <code class="sourceCode">[<span class="dt">Point</span> <span class="dt">V2</span> <span class="dt">Double</span>]</code> is an instace of
<code class="sourceCode"><span class="dt">TrailLike</span></code>. Using a function returning any <code class="sourceCode"><span class="dt">TrailLike</span></code> at the
result type <code class="sourceCode">[<span class="dt">Point</span> <span class="dt">V2</span> <span class="dt">Double</span>]</code> will result in the list of vertices of the trail.
For example, here we obtain the list of vertices of a regular
nonagon:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/a217ed9c127328ca.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> pts ::</span> [<span class="dt">P2</span> <span class="dt">Double</span>]
<span class="ot">></span> pts <span class="fu">=</span> nonagon <span class="dv">1</span>
<span class="ot">></span> example <span class="fu">=</span> atPoints pts (repeat <span class="fu">$</span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc green)</code></pre></div></div></div><p>Note that we could also inline <code class="sourceCode">pts</code> in the above example to obtain</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> atPoints (nonagon <span class="dv">1</span>) (repeat <span class="fu">$</span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc green)</code></pre></div></div><p>In this case, the type of <code class="sourceCode">nonagon <span class="dv">1</span></code> would be inferred as <code class="sourceCode">[<span class="dt">P2</span> <span class="dt">Double</span>]</code>
(since <code class="sourceCode">atPoints</code> expects a list of points), causing the
appropriate <code class="sourceCode"><span class="dt">TrailLike</span></code> instance to be
chosen.</p></li></ul></div><div class="section" id="destructing-points"><h2>Destructing points</h2><p>For taking a point apart into its components:</p><ul><li><p>You can use the <code class="sourceCode">unp2</code> function, or, more generally, <code class="sourceCode">coords</code> (just
as with vectors) to get the Cartesian coordinates of a point.</p></li><li><p>You can also use the <code class="sourceCode">_x</code> and <code class="sourceCode">_y</code> lenses to extract (or update) the
\(x\)- and \(y\)-coordinates of a point: for example, <code class="sourceCode">pt
<span class="fu">^.</span> _x</code> gets the \(x\)-coordinate of <code class="sourceCode">pt</code>, and <code class="sourceCode">pt <span class="fu">&</span> _x <span class="fu">+~</span> <span class="dv">2</span></code> adds
<code class="sourceCode"><span class="dv">2</span></code> to the \(x\)-coordinate.</p></li></ul><p>You can compute the distance between two points with the <code class="sourceCode">distance</code>
function (or <code class="sourceCode">qd</code> to get the square ("quadrance") of the distance,
which avoids a square root).</p><div class="exercises panel panel-success"><div class="panel-body"><p>Construct each of the following images.</p><ol><li><p>A \(31 \times 31\) grid of circles, each colored according to
the distance of its center from the origin.</p><div class="exampleimg"><div style="text-align: center"><img src="images/64fb3a3a000fe5ca.png" width="500" height="200" /></div></div></li></ol></div></div></div><div class="section" id="polar-coordinates"><h2>Polar coordinates</h2><p>Instead of being represented using \(x\)- and \(y\)-coordinates,
points can also be represented using <em>polar</em> coordinates (usually
referred to as \((r, \theta)\)).</p><ul><li><p>You can use the <code class="sourceCode">_r</code> lens to refer to the magnitude
(\(r\)-coordinate) of a point.</p></li><li><p>You can use the <code class="sourceCode">_theta</code> lens to refer to the
\(\theta\)-coordinate of a point, that is, the angle to the point
as measured counterclockwise from the positive \(x\)-axis.</p></li></ul></div><div class="section" id="point-operations"><h2>Point operations</h2><p>You can transform points arbitrarily: unlike vectors, points are
affected by translation.  Rotation and scaling act on points with
respect to the origin (for example, scaling the point \((1,1)\) by
\(2\) results in the point \((2,2)\)).</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/69752e2c706e5f02.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> sqPts <span class="fu">=</span> square <span class="dv">1</span>
<span class="ot">></span>
<span class="ot">></span> drawPts pts c <span class="fu">=</span> pts <span class="fu">#</span> map (\p <span class="ot">-></span> (p,dot' c)) <span class="fu">#</span> position
<span class="ot">></span> dot' c <span class="fu">=</span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc c
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> drawPts sqPts blue
<span class="ot">></span>        <span class="fu"><></span> drawPts (sqPts <span class="fu">#</span> scale <span class="dv">2</span> <span class="fu">#</span> rotateBy(<span class="dv">1</span><span class="fu">/</span><span class="dv">10</span>) <span class="fu">#</span> translateX <span class="fl">0.2</span>) red</code></pre></div></div></div><p>Abstractly, points and vectors together form what is termed an "affine
space". Here is a nice intuitive description of affine spaces, stolen
from <a class="reference external" href="http://en.wikipedia.org/wiki/Affine_space">the wikipedia page</a>:</p><blockquote><p>An affine space is what is left of a <a class="reference external" href="http://en.wikipedia.org/wiki/Vector_space">vector space</a> after you've
forgotten which point is the origin (or, in the words of the
French mathematician <a class="reference external" href="http://en.wikipedia.org/wiki/Marcel_Berger">Marcel Berger</a>, "An affine space is nothing
more than a vector space whose origin we try to forget about, by
adding translations to the linear maps").</p></blockquote><p>It's not important to understand the formal mathematical
definition of an affine space; it's enough to understand the sorts of
operations which this enables on points and vectors.</p><p>In particular, <code class="sourceCode"><span class="dt">P2</span></code> is an instance of the <code class="sourceCode"><span class="dt">Affine</span></code> type class
(defined in <code>Linear.Affine</code> from the <span class="package"><a href="http://hackage.haskell.org/package/linear"><code>linear</code></a></span> package).
This class also has an associated type family called <code class="sourceCode"><span class="dt">Diff</span></code>, which for
<code class="sourceCode"><span class="dt">P2</span></code> is defined to be <code class="sourceCode"><span class="dt">V2</span></code>: roughly, this says that the <em>difference</em>
or "offset" between two points is given by a vector.</p><p>Note how the operators below are named: a period indicates a point
argument, and a carat (<code class="sourceCode"><span class="fu">^</span></code>) indicates a vector argument.  So, for
example, <code class="sourceCode">(<span class="fu">.+^</span>)</code> takes a point as its first argument and a vector as
its second.</p><ul><li><p>You can "subtract" one point from another to get the vector between
them, using <code class="sourceCode">(<span class="fu">.-.</span>)</code>.  In particular <code class="sourceCode">b <span class="fu">.-.</span> a</code> is the vector
pointing from <code class="sourceCode">a</code> to <code class="sourceCode">b</code>.</p></li><li><p>Using <code class="sourceCode">(<span class="fu">.+^</span>)</code>, you can add a vector to a point, resulting in another
point which is offset from the first point by the given vector.  If
<code class="sourceCode">p <span class="fu">.+^</span> v <span class="fu">==</span> p'</code>, then <code class="sourceCode">p' <span class="fu">.-.</span> p <span class="fu">==</span> v</code>.  You can also use <code class="sourceCode">(<span class="fu">.-^</span>)</code> to
subtract a vector from a point.</p></li><li><p>Although it is not semanticly correct, <code class="sourceCode"><span class="dt">Point</span></code> is an instance of
<code class="sourceCode"><span class="dt">Additive</span></code> (this may be fixed in a later release). This means you
can <em>linearly interpolate</em> between two points using <code class="sourceCode">lerp</code>, which
does make sense. For example, to find the point which is 25% of the
way from the first point to the second.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/caf6c8a20168ce6f.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> pt1,<span class="ot"> pt2 ::</span> <span class="dt">P2</span> <span class="dt">Double</span>
<span class="ot">></span> pt1 <span class="fu">=</span> origin
<span class="ot">></span> pt2 <span class="fu">=</span> p2 (<span class="dv">5</span>,<span class="dv">3</span>)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> position <span class="fu">$</span>
<span class="ot">></span>   [ (p, circle <span class="fl">0.2</span> <span class="fu">#</span> fc (colourConvert c))
<span class="ot">></span>   <span class="fu">|</span> a <span class="ot"><-</span> [<span class="dv">0</span>, <span class="fl">0.1</span> <span class="fu">..</span> <span class="dv">1</span>]
<span class="ot">></span>   , <span class="kw">let</span> p <span class="fu">=</span> lerp a pt2 pt1
<span class="ot">></span>   , <span class="kw">let</span> c <span class="fu">=</span> blend a blue green
<span class="ot">></span>   ]</code></pre></div></div></div></li><li><p>You can find the <em>centroid</em> (the "average" or "center of mass") of a
list of points using the <code class="sourceCode">centroid</code> function (defined in
<code>Diagrams.Points</code>).</p></li><li><p>Finally, you can scale a point using the <code class="sourceCode">(<span class="fu">*^</span>)</code> operator (though, as
mentioned earlier, you can also use <code class="sourceCode">scale</code>).</p></li></ul><div class="exercises panel panel-success"><div class="panel-body"><ol><li><p>Implement the <a class="reference external" href="http://en.wikipedia.org/wiki/Graham_scan">Graham scan algorithm</a> and generate diagrams
illustrating the intermediate steps.</p></li></ol></div></div></div><div class="section" id="using-points"><h2>Using points</h2><p>Here are some things you can do with points, once you have constructed
or computed them:</p><ul><li><p>You can create a straight line between two points with <code class="sourceCode">(<span class="fu">~~</span>)</code>.</p></li><li><p>You can construct any <code class="sourceCode"><span class="dt">TrailLike</span></code> instance (like trails, paths, or
diagrams) from a list of points using <code class="sourceCode">fromVertices</code>.</p></li><li><p>You can translate objects to a given point using <code class="sourceCode">moveTo</code>, <code class="sourceCode">place</code>,
or <code class="sourceCode">moveOriginTo</code>.</p></li><li><p>You can position an entire collection of objects using <code class="sourceCode">position</code>.</p></li></ul></div></div></div></div></div>

    </div>

    </div> <!-- #wrap -->

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/bootstrap-docs-application.js"></script>
    <script src="../js/hoogle-search.js"></script>
  </body>
</html>
