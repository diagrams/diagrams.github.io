<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Diagrams - Diagrams Quick Start Tutorial</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <!-- Bootstrap -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="../css/bootstrap.min.css" rel="stylesheet" />
    <link href="../css/sticky-footer-navbar.css" rel="stylesheet" />
    <link href="../css/callout.css" rel="stylesheet" />
    <link href="../css/doc.css" rel="stylesheet" />
    <link href="../css/bootstrap-docs.css" rel="stylesheet" />
    <link href="../css/home.css" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <link rel="shortcut icon" href="../diagrams.ico" />

    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>

    <div id="wrap">

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">diagrams</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav pull-right">
            <li><a href="../">Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
              <ul class="dropdown-menu">
		<li><a href="../download.html">Installation</a></li>
		<li class="divider"></li>
 		<li><a href="../tutorials.html">Tutorials</a></li>
		<li><a href="../doc/manual.html">User manual</a></li>
                <li><a href="../haddock/index.html">API reference (Haddocks)</a></li>
                <li><a href="../doc/core.html">Core library reference</a></li>
		<li class="divider"></li>
		<li><a href="http://haskell.org/haskellwiki/Diagrams">Wiki</a></li>
		<li><a href="../releases.html">Releases / changelogs</a></li>
              </ul>
            </li>
	    <li><a href="../gallery.html">Gallery</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <b class="caret"></b></a>
	      <ul class="dropdown-menu">
		<li><a href="http://webchat.freenode.net?channels=diagrams">IRC channel</a></li>
		<li><a href="http://groups.google.com/group/diagrams-discuss">Mailing
		    list</a></li>
                <li><a href="https://github.com/diagrams">Github</a></li>
		<li><a href="../sightings.html">Sightings</a></li>
		<li><a href="../community.html">Get involved</a></li>
              </ul>
	    </li>
            <li><a href="../blog/index.html">Blog</a></li>
	    <li>
	        <form id="search" class="navbar-form navbar-left" role="search" method="get" action="http://haskell.org/hoogle">
	            <div class="form-group">
	                <input id="hoogle" name="hoogle" type="text" class="form-control" placeholder="API Search">
	            </div>
	        </form>
	    </li>
	   </ul>
        </div>
      </div>
    </div>
    
    <div class="container" style="padding-top: 60px;">
      <?xml version="1.0" encoding="UTF-8" ?>
<div class="container bs-docs-container"><div class="row"><div class="col-md-3"><div class="bs-sidebar hidden-print" role="complementary" data-spy="affix"><ul class="nav"><li><a class="reference internal" href="#introduction">Introduction</a></li><li><a class="reference internal" href="#resources">Resources</a></li><li><a class="reference internal" href="#getting-started">Getting started</a><ul class="nav"><li><a class="reference internal" href="#ghc-the-haskell-platform">GHC/The Haskell Platform</a></li><li><a class="reference internal" href="#installation">Installation</a></li></ul></li><li><a class="reference internal" href="#philosophy">Philosophy</a></li><li><a class="reference internal" href="#your-first-diagram">Your first diagram</a></li><li><a class="reference internal" href="#attributes">Attributes</a></li><li><a class="reference internal" href="#combining-diagrams">Combining diagrams</a><ul class="nav"><li><a class="reference internal" href="#local-origins">Local origins</a></li><li><a class="reference internal" href="#side-by-side">Side-by-side</a></li><li><a class="reference internal" href="#envelopes">Envelopes</a></li></ul></li><li><a class="reference internal" href="#transforming-diagrams">Transforming diagrams</a><ul class="nav"><li><a class="reference internal" href="#translation">Translation</a></li><li><a class="reference internal" href="#aligning">Aligning</a></li></ul></li><li><a class="reference internal" href="#diagrams-as-a-monoid">Diagrams as a monoid</a></li><li><a class="reference internal" href="#a-worked-example">A worked example</a></li><li><a class="reference internal" href="#next-steps">Next steps</a></li></ul></div></div><div class="col-md-9"><h1 class="title">Diagrams Quick Start Tutorial</h1><div class="section" id="introduction"><h1>Introduction</h1><p>This tutorial will walk you through the basics of using the diagrams
DSL to create graphics in a powerful, modular, and declarative way.
There's enough here to get you started quickly; for more in-depth
information, see the <a class="reference external" href="manual.html">user manual</a>.</p><p>This is not a Haskell tutorial (although a
Haskell-tutorial-via-diagrams is a fun idea and may happen in the
future).  For now, we recommend <a class="reference external" href="http://learnyouahaskell.com/">Learn You a Haskell</a> for a nice
introduction to Haskell; Chapters 1-6 should give you pretty much all
you need for working with diagrams.</p></div><div class="section" id="resources"><h1>Resources</h1><p>Some resources that may be helpful to you as you learn about diagrams:</p><ul><li><p>The <a class="reference external" href="manual.html">user manual</a></p></li><li><p>The <a class="reference external" href="../haddock/index.html">API documentation</a></p></li><li><p>The <a class="reference external" href="http://groups.google.com/group/diagrams-discuss">diagrams-discuss mailing list</a></p></li><li><p>The <code>#diagrams</code> IRC channel on freenode.org</p></li></ul></div><div class="section" id="getting-started"><h1>Getting started</h1><p>Before getting on with generating beautiful diagrams, you'll need a
few things:</p><div class="section" id="ghc-the-haskell-platform"><h2>GHC/The Haskell Platform</h2><p>You'll need a recent version of the <a class="reference external" href="http://haskell.org/ghc">Glasgow Haskell Compiler</a> (7.8
or later), as well as the <a class="reference external" href="http://hackage.haskell.org/trac/hackage/wiki/CabalInstall">cabal-install tool</a>.  If you do not
already have these, we recommend following the <a class="reference external" href="https://www.haskell.org/downloads#minimal">minimal installer
instructions</a>.</p></div><div class="section" id="installation"><h2>Installation</h2><p>Once you have the prerequisites, installing the diagrams libraries
themselves should be a snap. We recommend installing diagrams in a
sandbox, like so:</p><p>*nix:</p><pre><code>cabal sandbox init
cabal install diagrams</code></pre><p>Windows:</p><pre><code>cabal update
cabal sandbox init
cabal install diagrams -j1</code></pre><p>(The <code class="sourceCode"><span class="fu">-</span>j1</code> flag is necessary in Windows to prevent the <code class="sourceCode">package<span class="fu">.</span>cache</code>
file from being edited multiple times at once.  See
[here](<a class="reference external" href="https://github.com/haskell/cabal/issues/4005#issuecomment-275434975">https://github.com/haskell/cabal/issues/4005#issuecomment-275434975</a>)
and
[here](<a class="reference external" href="https://github.com/commercialhaskell/stack/issues/2617">https://github.com/commercialhaskell/stack/issues/2617</a>) for
more information.)</p><p>To make use of the diagrams libraries in the sandbox, you can use
commands such as</p><p>*nix/cmd.exe:</p><pre><code>cabal exec -- ghc --make MyDiagram.hs</code></pre><p>Powershell:</p><pre><code>cabal exec (ghc --make MyDiagram.hs)</code></pre><p>which will run <code>ghc --make MyDiagram.hs</code> in the sandbox environment.
Alternatively, on any Unix-ish system you should be able to do
something like</p><pre><code>cabal exec bash</code></pre><p>(feel free to substitute your favorite shell in place of <code>bash</code>).
This will start a new shell in an environment with all the diagrams
packages available to GHC; you can now run <code>ghc</code> normally, without
the need for <code>cabal exec</code>.  To exit the sandbox, just exit the shell.</p><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams"><code>diagrams</code></a></span> is just a wrapper package which pulls in the following
four packages:</p><ul><li><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams-core"><code>diagrams-core</code></a></span> contains the core data structures and definitions
that form the abstract heart of the library.</p></li><li><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams-lib"><code>diagrams-lib</code></a></span> is a standard library of drawing primitives,
attributes, and combinators built on top of the core library.</p></li><li><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams-contrib"><code>diagrams-contrib</code></a></span> is a library of user-contributed extensions.</p></li><li><p><span class="package"><a href="http://hackage.haskell.org/package/diagrams-svg"><code>diagrams-svg</code></a></span> is a backend which renders diagrams as SVG files.</p></li></ul><p>There are other backends as well; see the <a class="reference external" href="http://hackage.haskell.org/package/diagrams">diagrams package
documentation</a> and the <a class="reference external" href="http://www.haskell.org/haskellwiki/Diagrams/Projects#Backends">diagrams wiki</a> for more information.</p></div></div><div class="section" id="philosophy"><h1>Philosophy</h1><p>Before diving in to create some diagrams, it's worth taking a minute
to explain some of the philosophy that drove many of the design
decisions. (If you're particularly impatient, feel free to skip this
section for now—but you might want to come back and read it later!)</p><ul><li><p>Positioning and scaling are always <em>relative</em>.  There is never any
global coordinate system to think about; everything is done relative
to diagrams' <em>local</em> vector spaces.  This is not only easier to think
about, it also increases modularity and compositionality, since diagrams
can always be designed without thought for the context in which they
will eventually be used.  Doing things this way is more work for the
<em>library</em> and less work for the <em>user</em>, which is the way it should be.</p></li><li><p>Almost everything is based around the concept of <em>monoids</em> (more on
this later).</p></li><li><p>The core library is as simple and elegant as possible—almost
everything is built up from a very small set of primitive types and
operations.  One consequence is that diagrams is optimized for
simplicity and flexibility rather than for speed; if you are looking
to do <em>real-time</em> graphics generation you will probably be best
served by looking elsewhere! (With that said, however, we certainly
are interested in making diagrams as fast as possible without
sacrificing other features, and there have been several cases of
people successfully using diagrams for simple real-time graphics
generation.)</p></li></ul></div><div class="section" id="your-first-diagram"><h1>Your first diagram</h1><p>Create a file called <code class="sourceCode">DiagramsTutorial.lhs</code>
with the following contents:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> <span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span>
<span class="ot">></span> <span class="ot">{-# LANGUAGE FlexibleContexts          #-}</span>
<span class="ot">></span> <span class="ot">{-# LANGUAGE TypeFamilies              #-}</span>
<span class="ot">></span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.Prelude</span>
<span class="ot">></span> <span class="kw">import </span><span class="dt">Diagrams.Backend.SVG.CmdLine</span>
<span class="ot">></span>
<span class="ot">> myCircle ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> myCircle <span class="fu">=</span> circle <span class="dv">1</span>
<span class="ot">></span>
<span class="ot">></span> main <span class="fu">=</span> mainWith myCircle</code></pre></div></div><p>Turning off the Dreaded Monomorphism Restriction is quite important:
if you don't, you will almost certainly run into it (and be very
confused by the resulting error messages).  The other two extensions
are not needed for this simple example in particular, but are often
required by diagrams in general, so it doesn't hurt to include them as
a matter of course.</p><div class="warning bs-callout bs-callout-warning"><p>This tutorial assumes the latest version of <code>diagrams</code> (namely,
1.4). If you get an error message saying <code>Expecting one more
argument to 'Diagram B'</code>, it means you have an older (1.2 or older)
version of <code>diagrams</code> installed.  We recommend <a class="reference external" href="https://wiki.haskell.org/Diagrams/Dev/Migrate1.4">upgrading to the
latest version</a>.</p></div><p>The first <code class="sourceCode">import</code> statement brings into scope the entire diagrams DSL
and standard library, as well as a few things from other libraries
re-exported for convenience.  The second <code class="sourceCode">import</code> is so that we can
use the SVG backend for rendering diagrams.  Among other things, it
provides the function <code class="sourceCode">mainWith</code>, which takes a diagram as input (in
this case, a circle of radius 1) and creates a command-line-driven
application for rendering it.</p><p>Let's compile and run it:</p><pre><code>$ ghc --make DiagramsTutorial.lhs
[1 of 1] Compiling Main             ( DiagramsTutorial.lhs, DiagramsTutorial.o )
Linking DiagramsTutorial ...
$ ./DiagramsTutorial -o circle.svg -w 400</code></pre><p>If you now view <code class="sourceCode">circle<span class="fu">.</span>svg</code> in your favorite web browser, you should
see an unfilled black circle on a white background (actually, it's on
a transparent background, but most browsers use white):</p><div class="exampleimg"><div style="text-align: center"><img src="images/1d707ce3132f040f.png" width="500" height="200" /></div></div><p>Be careful not to omit the <code>-w 400</code> argument!  This specifies that the
width of the output file should be 400 units, and the height should
be determined automatically.  You can also specify just a height
(using <code class="sourceCode"><span class="fu">-</span>h</code>), or both a width and a height if you know the exact
dimensions of the output image you want (note that the diagram will
not be stretched; extra padding will be added if the aspect ratios do
not match).  If you do not specify a width or a height, the absolute
scale of the diagram itself will be used, which in this case would be
rather tiny—only 2x2.</p><p>There are several more options besides <code class="sourceCode"><span class="fu">-</span>o</code>, <code class="sourceCode"><span class="fu">-</span>w</code>, and <code class="sourceCode"><span class="fu">-</span>h</code>; you can
see what they are by typing <code class="sourceCode"><span class="fu">./</span><span class="dt">DiagramsTutorial</span> <span class="co">--help</span></code>.  One
particularly useful option is <code class="sourceCode"><span class="fu">-</span>l</code>, which puts the program into "looped
mode": it will watch the source file for changes, and then
automatically recompile and rerun itself, like this:</p><pre><code>augustine :: src/diagrams/tmp » ./DiagramsTutorial -o circle.svg -w 400 -l
Looping turned on
Using sandbox /home/brent/build/diagrams/.cabal-sandbox
Watching source file DiagramsTutorial.lhs
Compiling target: DiagramsTutorial
Program args: -o circle.svg -w 400
Modified 02:41:42 ... compiling ... running ... done.
Modified 02:41:50 ... compiling ... running ... done.</code></pre><p>With looped mode, you only need to edit and save the source code, then
reload the image in your browser or image viewer.</p><p>The <code class="sourceCode">mainWith</code> function is also quite a bit more general than
accepting just a diagram: it can accept animations, lists of diagrams,
association lists of names and diagrams, or functions producing any of
the above.  For more information, see the <a class="reference external" href="cmdline.html">diagrams command-line
creation tutorial</a>.</p><p>A few miscellaneous notes:</p><ul><li><p>Diagrams does not require the use of <a class="reference external" href="https://wiki.haskell.org/Literate_programming">literate Haskell</a> (<code>.lhs</code>)
files; normal <code>.hs</code> files work perfectly well.  However, we
suggest using <code>.lhs</code> while following diagrams tutorials, since you
will be able to easily copy and paste sections of text and code from
the tutorial page into your editor without reformatting it.</p></li><li><p>The type signature on <code>myCircle :: Diagram B</code> is needed to inform the
diagrams framework which backend you intend to use for rendering
(every backend exports <code>B</code> as a synonym for itself).  Without the
type signature, you are likely to get type errors about ambiguous
type variables.  You can often get away with putting just one type
signature on the final diagram to be rendered, and letting GHC infer
the rest, though including more type signatures can also be helpful.</p></li></ul></div><div class="section" id="attributes"><h1>Attributes</h1><p>Suppose we want our circle to be blue, with a thick dashed purple
outline (there's no accounting for taste!).  We can apply attributes to
the <code class="sourceCode">circle</code> diagram with the <code class="sourceCode">(<span class="fu">#</span>)</code> operator:</p><div class="warning bs-callout bs-callout-warning"><p>You may need to include a type signature to build the examples that
follow.  We omit <code class="sourceCode"><span class="ot">example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span></code> in the examples below.</p></div><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/fec59676a5674a5f.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> fc blue
<span class="ot">></span>                    <span class="fu">#</span> lw veryThick
<span class="ot">></span>                    <span class="fu">#</span> lc purple
<span class="ot">></span>                    <span class="fu">#</span> dashingG [<span class="fl">0.2</span>,<span class="fl">0.05</span>] <span class="dv">0</span></code></pre></div></div></div><p>There's actually nothing special about the <code class="sourceCode">(<span class="fu">#</span>)</code> operator: it's just
reverse function application, that is,</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> x <span class="fu">#</span> f <span class="fu">=</span> f x</code></pre></div></div><p>Just to illustrate,</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/7df7bc5541499765.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> dashingG [<span class="fl">0.2</span>,<span class="fl">0.05</span>] <span class="dv">0</span> <span class="fu">.</span> lc purple <span class="fu">.</span> lw veryThick <span class="fu">.</span> fc blue
<span class="ot">></span>         <span class="fu">$</span> circle <span class="dv">1</span></code></pre></div></div></div><p>produces exactly the same diagram as before.  So why bother with
<code class="sourceCode">(<span class="fu">#</span>)</code>?  First, it's often more natural to write (and easier to read)
what a diagram <em>is</em> first, and what it is <em>like</em> second.  Second,
<code class="sourceCode">(<span class="fu">#</span>)</code> has a high precedence (namely, 8), making it more convenient to
combine diagrams with specified attributes.  For example,</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/d7ad6bc065f64e27.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> fc red <span class="fu">#</span> lw none <span class="fu">|||</span> circle <span class="dv">1</span> <span class="fu">#</span> fc green <span class="fu">#</span> lw none</code></pre></div></div></div><p>places a red circle with no border next to a green circle with no
border (we'll see more about the <code class="sourceCode">(<span class="fu">|||</span>)</code> operator shortly). Without
<code class="sourceCode">(<span class="fu">#</span>)</code> we would have to write something with more parentheses, like</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> (fc red <span class="fu">.</span> lw none <span class="fu">$</span> circle <span class="dv">1</span>) <span class="fu">|||</span> (fc green <span class="fu">.</span> lw none <span class="fu">$</span> circle <span class="dv">1</span>)</code></pre></div></div><p>For information on other standard attributes, see the
<code>Diagrams.Attributes</code> and <code>Diagrams.TwoD.Attributes</code>
modules.</p></div><div class="section" id="combining-diagrams"><h1>Combining diagrams</h1><p>OK, so we can draw a single circle: boring!  Much of the power of the
diagrams framework, of course, comes from the ability to build up
complex diagrams by <em>combining</em> simpler ones.</p><p>Let's start with the most basic way of combining two diagrams:
superimposing one diagram on top of another.  We can accomplish this
with <code class="sourceCode">atop</code>:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/807ee03c4b4a426f.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> fc aqua <span class="ot">`atop`</span> circle <span class="dv">1</span></code></pre></div></div></div><p>(Incidentally, these colors are coming from the
<code>Data.Colour.Names</code> module.)</p><p>"Putting one thing on top of another" sounds rather vague: how do we
know exactly where the circle and square will end up relative to one
another?  To answer this question, we must introduce the fundamental
notion of a <em>local origin</em>.</p><div class="section" id="local-origins"><h2>Local origins</h2><p>Every diagram has a distinguished point called its <em>local origin</em>.
Many operations on diagrams—such as <code class="sourceCode">atop</code>—work somehow with
respect to the local origin.  <code class="sourceCode">atop</code> in particular works by
superimposing two diagrams so that their local origins coincide (and
this point becomes the local origin of the new, combined diagram).</p><p>The <code class="sourceCode">showOrigin</code> function is provided for conveniently visualizing the
local origin of a diagram.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/d9290e274a8caca0.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> showOrigin</code></pre></div></div></div><p>Not surprisingly, the local origin of <code class="sourceCode">circle</code> is at its center.  So
is the local origin of <code class="sourceCode">square</code>.  This is why <code>square 1 `atop` circle 1</code>
produces a square centered on a circle.</p></div><div class="section" id="side-by-side"><h2>Side-by-side</h2><p>Another fundamental way to combine two diagrams is by placing them
<em>next to</em> each other.  The <code class="sourceCode">(<span class="fu">|||</span>)</code> and <code class="sourceCode">(<span class="fu">===</span>)</code> operators let us
conveniently put two diagrams next to each other in the horizontal or
vertical directions, respectively.  For example, horizontal:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/30870113110129e3.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">|||</span> square <span class="dv">2</span></code></pre></div></div></div><p>and vertical:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/538b8e3012484eb2.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">===</span> square <span class="dv">2</span></code></pre></div></div></div><p>The two diagrams are arranged next to each other so that their local
origins are on the same horizontal or vertical line.  As you can
ascertain for yourself with <code class="sourceCode">showOrigin</code>, the local origin of the new,
combined diagram coincides with the local origin of the first diagram.</p><p>The <code class="sourceCode">hcat</code> and <code class="sourceCode">vcat</code> functions are provided for laying out an entire
<em>list</em> of diagrams horizontally or vertically:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/313ff213dffdd115.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> circles <span class="fu">=</span> hcat (map circle [<span class="dv">1</span><span class="fu">..</span><span class="dv">6</span>])
<span class="ot">></span> example <span class="fu">=</span> vcat (replicate <span class="dv">3</span> circles)</code></pre></div></div></div><p>See also <code class="sourceCode">hsep</code> and <code class="sourceCode">vsep</code> for including space in between subsequent
diagrams.</p><p><code class="sourceCode">(<span class="fu">|||</span>)</code> and <code class="sourceCode">(<span class="fu">===</span>)</code> are actually just convenient specializations of
the more general <code class="sourceCode">beside</code> combinator. <code class="sourceCode">beside</code> takes as arguments a
<em>vector</em> and two diagrams, and places them next to each other "along
the vector"—that is, in such a way that the vector points from the
local origin of the first diagram to the local origin of the second.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/d9ab7d790f0b3ee5.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> circleSqV1 <span class="fu">=</span> beside (r2 (<span class="dv">1</span>,<span class="dv">1</span>)) (circle <span class="dv">1</span>) (square <span class="dv">2</span>)
<span class="ot">></span>
<span class="ot">></span> circleSqV2 <span class="fu">=</span> beside (r2 (<span class="dv">1</span>,<span class="fu">-</span><span class="dv">2</span>)) (circle <span class="dv">1</span>) (square <span class="dv">2</span>)
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hcat [circleSqV1, strutX <span class="dv">1</span>, circleSqV2]</code></pre></div></div></div><p>Notice how we use the <code class="sourceCode">r2</code> function to create a 2D vector from a pair
of coordinates; see the <a class="reference external" href="vector.html">vectors and points tutorial</a> for more.</p></div><div class="section" id="envelopes"><h2>Envelopes</h2><p>How does the diagrams library figure out how to place two diagrams
"next to" each other?  And what exactly does "next to" mean?  There
are many possible definitions of "next to" that one could imagine
choosing, with varying degrees of flexibility, simplicity, and
tractability.  The definition of "next to" adopted by diagrams is as
follows:</p><p>To place two diagrams next to each other in the direction
of a vector <em>v</em>, place them as close as possible so that there is a
<em>separating line</em> perpendicular to <em>v</em>; that is, a line perpendicular
to <em>v</em> such that the first diagram lies completely on one side of the
line and the other diagram lies completely on the other side.</p><p>There are certainly some tradeoffs in this choice. The biggest
downside is that adjacent diagrams sometimes end up with undesired
space in between them.  For example, the two rotated ellipses in the
diagram below have some space between them. (Try adding a vertical
line between them with <code class="sourceCode">vrule</code> and you will see why.)</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/bcfca99c72cf1fc6.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> ell <span class="fu">|||</span> ell
<span class="ot">></span>   <span class="kw">where</span> ell <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> scaleX <span class="fl">0.5</span> <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">6</span>)</code></pre></div></div></div><p>However:</p><ul><li><p>This rule is very <em>simple</em>, in that it is easy to predict what will
happen when placing two diagrams next to each other.</p></li><li><p>It is also <em>tractable</em>.  Every diagram carries along with it an
"envelope"—a function which takes as input a vector <em>v</em>, and returns
the minimum distance to a separating line from the local origin in the
direction of <em>v</em>.  When composing two diagrams with <code class="sourceCode">atop</code> we take the
pointwise maximum of their envelopes; to place two diagrams
next to each other we use their envelopes to decide how to
reposition their local origins before composing them with <code class="sourceCode">atop</code>.</p></li></ul><p>Happily, in this particular case, it <em>is</em> possible to place the
ellipses tangent to one another (though this solution is not quite as
general as one might hope):</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/6da81b0b7c1529af.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> ell <span class="fu">#</span> snugR <span class="fu"><></span> ell <span class="fu">#</span> snugL
<span class="ot">></span>   <span class="kw">where</span> ell <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> scaleX <span class="fl">0.5</span> <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">6</span>)</code></pre></div></div></div><p>The <code class="sourceCode">snug</code> class of functions use diagrams' <em>trace</em> (something like an
embedded raytracer) rather than their envelope.  (For more information,
see <code>Diagrams.TwoD.Align</code> and the <a class="reference external" href="manual.html#traces">user manual section on
traces</a>.)</p></div></div><div class="section" id="transforming-diagrams"><h1>Transforming diagrams</h1><p>As you would expect, there is a range of standard functions available
for transforming diagrams, such as:</p><ul><li><p><code class="sourceCode">scale</code> (scale uniformly)</p></li><li><p><code class="sourceCode">scaleX</code> and <code class="sourceCode">scaleY</code> (scale in the X or Y axis only)</p></li><li><p><code class="sourceCode">rotate</code> (rotate by an Angle)</p></li><li><p><code class="sourceCode">rotateBy</code> (rotate by a fraction of a circle)</p></li><li><p><code class="sourceCode">reflectX</code> and <code class="sourceCode">reflectY</code> for reflecting along the X and Y axes</p></li></ul><p>For example:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/fc4bbe173e1fcbde.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> circleRect  <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> scale <span class="fl">0.5</span> <span class="fu">|||</span> square <span class="dv">1</span> <span class="fu">#</span> scaleX <span class="fl">0.3</span>
<span class="ot">></span>
<span class="ot">></span> circleRect2 <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> scale <span class="fl">0.5</span> <span class="fu">|||</span> square <span class="dv">1</span> <span class="fu">#</span> scaleX <span class="fl">0.3</span>
<span class="ot">></span>                                                 <span class="fu">#</span> rotateBy (<span class="dv">1</span><span class="fu">/</span><span class="dv">6</span>)
<span class="ot">></span>                                                 <span class="fu">#</span> scaleX <span class="fl">0.5</span>
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hcat [circleRect, strutX <span class="dv">1</span>, circleRect2]</code></pre></div></div></div><p>(Of course, <code class="sourceCode">circle <span class="dv">1</span> <span class="fu">#</span> scale <span class="fl">0.5</span></code> would be better written as just <code class="sourceCode">circle <span class="fl">0.5</span></code>.)</p><div class="section" id="translation"><h2>Translation</h2><p>Of course, there are also translation transformations like
<code class="sourceCode">translate</code>, <code class="sourceCode">translateX</code>, and <code class="sourceCode">translateY</code>.  These operations
translate a diagram within its <em>local vector space</em>—that is,
relative to its local origin.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/c437509673d74e45.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> circle <span class="dv">1</span> <span class="fu">#</span> translate (r2 (<span class="fl">0.5</span>, <span class="fl">0.3</span>)) <span class="fu">#</span> showOrigin</code></pre></div></div></div><p>As the above example shows, translating a diagram by <code class="sourceCode">(<span class="fl">0.5</span>, <span class="fl">0.3</span>)</code> is
the same as moving its local origin by <code class="sourceCode">(<span class="fu">-</span><span class="fl">0.5</span>, <span class="fu">-</span><span class="fl">0.3</span>)</code>.</p><p>Since diagrams are always composed with respect to their local
origins, translation can affect the way diagrams are composed.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/50d2432374afc5e9.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> circleSqT   <span class="fu">=</span> square <span class="dv">1</span> <span class="ot">`atop`</span> circle <span class="dv">1</span> <span class="fu">#</span> translate (r2 (<span class="fl">0.5</span>, <span class="fl">0.3</span>))
<span class="ot">></span> circleSqHT  <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">|||</span> circle <span class="dv">1</span> <span class="fu">#</span> translate (r2 (<span class="fl">0.5</span>, <span class="fl">0.3</span>))
<span class="ot">></span> circleSqHT2 <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">|||</span> circle <span class="dv">1</span> <span class="fu">#</span> translate (r2 (<span class="fl">19.5</span>, <span class="fl">0.3</span>))
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> hcat [circleSqT, strutX <span class="dv">1</span>, circleSqHT, strutX <span class="dv">1</span>, circleSqHT2]</code></pre></div></div></div><p>As <code class="sourceCode">circleSqHT</code> and <code class="sourceCode">circleSqHT2</code> demonstrate, when we place a
translated circle next to a square, it doesn't matter how much the
circle was translated in the <em>horizontal</em> direction—the square and
circle will always simply be placed next to each other.  The vertical
direction matters, though, since the local origins of the square and
circle are placed on the same horizontal line.</p></div><div class="section" id="aligning"><h2>Aligning</h2><p>It's quite common to want to <em>align</em> some diagrams in a certain way
when placing them next to one another—for example, we might want a
horizontal row of diagrams aligned along their top edges.  The
<em>alignment</em> of a diagram simply refers to its position relative to its
local origin, and convenient alignment functions are provided for
aligning a diagram with respect to its envelope.  For example,
<code class="sourceCode">alignT</code> translates a diagram in a vertical direction so that its
local origin ends up exactly on the edge of its envelope.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/a7e192fcf5c7ffc3.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> hrule (<span class="dv">2</span> <span class="fu">*</span> sum sizes) <span class="fu">===</span> circles <span class="fu">#</span> centerX
<span class="ot">></span>   <span class="kw">where</span> circles <span class="fu">=</span> hcat <span class="fu">.</span> map alignT <span class="fu">.</span> zipWith scale sizes
<span class="ot">></span>                 <span class="fu">$</span> repeat (circle <span class="dv">1</span>)
<span class="ot">></span>         sizes   <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">7</span>,<span class="dv">1</span>,<span class="dv">3</span>]</code></pre></div></div></div><p>See <code>Diagrams.TwoD.Align</code> for other alignment combinators.</p></div></div><div class="section" id="diagrams-as-a-monoid"><h1>Diagrams as a monoid</h1><p>As you may have already suspected if you are familiar with monoids,
diagrams form a monoid under <code class="sourceCode">atop</code>.  This means that you can use
<code class="sourceCode">(<span class="fu"><></span>)</code> instead of <code class="sourceCode">atop</code> to superimpose two diagrams.  It also means
that <code class="sourceCode">mempty</code> is available to construct the "empty diagram", which
takes up no space and produces no output.</p><p>Quite a few other things in the diagrams standard library are also
monoids (transformations, trails, paths, styles, colors, envelopes,
traces...).</p></div><div class="section" id="a-worked-example"><h1>A worked example</h1><p>As a way of exhibiting a complete example and introducing some
additional features of diagrams, consider trying to draw the following
picture:</p><div class="exampleimg"><div style="text-align: center"><img src="images/547534f56c854db5.png" width="500" height="200" /></div></div><p>This features a hexagonal arrangement of numbered nodes, with an arrow
from node \(i\) to node \(j\) whenever \(i &lt; j\).  While
we're at it, we might as well make our program generic in the number
of nodes, so it generates a whole family of similar diagrams.</p><p>The first thing to do is place the nodes.  We can use the <code class="sourceCode">regPoly</code>
function to produce a regular polygon with sides of a given length. (In
this case we want to hold the side length constant, rather than the
radius, so that we can simply make the nodes a fixed size.  To create
polygons with a fixed radius as well as many other types of polygons,
use the <code class="sourceCode">polygon</code> function.)</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/c6c7a023eb9e43be.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> example <span class="fu">=</span> regPoly <span class="dv">6</span> <span class="dv">1</span></code></pre></div></div></div><p>However, <code class="sourceCode">regPoly</code> (and most other functions for describing shapes)
can be used to produce not just a diagram, but also a <em>trail</em> or
<em>path</em>.  Loosely speaking, trails are purely geometric,
one-dimensional tracks through space, and paths are collections of
trails; see the <a class="reference external" href="paths.html">tutorial on trails and paths</a> for a more detailed
account.  Trails and paths can be explicitly manipulated and computed
with, and used, for example, to describe and position other
diagrams. In this case, we can use the <code class="sourceCode">trailVertices</code> and <code class="sourceCode">atPoints</code>
functions to
place nodes at the vertices of the trail produced by <code class="sourceCode">regPoly</code>:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/c00c4f07dc25e362.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">></span> node    <span class="fu">=</span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc green
<span class="ot">></span> example <span class="fu">=</span> atPoints (trailVertices <span class="fu">$</span> regPoly <span class="dv">6</span> <span class="dv">1</span>) (repeat node)</code></pre></div></div></div><p>As a next step, we can add text labels to the nodes.  For quick and
dirty text, we can use the <code class="sourceCode">text</code> function provided by
<span class="package"><a href="http://hackage.haskell.org/package/diagrams-lib"><code>diagrams-lib</code></a></span>. (For more sophisticated text support, see the
<span class="package"><a href="http://hackage.haskell.org/package/SVGFonts"><code>SVGFonts</code></a></span> package.) While we are at it, we also abstract over
the number of nodes:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/d8c3b1afc7aaac88.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> node ::</span> <span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> node n <span class="fu">=</span> text (show n) <span class="fu">#</span> fontSizeL <span class="fl">0.2</span> <span class="fu">#</span> fc white <span class="fu"><></span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc green
<span class="ot">></span>
<span class="ot">> tournament ::</span> <span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> tournament n <span class="fu">=</span> atPoints (trailVertices <span class="fu">$</span> regPoly n <span class="dv">1</span>) (map node [<span class="dv">1</span><span class="fu">..</span>n])
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> tournament <span class="dv">5</span></code></pre></div></div></div><p>Note the use of the type <code class="sourceCode"><span class="dt">B</span></code>, which is exported by every backend as a
synonym for its particular backend type tag.  This makes it easier to
switch between backends while still giving explicit type signatures for
your code: in contrast to a type like <code class="sourceCode"><span class="dt">Diagram</span> <span class="dt">SVG</span></code> which is
explicitly tied to a particular backend and would have to be changed
when switching to a different backend, the <code class="sourceCode"><span class="dt">B</span></code> in <code class="sourceCode"><span class="dt">Diagram</span> <span class="dt">B</span></code> will
get instantiated to whichever backend happens to be in scope.</p><p>Our final task is to connect the nodes with arrows.  First, in order
to specify the parts of the diagram between which arrows should be
drawn, we need to give <em>names</em> to the nodes, using the <code class="sourceCode">named</code>
function:</p><div class="examplesrc"><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> node ::</span> <span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> node n <span class="fu">=</span> text (show n) <span class="fu">#</span> fontSizeL <span class="fl">0.2</span> <span class="fu">#</span> fc white
<span class="ot">></span>       <span class="fu"><></span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc green <span class="fu">#</span> named n
<span class="ot">></span>
<span class="ot">> tournament ::</span> <span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> tournament n <span class="fu">=</span> atPoints (trailVertices <span class="fu">$</span> regPoly n <span class="dv">1</span>) (map node [<span class="dv">1</span><span class="fu">..</span>n])</code></pre></div></div><p>Note the addition of <code class="sourceCode"><span class="fu">...</span> <span class="fu">#</span> named n</code> to the circles making up the nodes.
This doesn't yet change the picture in any way, but it sets us up to
describe arrows between the nodes.  We can use values of arbitrary
type (subject to a few restrictions) as names; in this case the
obvious choice is the <code class="sourceCode"><span class="dt">Int</span></code> values corresponding to the nodes
themselves.  (See the <a class="reference external" href="manual.html#named-subdiagrams">user manual section on named subdiagrams</a> for
more.)</p><p>The <code>Diagrams.TwoD.Arrow</code> module provides a number of tools for
drawing arrows (see also the <a class="reference external" href="manual.html#arrows">user manual section on arrows</a> and the
<a class="reference external" href="arrow.html">arrow tutorial</a>). In this case, we can use the <code class="sourceCode">connectOutside</code>
function to draw an arrow between the outer edges of two named
objects.  Here we connect nodes 1 and 2:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/3535b3d742fadfcd.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> node ::</span> <span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> node n <span class="fu">=</span> text (show n) <span class="fu">#</span> fontSizeL <span class="fl">0.2</span> <span class="fu">#</span> fc white
<span class="ot">></span>       <span class="fu"><></span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc green <span class="fu">#</span> named n
<span class="ot">></span>
<span class="ot">> tournament ::</span> <span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> tournament n <span class="fu">=</span> atPoints (trailVertices <span class="fu">$</span> regPoly n <span class="dv">1</span>) (map node [<span class="dv">1</span><span class="fu">..</span>n])
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> tournament <span class="dv">6</span> <span class="fu">#</span> connectOutside (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span>)</code></pre></div></div></div><p>(The type annotations on <code class="sourceCode"><span class="dv">1</span></code> and <code class="sourceCode"><span class="dv">2</span></code> are necessary since numeric
literals are polymorphic and we can use names of any type.)</p><p>This won't do, however; we want to leave some space between the nodes and the
ends of the arrows, and to use a slightly larger arrowhead.  Fortunately, the
arrow-drawing code is highly configurable.  Instead of
<code class="sourceCode">connectOutside</code> we can use its sibling function <code class="sourceCode">connectOutside'</code>
(note the prime) which takes an extra record of options controlling the way
arrows are drawn.  We want to override the default arrowhead size as
well as specify gaps before and after the arrow, which we do as
follows:</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/45b66fb6e34ba0cb.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> node ::</span> <span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> node n <span class="fu">=</span> text (show n) <span class="fu">#</span> fontSizeL <span class="fl">0.2</span> <span class="fu">#</span> fc white
<span class="ot">></span>       <span class="fu"><></span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc green <span class="fu">#</span> named n
<span class="ot">></span>
<span class="ot">> tournament ::</span> <span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> tournament n <span class="fu">=</span> atPoints (trailVertices <span class="fu">$</span> regPoly n <span class="dv">1</span>) (map node [<span class="dv">1</span><span class="fu">..</span>n])
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> tournament <span class="dv">6</span>
<span class="ot">></span>   <span class="fu">#</span> connectOutside' (with <span class="fu">&</span> gaps       <span class="fu">.~</span> small
<span class="ot">></span>                           <span class="fu">&</span> headLength <span class="fu">.~</span> local <span class="fl">0.15</span>
<span class="ot">></span>                     )
<span class="ot">></span>     (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) (<span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span>)</code></pre></div></div></div><p><code class="sourceCode">with</code> is a convenient name for the default arguments record, and we
update it using the <span class="package"><a href="http://hackage.haskell.org/package/lens"><code>lens</code></a></span> library.  (This pattern is common
throughout diagrams; See <a class="reference external" href="manual.html#faking-optional-named-arguments">the user manual section on optional named
arguments</a>.)</p><p>Now we simply need to call <code class="sourceCode">connectOutside'</code> for each pair of nodes.
<code class="sourceCode">applyAll</code>, which applies a list of functions, is useful in this sort
of situation.</p><div class="dia-lhs panel panel-default"><div class="panel-body"><div style="text-align: center"><img src="images/92868bbb788ab37d.png" width="500" height="200" /></div><div class="sourceCode"><pre class="sourceCode"><code class="sourceCode"><span class="ot">> node ::</span> <span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> node n <span class="fu">=</span> text (show n) <span class="fu">#</span> fontSizeL <span class="fl">0.2</span> <span class="fu">#</span> fc white
<span class="ot">></span>       <span class="fu"><></span> circle <span class="fl">0.2</span> <span class="fu">#</span> fc green <span class="fu">#</span> named n
<span class="ot">></span>
<span class="ot">></span> arrowOpts <span class="fu">=</span> with <span class="fu">&</span> gaps       <span class="fu">.~</span> small
<span class="ot">></span>                  <span class="fu">&</span> headLength <span class="fu">.~</span> local <span class="fl">0.15</span>
<span class="ot">></span>
<span class="ot">> tournament ::</span> <span class="dt">Int</span> <span class="ot">-></span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">></span> tournament n <span class="fu">=</span> atPoints (trailVertices <span class="fu">$</span> regPoly n <span class="dv">1</span>) (map node [<span class="dv">1</span><span class="fu">..</span>n])
<span class="ot">></span>   <span class="fu">#</span> applyAll [connectOutside' arrowOpts j k <span class="fu">|</span> j <span class="ot"><-</span> [<span class="dv">1</span> <span class="fu">..</span> n<span class="fu">-</span><span class="dv">1</span>], k <span class="ot"><-</span> [j<span class="fu">+</span><span class="dv">1</span> <span class="fu">..</span> n]]
<span class="ot">></span>
<span class="ot">></span> example <span class="fu">=</span> tournament <span class="dv">6</span></code></pre></div></div></div><p>Voilá!</p></div><div class="section" id="next-steps"><h1>Next steps</h1><p>This tutorial has really only scratched the surface of what is
possible! Here are pointers to some resources for learning more:</p><ul><li><p>There are <a class="reference external" href="../documentation.html">other tutorials on more specific topics</a> available.  For
example, there is a tutorial on <a class="reference external" href="vector.html">working with vectors and points</a>,
one on <a class="reference external" href="paths.html">trails and paths</a>, one on drawing <a class="reference external" href="arrow.html">arrows</a> between things,
one on construting <a class="reference external" href="cmdline.html">command-line driven interfaces</a>, and others.</p></li><li><p>The diagrams <a class="reference external" href="manual.html">user manual</a> goes into much more depth on all the
topics covered in this tutorial, plus many others, and includes lots
of illustrative examples.  If there is anything in the manual that
you find unclear, confusing, or omitted, please <a class="reference external" href="http://github.com/diagrams/diagrams-doc/issues">report it as a
bug</a>!</p></li><li><p>The diagrams-lib API is generally well-documented; start with the
documentation for <code>Diagrams.Prelude</code>, and then drill down from
there to learn about whatever you are interested in.  If there is
anything in the API documentation that you find unclear or
confusing, please <a class="reference external" href="http://github.com/diagrams/diagrams/issues">report it as a bug as well</a>!</p></li><li><p>If you run into difficulty or have any questions, join the
<code>#diagrams</code> IRC channel on freenode.org, or the <a class="reference external" href="http://groups.google.com/group/diagrams-discuss">diagrams-discuss
mailing list</a>.</p></li></ul></div></div></div></div>

    </div>

    </div> <!-- #wrap -->

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/bootstrap-docs-application.js"></script>
    <script src="../js/hoogle-search.js"></script>
  </body>
</html>
