<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Diagrams - Quasifuchsian</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <!-- Bootstrap -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="../css/bootstrap.min.css" rel="stylesheet" />
    <link href="../css/sticky-footer-navbar.css" rel="stylesheet" />
    <link href="../css/callout.css" rel="stylesheet" />
    <link href="../css/doc.css" rel="stylesheet" />
    <link href="../css/bootstrap-docs.css" rel="stylesheet" />
    <link href="../css/home.css" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <link rel="shortcut icon" href="../diagrams.ico" />

    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>

    <div id="wrap">

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">diagrams</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav pull-right">
            <li><a href="../">Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
              <ul class="dropdown-menu">
		<li><a href="../download.html">Installation</a></li>
		<li class="divider"></li>
 		<li><a href="../tutorials.html">Tutorials</a></li>
		<li><a href="../doc/manual.html">User manual</a></li>
                <li><a href="../haddock/index.html">API reference (Haddocks)</a></li>
                <li><a href="../doc/core.html">Core library reference</a></li>
		<li class="divider"></li>
		<li><a href="http://haskell.org/haskellwiki/Diagrams">Wiki</a></li>
		<li><a href="../releases.html">Releases / changelogs</a></li>
              </ul>
            </li>
	    <li><a href="../gallery.html">Gallery</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <b class="caret"></b></a>
	      <ul class="dropdown-menu">
		<li><a href="http://webchat.freenode.net?channels=diagrams">IRC channel</a></li>
		<li><a href="http://groups.google.com/group/diagrams-discuss">Mailing
		    list</a></li>
                <li><a href="https://github.com/diagrams">Github</a></li>
		<li><a href="../sightings.html">Sightings</a></li>
		<li><a href="../community.html">Get involved</a></li>
              </ul>
	    </li>
            <li><a href="../blog/index.html">Blog</a></li>
	    <li>
	        <form id="search" class="navbar-form navbar-left" role="search" method="get" action="http://haskell.org/hoogle">
	            <div class="form-group">
	                <input id="hoogle" name="hoogle" type="text" class="form-control" placeholder="API Search">
	            </div>
	        </form>
	    </li>
	   </ul>
        </div>
      </div>
    </div>
    
    <div class="container" style="padding-top: 60px;">
      <div id="examplesrc">

<p>Quasifuchsian limit circles of Schottky groups of Moebius transformations.</p>

<div class="exampleimg" style="text-align: center">
<img src="../gallery/images/Quasifuchsian.big.png" width="400" height="400" />
</div>
Author: <b><a href="http://apfelmus.nfshost.com/">Heinrich Apfelmus</a></b>

<p><span style="font-size: small"><a href="../gallery/Quasifuchsian.lhs">Download raw source code</a></span><br /></p>

<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Diagrams.Backend.SVG.CmdLine</span></span></code></pre></div>
<p>Quasifuchsian limit circles of Schottky groups of Moebius transformations. Sounds very pretentious. Connoisseurs may want to direct their monocles towards the tome <a href="http://en.wikipedia.org/wiki/Indra's_Pearls_%28book%29">“Indra’s Pearls: The Vision of Felix Klein”</a> wherein the extraordinary circumstances behind these images are revealed.</p>
<p>The fractals presented here are a good example why declarative image generation should be done in a full programming language.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Diagrams.Prelude</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Colour</span> <span class="kw">as</span> <span class="dt">C</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Colour.SRGB</span> (sRGB24read)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Complex</span> <span class="kw">as</span> <span class="dt">Complex</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Array</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span></span></code></pre></div>
<h1 id="moebius-transformations">Moebius Transformations</h1>
<p>We are dealing with complex numbers.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">C</span> <span class="ot">=</span> <span class="dt">Complex</span> <span class="dt">Double</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>i <span class="ot">=</span> <span class="dv">0</span> <span class="op">:+</span> <span class="dv">1</span></span></code></pre></div>
<p>A <em>Moebius transformation</em> is a mapping of the (projective) complex plane <code>C</code> onto itself, given by a linear fractional transformation \(z \to \frac{az+b}{cz+d}\).</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Moebius</span> <span class="ot">=</span> <span class="dt">M</span> <span class="op">!</span><span class="dt">C</span> <span class="op">!</span><span class="dt">C</span> <span class="op">!</span><span class="dt">C</span> <span class="op">!</span><span class="dt">C</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ot">applyMoebius ::</span> <span class="dt">Moebius</span> <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="ot">-&gt;</span> <span class="dt">C</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>applyMoebius (<span class="dt">M</span> a b c d) z <span class="ot">=</span> (a<span class="op">*</span>z <span class="op">+</span> b) <span class="op">/</span> (c<span class="op">*</span>z <span class="op">+</span> d)</span></code></pre></div>
<p>Moebius transformations form a <em>group</em>. The composition of Moebius transformations follows the well-known laws for matrix multiplcation</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Moebius</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">M</span> a b c d) <span class="op">&lt;&gt;</span> (<span class="dt">M</span> a1 b1 c1 d1) <span class="ot">=</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">M</span> (a<span class="op">*</span>a1 <span class="op">+</span> b<span class="op">*</span>c1) (a<span class="op">*</span>b1 <span class="op">+</span> b<span class="op">*</span>d1) (c<span class="op">*</span>a1 <span class="op">+</span> d<span class="op">*</span>c1) (c<span class="op">*</span>b1 <span class="op">+</span> d<span class="op">*</span>d1)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Moebius</span> <span class="kw">where</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">M</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mappend</span> <span class="ot">=</span> (<span class="op">&lt;&gt;</span>)</span></code></pre></div>
<p>and so does taking their inverse.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inverse ::</span> <span class="dt">Moebius</span> <span class="ot">-&gt;</span> <span class="dt">Moebius</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>inverse (<span class="dt">M</span> a b c d) <span class="ot">=</span> <span class="dt">M</span> d (<span class="op">-</span>b) (<span class="op">-</span>c) a</span></code></pre></div>
<p>Our representation of Moebius transformations has one superfluous degree of freedom: we can scale the numbers \(a,b,c,d\) by a constant amount, but this will not change the transformation at all. The <em>determinant</em> of the matrix can be normalized to 1.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">det ::</span> <span class="dt">Moebius</span> <span class="ot">-&gt;</span> <span class="dt">C</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>det (<span class="dt">M</span> a b c d) <span class="ot">=</span> a<span class="op">*</span>d <span class="op">-</span> b<span class="op">*</span>c</span></code></pre></div>
<p>Every Moebius transformation has two fixed points. (They may be located at infinity and they may coincide.)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fixpoints ::</span> <span class="dt">Moebius</span> <span class="ot">-&gt;</span> (<span class="dt">C</span>,<span class="dt">C</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>fixpoints (<span class="dt">M</span> a b c d) <span class="ot">=</span> solveQuadratic c (d<span class="op">-</span>a) (<span class="op">-</span>b)</span></code></pre></div>
<p>Moebius transformations can be classified up to conjugation by moving the fixed points to 0 and ∞. For more details, see Note 3.5 in the <a href="http://en.wikipedia.org/wiki/Indra's_Pearls_%28book%29">book</a>.</p>
<p>The classification also gives a number called the <em>multiplier</em> associated to each Moebius transformation. Here, we only use it to find out which of the fixed points is the attractive fixpoint.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fixpointAttractive ::</span> <span class="dt">Moebius</span> <span class="ot">-&gt;</span> <span class="dt">C</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>fixpointAttractive moebius<span class="op">@</span>(<span class="dt">M</span> a b c d) <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> Complex.magnitude multiplier <span class="op">&gt;=</span> <span class="dv">1</span> <span class="kw">then</span> z2 <span class="kw">else</span> z1</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    multiplier <span class="ot">=</span> (a<span class="op">-</span>c<span class="op">*</span>z1) <span class="op">/</span> (a<span class="op">-</span>c<span class="op">*</span>z2)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    (z1,z2)    <span class="ot">=</span> fixpoints moebius</span></code></pre></div>
<h1 id="schottky-groups">Schottky groups</h1>
<p>In the following, we are concerned with groups generated by two Moebius transformations <code>a</code> and <code>b</code>, so-called Schottky groups. We want to plot the set of <em>limit points</em> of this group, which is the set of points in the complex plane that is left <em>invariant</em> under the action of both <code>a</code> and <code>b</code>. This set is a fractal and it turns out that for special choices of <code>a</code> and <code>b</code>, this set is connected, like a circle. For more on this, you will have to consult the <a href="http://en.wikipedia.org/wiki/Indra's_Pearls_%28book%29">book</a>.</p>
<p>The generators of the group are labeled with the letters <code>A</code> and <code>B</code>. <code>A1</code> corresponds to the inverse of <code>A</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Letter</span> <span class="ot">=</span> <span class="dt">A</span> <span class="op">|</span> <span class="dt">B</span> <span class="op">|</span> <span class="dt">A1</span> <span class="op">|</span> <span class="dt">B1</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Enum</span>,<span class="dt">Ix</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Word</span>   <span class="ot">=</span> [<span class="dt">Letter</span>]</span></code></pre></div>
<p>The <a href="http://en.wikipedia.org/wiki/Indra's_Pearls_%28book%29">book</a> explains in box 13, page 130 that limit points correspond to infinite words. A repeating word corresponds to a fixed point of a Moebius transformation. In other words, we know how to plot some limit points, namely those that correspond to repeating words.</p>
<p>Moreover, words with the same initial segments tend to be close together. That allows us to plot (an approximation to) the limit set by performing a <em>depth first search</em> (DFS), exploring initial word segments and stopping when their distance becomes small.</p>
<p>To draw the limit set in one single stroke, we have to enumerate the DFS in the right order. This takes some thought, presented on page 182 of the <a href="http://en.wikipedia.org/wiki/Indra's_Pearls_%28book%29">book</a>. It’s too long to be reproduced here, so you have to trust me on the following code.</p>
<p>Determine which words to explore next, in the right order</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>next <span class="dt">A</span>  <span class="ot">=</span> [<span class="dt">B1</span>,<span class="dt">A</span>,<span class="dt">B</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>next <span class="dt">B1</span> <span class="ot">=</span> [<span class="dt">A1</span>,<span class="dt">B1</span>,<span class="dt">A</span>]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>next <span class="dt">A1</span> <span class="ot">=</span> [<span class="dt">B</span>,<span class="dt">A1</span>,<span class="dt">B1</span>]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>next <span class="dt">B</span>  <span class="ot">=</span> [<span class="dt">A</span>,<span class="dt">B</span>,<span class="dt">A1</span>]</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>left    [a,b,c] <span class="ot">=</span> a</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>middle  [a,b,c] <span class="ot">=</span> b</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>right   [a,b,c] <span class="ot">=</span> c</span></code></pre></div>
<p>We will seed the plot with fixed points of <em>commutators</em>, for instance <code>[A,B,A1,B1]</code>. The choice of commutator depends on the letter we are currently exploring.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>commutatorLeft  x <span class="ot">=</span> <span class="fu">take</span> <span class="dv">4</span> <span class="op">$</span> <span class="fu">iterate</span> (left  <span class="op">.</span> next) x</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>commutatorRight x <span class="ot">=</span> <span class="fu">take</span> <span class="dv">4</span> <span class="op">$</span> <span class="fu">iterate</span> (right <span class="op">.</span> next) x</span></code></pre></div>
<p>Now for the function that enumerates points in the limit set</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">limitPoints ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Moebius</span> <span class="ot">-&gt;</span> <span class="dt">Moebius</span> <span class="ot">-&gt;</span> [<span class="dt">C</span>]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>limitPoints eps a b <span class="ot">=</span> points</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span></code></pre></div>
<p>First, we need to map letters to actual group elements</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    generators   <span class="ot">=</span> array (<span class="dt">A</span>,<span class="dt">B1</span>) [(<span class="dt">A</span>,a),(<span class="dt">B</span>,b),(<span class="dt">A1</span>,inverse a),(<span class="dt">B1</span>,inverse b)]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    fromLetter x <span class="ot">=</span> generators <span class="op">!</span> x</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    fromWord     <span class="ot">=</span> <span class="fu">mconcat</span> <span class="op">.</span> <span class="fu">map</span> fromLetter</span></code></pre></div>
<p>Then, we need the fixpoints of various Moebius transformations that correspond to commutators.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    mkFixpoints f <span class="ot">=</span> array (<span class="dt">A</span>,<span class="dt">B1</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>        [(x, fixpointAttractive <span class="op">.</span> fromWord <span class="op">.</span> f <span class="op">$</span> x) <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dt">A</span> <span class="op">..</span> <span class="dt">B1</span>]]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    commutatorsLeft  <span class="ot">=</span> mkFixpoints commutatorLeft</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    commutatorsRight <span class="ot">=</span> mkFixpoints commutatorRight</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    pointLeft  x <span class="ot">=</span> commutatorsLeft  <span class="op">!</span> x</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    pointRight x <span class="ot">=</span> commutatorsRight <span class="op">!</span> x</span></code></pre></div>
<p>We can now define the list of limit points</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    points <span class="ot">=</span> <span class="fu">concatMap</span> (\x <span class="ot">-&gt;</span> dfs <span class="fu">mempty</span> x <span class="op">$</span> pointRight x) [<span class="dt">A</span>,<span class="dt">B</span>,<span class="dt">A1</span>,<span class="dt">B1</span>]</span></code></pre></div>
<p>by performing a depth-first search</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">    dfs ::</span> <span class="dt">Moebius</span> <span class="ot">-&gt;</span> <span class="dt">Letter</span> <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="ot">-&gt;</span> [<span class="dt">C</span>]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    dfs w g z <span class="ot">=</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> Complex.magnitude (l <span class="op">-</span> z) <span class="op">&lt;=</span> eps <span class="kw">then</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>            [l]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>                rs <span class="ot">=</span> dfs w' (right  ns) z</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>                ms <span class="ot">=</span> dfs w' (middle ns) (<span class="fu">head</span> rs)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>                ls <span class="ot">=</span> dfs w' (left   ns) (<span class="fu">head</span> ms)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">in</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>                ls <span class="op">++</span> ms <span class="op">++</span> rs</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        l  <span class="ot">=</span> applyMoebius w <span class="op">$</span> pointLeft g</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        w' <span class="ot">=</span> w <span class="ot">`mappend`</span> fromLetter g</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        ns <span class="ot">=</span> next g</span></code></pre></div>
<h1 id="utilities">Utilities</h1>
<p>Solve a quadratic equation.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solveQuadratic ::</span> <span class="dt">Floating</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a,a)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>solveQuadratic a b c <span class="ot">=</span> (x1,x2)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    p2 <span class="ot">=</span> b<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>a)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    q  <span class="ot">=</span> c<span class="op">/</span>a</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    x1 <span class="ot">=</span> <span class="op">-</span>p2 <span class="op">+</span> <span class="fu">sqrt</span> (p2<span class="op">*</span>p2 <span class="op">-</span> q)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    x2 <span class="ot">=</span> <span class="op">-</span>(<span class="dv">2</span><span class="op">*</span>p2 <span class="op">+</span> x1)</span></code></pre></div>
<p>Grandma’s special recipe to make two Moebius tranformations from two complex parameters. (Box 21, page 226.)</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">grandma ::</span> <span class="dt">C</span> <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="ot">-&gt;</span> (<span class="dt">Moebius</span>, <span class="dt">Moebius</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>grandma ta tb <span class="ot">=</span> (a,b)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    tab <span class="ot">=</span> <span class="fu">snd</span> <span class="op">$</span> solveQuadratic <span class="dv">1</span> (<span class="op">-</span>ta<span class="op">*</span>tb) (ta<span class="op">*</span>ta <span class="op">+</span> tb<span class="op">*</span>tb)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    z0  <span class="ot">=</span> (tab <span class="op">-</span> <span class="dv">2</span>)<span class="op">*</span>tb <span class="op">/</span> (tb<span class="op">*</span>tab <span class="op">-</span> <span class="dv">2</span><span class="op">*</span>ta <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>i<span class="op">*</span>tab)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    b   <span class="ot">=</span> <span class="dt">M</span> ((tb<span class="op">-</span><span class="dv">2</span><span class="op">*</span>i)<span class="op">/</span><span class="dv">2</span>) (tb<span class="op">/</span><span class="dv">2</span>) (tb<span class="op">/</span><span class="dv">2</span>) ((tb<span class="op">+</span><span class="dv">2</span><span class="op">*</span>i)<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    ab  <span class="ot">=</span> <span class="dt">M</span> (tab<span class="op">/</span><span class="dv">2</span>) ((tab<span class="op">-</span><span class="dv">2</span>)<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>z0)) ((tab<span class="op">+</span><span class="dv">2</span>)<span class="op">*</span>z0<span class="op">/</span><span class="dv">2</span>) (tab<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    a   <span class="ot">=</span> ab <span class="ot">`mappend`</span> inverse b</span></code></pre></div>
<h1 id="actual-drawing">Actual drawing</h1>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    (    diagram <span class="fl">0.01</span> <span class="fl">2.5</span> <span class="fl">2.5</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>     <span class="op">|||</span> diagram <span class="fl">0.01</span> (<span class="fl">2.09</span>) (<span class="fl">2.09</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">===</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    (    diagram <span class="fl">0.004</span> (<span class="fl">1.9</span> <span class="op">:+</span> <span class="fl">0.1</span>) (<span class="fl">2.4</span> <span class="op">:+</span> <span class="fl">0.1</span>)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>     <span class="op">|||</span> diagram <span class="fl">0.004</span> (<span class="dv">2</span> <span class="op">:+</span> <span class="fl">0.2</span>) (<span class="dv">2</span> <span class="op">:+</span> (<span class="op">-</span><span class="fl">0.2</span>))</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>diagram eps ta tb</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> fc (sRGB24read <span class="st">&quot;#DB4105&quot;</span>) <span class="op">$</span> lw none <span class="op">$</span> pad <span class="fl">1.1</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> strokeT</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> closeTrail</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> fromVertices [origin <span class="op">.+^</span> r2 (x,y) <span class="op">|</span> x <span class="op">:+</span> y <span class="ot">&lt;-</span> limitPoints eps a b]</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> (a,b) <span class="ot">=</span> grandma ta tb</span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> mainWith (<span class="ot">example ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>)</span></code></pre></div>

</div>

    </div>

    </div> <!-- #wrap -->

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/bootstrap-docs-application.js"></script>
    <script src="../js/hoogle-search.js"></script>
  </body>
</html>
